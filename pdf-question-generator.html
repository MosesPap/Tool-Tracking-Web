<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="format-detection" content="telephone=no">
    <title>PDF Question Generator - Tool Tracking</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <link rel="stylesheet" href="css/common.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .main-container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .card {
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            border: none;
            margin-bottom: 20px;
        }

        .card-header {
            background: linear-gradient(135deg, #FF9800 0%, #F57C00 100%);
            color: white;
            border-radius: 15px 15px 0 0 !important;
            padding: 20px;
            font-weight: bold;
            font-size: 1.5rem;
        }

        .upload-area {
            border: 3px dashed #667eea;
            border-radius: 10px;
            padding: 40px;
            text-align: center;
            background: white;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .upload-area:hover {
            border-color: #764ba2;
            background: #f8f9fa;
        }

        .upload-area.dragover {
            border-color: #FF9800;
            background: #fff3e0;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 8px;
            padding: 12px 30px;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-success {
            background: linear-gradient(135deg, #4CAF50 0%, #388E3C 100%);
            border: none;
            border-radius: 8px;
            padding: 12px 30px;
            font-weight: bold;
        }

        .btn-danger {
            background: linear-gradient(135deg, #f44336 0%, #d32f2f 100%);
            border: none;
            border-radius: 8px;
            padding: 12px 30px;
            font-weight: bold;
        }

        .question-card {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            border-left: 4px solid #667eea;
        }

        .question-number {
            font-weight: bold;
            color: #667eea;
            font-size: 1.2rem;
            margin-bottom: 10px;
        }

        .question-text {
            font-size: 1.1rem;
            margin-bottom: 15px;
            color: #333;
        }

        .option {
            padding: 12px;
            margin: 8px 0;
            border-radius: 8px;
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .option:hover {
            background: #e9ecef;
            border-color: #667eea;
        }

        .option.correct {
            background: #d4edda;
            border-color: #4CAF50;
            color: #155724;
        }

        .option.incorrect {
            background: #f8d7da;
            border-color: #f44336;
            color: #721c24;
        }

        .loading-spinner {
            display: none;
            text-align: center;
            padding: 40px;
        }

        .loading-spinner.active {
            display: block;
        }

        .spinner-border {
            width: 3rem;
            height: 3rem;
            border-width: 0.3em;
        }

        .api-key-section {
            background: #fff3cd;
            border: 2px solid #ffc107;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .pdf-preview {
            max-height: 400px;
            overflow-y: auto;
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .settings-section {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .form-label {
            font-weight: bold;
            color: #333;
        }

        .alert {
            border-radius: 8px;
            border: none;
        }
    </style>
</head>
<body>
    <div class="main-container">
        <div class="card">
            <div class="card-header">
                <i class="fas fa-file-pdf me-2"></i>
                PDF Question Generator
            </div>
            <div class="card-body p-4">
                <!-- API Key Section -->
                <div class="api-key-section" style="background: #d4edda; border-color: #28a745;">
                    <h5><i class="fas fa-key me-2"></i>Google Gemini API Configuration (FREE!)</h5>
                    <p class="mb-2"><strong>Free to use!</strong> Google Gemini offers a generous free tier. Enter your API key to generate questions. Your key is stored locally and never sent to our servers.</p>
                    <div class="input-group mb-2">
                        <span class="input-group-text"><i class="fas fa-lock"></i></span>
                        <input type="password" id="apiKey" class="form-control" placeholder="AIza..." value="">
                        <button class="btn btn-outline-secondary" type="button" id="toggleApiKey">
                            <i class="fas fa-eye"></i>
                        </button>
                    </div>
                    <small class="text-muted">
                        Get your FREE API key from <a href="https://aistudio.google.com/app/apikey" target="_blank">Google AI Studio</a> (No credit card required!)
                        <br>
                        <strong>Note:</strong> The default project works fine! Just create an API key from Google AI Studio - no need to create a new project.
                    </small>
                    <div class="mt-2">
                        <button class="btn btn-sm btn-info" id="testApiKeyBtn" onclick="testApiKey()">
                            <i class="fas fa-check-circle me-1"></i>Test API Key
                        </button>
                        <small id="apiKeyStatus" class="ms-2"></small>
                    </div>
                </div>

                <!-- Settings Section -->
                <div class="settings-section">
                    <h5><i class="fas fa-cog me-2"></i>Generation Settings</h5>
                    <div class="row">
                        <div class="col-md-4 mb-3">
                            <label class="form-label">Number of Questions</label>
                            <input type="number" id="numQuestions" class="form-control" value="5" min="1" max="20">
                        </div>
                        <div class="col-md-4 mb-3">
                            <label class="form-label">Knowledge Level</label>
                            <select id="knowledgeLevel" class="form-select">
                                <option value="1">Level 1 - Familiarisation</option>
                                <option value="2" selected>Level 2 - General Knowledge</option>
                                <option value="3">Level 3 - Detailed Knowledge</option>
                            </select>
                            <small class="text-muted" id="levelDescription"></small>
                        </div>
                        <div class="col-md-4 mb-3">
                            <label class="form-label">Page Range</label>
                            <div class="input-group">
                                <input type="number" id="startPage" class="form-control" placeholder="Start" value="1" min="1" max="1000">
                                <span class="input-group-text">to</span>
                                <input type="number" id="endPage" class="form-control" placeholder="End" value="0" min="0" max="1000">
                            </div>
                            <small class="text-muted">Leave End as 0 for all pages from start</small>
                        </div>
                    </div>
                </div>

                <!-- PDF Upload Section -->
                <div class="upload-area" id="uploadArea">
                    <i class="fas fa-cloud-upload-alt fa-3x mb-3 text-primary"></i>
                    <h4>Drop your PDF file here</h4>
                    <p class="text-muted">or click to browse</p>
                    <input type="file" id="pdfFile" accept=".pdf" style="display: none;">
                    <button class="btn btn-primary mt-3" onclick="document.getElementById('pdfFile').click()">
                        <i class="fas fa-file-pdf me-2"></i>Select PDF File
                    </button>
                </div>

                <div id="fileInfo" class="mt-3" style="display: none;">
                    <div class="alert alert-info">
                        <i class="fas fa-file-pdf me-2"></i>
                        <span id="fileName"></span>
                        <button class="btn btn-sm btn-danger float-end" onclick="clearFile()">
                            <i class="fas fa-times"></i> Remove
                        </button>
                    </div>
                </div>

                <!-- PDF Text Preview -->
                <div id="pdfPreview" style="display: none;">
                    <h5 class="mt-4 mb-3"><i class="fas fa-eye me-2"></i>Extracted Text Preview</h5>
                    <div class="pdf-preview" id="extractedText"></div>
                </div>

                <!-- Generate Button -->
                <div class="text-center mt-4" id="generateSection" style="display: none;">
                    <button class="btn btn-success btn-lg" id="generateBtn">
                        <i class="fas fa-magic me-2"></i>Generate Questions
                    </button>
                </div>

                <!-- Loading Spinner -->
                <div class="loading-spinner" id="loadingSpinner">
                    <div class="spinner-border text-primary" role="status">
                        <span class="visually-hidden">Loading...</span>
                    </div>
                    <p class="mt-3">Processing PDF and generating questions...</p>
                </div>

                <!-- Questions Display -->
                <div id="questionsContainer" style="display: none;">
                    <h4 class="mt-4 mb-3">
                        <i class="fas fa-question-circle me-2"></i>Generated Questions
                        <span class="badge bg-info ms-2" id="levelBadge"></span>
                    </h4>
                    <div id="questionsList"></div>
                    <div class="text-center mt-4">
                        <button class="btn btn-primary" onclick="exportQuestions()">
                            <i class="fas fa-file-excel me-2"></i>Export to Excel
                        </button>
                        <button class="btn btn-secondary ms-2" onclick="clearAll()">
                            <i class="fas fa-redo me-2"></i>Start Over
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // Set up PDF.js worker
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        let pdfText = '';
        let questions = [];
        let availableModels = []; // Store available models from API

        // Load API key from localStorage
        const savedApiKey = localStorage.getItem('gemini_api_key');
        if (savedApiKey) {
            document.getElementById('apiKey').value = savedApiKey;
        }

        // Toggle API key visibility
        document.getElementById('toggleApiKey').addEventListener('click', function() {
            const apiKeyInput = document.getElementById('apiKey');
            const icon = this.querySelector('i');
            if (apiKeyInput.type === 'password') {
                apiKeyInput.type = 'text';
                icon.classList.remove('fa-eye');
                icon.classList.add('fa-eye-slash');
            } else {
                apiKeyInput.type = 'password';
                icon.classList.remove('fa-eye-slash');
                icon.classList.add('fa-eye');
            }
        });

        // Save API key when changed and clear cached models
        document.getElementById('apiKey').addEventListener('change', function() {
            localStorage.setItem('gemini_api_key', this.value);
            availableModels = []; // Clear cached models when key changes
        });

        // Update level description when knowledge level changes
        const knowledgeLevelSelect = document.getElementById('knowledgeLevel');
        const levelDescriptionEl = document.getElementById('levelDescription');
        
        const levelDescriptions = {
            1: "Basic familiarity with principal elements",
            2: "General theoretical and practical knowledge",
            3: "Detailed theoretical and practical knowledge"
        };
        
        function updateLevelDescription() {
            const level = parseInt(knowledgeLevelSelect.value);
            currentKnowledgeLevel = level;
            levelDescriptionEl.textContent = levelDescriptions[level];
        }
        
        knowledgeLevelSelect.addEventListener('change', updateLevelDescription);
        updateLevelDescription(); // Initialize

        // File upload handling
        const uploadArea = document.getElementById('uploadArea');
        const pdfFileInput = document.getElementById('pdfFile');

        uploadArea.addEventListener('click', () => pdfFileInput.click());

        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0 && files[0].type === 'application/pdf') {
                handleFile(files[0]);
            }
        });

        pdfFileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFile(e.target.files[0]);
            }
        });

        async function handleFile(file) {
            document.getElementById('fileName').textContent = file.name;
            document.getElementById('fileInfo').style.display = 'block';
            document.getElementById('pdfPreview').style.display = 'none';
            document.getElementById('generateSection').style.display = 'none';
            document.getElementById('questionsContainer').style.display = 'none';

            try {
                const arrayBuffer = await file.arrayBuffer();
                const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                
                let fullText = '';
                let startPage = parseInt(document.getElementById('startPage').value) || 1;
                let endPage = parseInt(document.getElementById('endPage').value) || 0;
                
                // Validate and set page range
                if (startPage < 1) startPage = 1;
                if (startPage > pdf.numPages) startPage = pdf.numPages;
                if (endPage === 0 || endPage > pdf.numPages) endPage = pdf.numPages;
                if (endPage < startPage) endPage = startPage;
                
                const pagesToProcess = endPage - startPage + 1;
                
                // Show progress for large PDFs
                if (pdf.numPages > 10) {
                    document.getElementById('fileInfo').innerHTML = `
                        <div class="alert alert-info">
                            <i class="fas fa-file-pdf me-2"></i>
                            <span id="fileName">${file.name}</span>
                            <span class="ms-2">Processing pages ${startPage}-${endPage} (${pagesToProcess} pages) of ${pdf.numPages} total...</span>
                            <button class="btn btn-sm btn-danger float-end" onclick="clearFile()">
                                <i class="fas fa-times"></i> Remove
                            </button>
                        </div>
                    `;
                }
                
                for (let i = startPage; i <= endPage; i++) {
                    const page = await pdf.getPage(i);
                    const textContent = await page.getTextContent();
                    const pageText = textContent.items.map(item => item.str).join(' ');
                    fullText += pageText + '\n\n';
                }
                
                if (startPage > 1 || endPage < pdf.numPages) {
                    fullText += `\n[Note: Processed pages ${startPage}-${endPage} out of ${pdf.numPages} total pages]`;
                }

                pdfText = fullText;
                
                // Show preview (truncated if too long)
                const previewText = fullText.length > 2000 ? fullText.substring(0, 2000) + '...' : fullText;
                document.getElementById('extractedText').textContent = previewText;
                document.getElementById('pdfPreview').style.display = 'block';
                document.getElementById('generateSection').style.display = 'block';
            } catch (error) {
                alert('Error reading PDF: ' + error.message);
                console.error(error);
            }
        }

        function clearFile() {
            pdfFileInput.value = '';
            pdfText = '';
            document.getElementById('fileInfo').style.display = 'none';
            document.getElementById('pdfPreview').style.display = 'none';
            document.getElementById('generateSection').style.display = 'none';
            document.getElementById('questionsContainer').style.display = 'none';
        }

        function clearAll() {
            clearFile();
            questions = [];
            document.getElementById('questionsList').innerHTML = '';
        }

        document.getElementById('generateBtn').addEventListener('click', generateQuestions);

        // Function to test API key and list available models
        async function testApiKey() {
            const apiKey = document.getElementById('apiKey').value.trim();
            if (!apiKey) {
                alert('Please enter your API key first');
                return;
            }

            const statusEl = document.getElementById('apiKeyStatus');
            statusEl.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Testing...';
            statusEl.className = 'ms-2 text-info';

            try {
                // Try to list available models
                const response = await fetch(`https://generativelanguage.googleapis.com/v1/models?key=${apiKey}`);
                
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.error?.message || `HTTP ${response.status}`);
                }

                const data = await response.json();
                const models = data.models || [];
                
                // Get models that support generateContent and are Gemini models
                const geminiModels = models
                    .filter(m => {
                        const name = m.name.toLowerCase();
                        return name.includes('gemini') && 
                               m.supportedGenerationMethods && 
                               m.supportedGenerationMethods.includes('generateContent');
                    })
                    .map(m => {
                        // Extract just the model name (remove 'models/' prefix)
                        return m.name.replace('models/', '');
                    });
                
                // Store available models globally
                availableModels = geminiModels;
                
                if (geminiModels.length > 0) {
                    statusEl.innerHTML = `<i class="fas fa-check-circle text-success"></i> API Key works! Available models: ${geminiModels.length}`;
                    statusEl.className = 'ms-2 text-success';
                    console.log('Available Gemini models with generateContent:', geminiModels);
                } else {
                    statusEl.innerHTML = '<i class="fas fa-exclamation-triangle text-warning"></i> API Key works but no Gemini models found';
                    statusEl.className = 'ms-2 text-warning';
                    availableModels = [];
                }
            } catch (error) {
                statusEl.innerHTML = `<i class="fas fa-times-circle text-danger"></i> Error: ${error.message}`;
                statusEl.className = 'ms-2 text-danger';
                console.error('API Key test failed:', error);
                availableModels = [];
            }
        }

        async function generateQuestions() {
            const apiKey = document.getElementById('apiKey')?.value?.trim();
            if (!apiKey) {
                alert('Please enter your Google Gemini API key');
                return;
            }

            if (!pdfText) {
                alert('Please upload a PDF file first');
                return;
            }

            // Save API key
            localStorage.setItem('gemini_api_key', apiKey);

            // Get form values with null checks
            const numQuestionsEl = document.getElementById('numQuestions');
            const knowledgeLevelEl = document.getElementById('knowledgeLevel');
            
            if (!numQuestionsEl || !knowledgeLevelEl) {
                alert('Error: Form elements not found. Please refresh the page.');
                console.error('Missing form elements:', { numQuestionsEl, knowledgeLevelEl });
                return;
            }

            const numQuestions = parseInt(numQuestionsEl.value) || 5;
            const knowledgeLevel = parseInt(knowledgeLevelEl.value) || 2;
                
                // Define level objectives
                const levelObjectives = {
                    1: {
                        name: "Level 1 - Familiarisation",
                        description: "Familiarisation with the principal elements of the subject",
                        objectives: [
                            "The applicant should be familiar with the basic elements of the subject",
                            "The applicant should be able to give a simple description of the whole subject using common words and examples",
                            "The applicant should be able to use typical terms"
                        ]
                    },
                    2: {
                        name: "Level 2 - General Knowledge",
                        description: "General knowledge of the theoretical and practical aspects of the subject",
                        objectives: [
                            "The applicant should be able to understand the theoretical fundamentals of the subject",
                            "The applicant should be able to give a general description of the subject using typical examples",
                            "The applicant should be able to use mathematical formulae in conjunction with physical laws",
                            "The applicant should be able to read and understand sketches, drawings and schematics",
                            "The applicant should be able to apply knowledge in a practical manner using detailed procedures"
                        ]
                    },
                    3: {
                        name: "Level 3 - Detailed Knowledge",
                        description: "Detailed knowledge of the theoretical and practical aspects of the subject",
                        objectives: [
                            "The applicant should know the theory of the subject and its interrelationships with other subjects",
                            "The applicant should be able to give a detailed description using theoretical fundamentals and specific examples",
                            "The applicant should understand and be able to use mathematical formulae related to the subject",
                            "The applicant should be able to read, understand and prepare sketches, simple drawings and schematics",
                            "The applicant should be able to apply knowledge in a practical manner using manufacturer's instructions",
                            "The applicant should be able to interpret results from various sources and measurements and apply corrective action"
                        ]
                    }
                };
                
                const levelInfo = levelObjectives[knowledgeLevel];

            document.getElementById('loadingSpinner').classList.add('active');
            document.getElementById('generateSection').style.display = 'none';
            document.getElementById('questionsContainer').style.display = 'none';

            try {
                // Truncate text to prevent MAX_TOKENS error
                // Reduce text size based on number of questions to ensure enough output tokens
                // For 5 questions, we need ~3000-4000 output tokens, so limit input to ~20000 chars
                const baseLength = 20000;
                const lengthPerQuestion = 3000;
                const maxLength = baseLength + (numQuestions * lengthPerQuestion);
                const adjustedLength = Math.min(maxLength, 50000); // Cap at 50K to ensure output space
                
                const textToUse = pdfText.length > adjustedLength 
                    ? pdfText.substring(0, adjustedLength) + '\n\n[Text truncated to ensure sufficient output tokens]' 
                    : pdfText;
                
                console.log(`Using ${textToUse.length} characters from PDF (${pdfText.length} total available)`);

                const prompt = `Based on the following text from a PDF document, generate ${numQuestions} multiple choice questions at ${levelInfo.name}.

KNOWLEDGE LEVEL REQUIREMENTS:
${levelInfo.description}

The questions must align with these objectives:
${levelInfo.objectives.map((obj, idx) => `${idx + 1}. ${obj}`).join('\n')}

Each question should have:
- A clear question stem appropriate for ${levelInfo.name}
- 3 answer options (A, B, C)
- One correct answer clearly marked
- Questions should test knowledge at the specified level depth
- Questions should be varied in style (factual, comprehension, application, analysis) as appropriate for the level

Format the response as a JSON array with this structure:
[
  {
    "question": "Question text here?",
    "options": {
      "A": "Option A text",
      "B": "Option B text",
      "C": "Option C text"
    },
    "correct": "A"
  }
]

Text content:
${textToUse}

Return ONLY the JSON array, no additional text or markdown formatting.`;

                // Get available models (use cached ones or fetch fresh)
                let modelsToTry = [];
                
                if (availableModels.length > 0) {
                    // Use cached models from test
                    modelsToTry = availableModels;
                    console.log('Using cached available models:', modelsToTry);
                } else {
                    // Try to fetch models if not cached
                    try {
                        const listResponse = await fetch(`https://generativelanguage.googleapis.com/v1/models?key=${apiKey}`);
                        if (listResponse.ok) {
                            const listData = await listResponse.json();
                            modelsToTry = (listData.models || [])
                                .filter(m => {
                                    const name = m.name.toLowerCase();
                                    return name.includes('gemini') && 
                                           m.supportedGenerationMethods && 
                                           m.supportedGenerationMethods.includes('generateContent');
                                })
                                .map(m => m.name.replace('models/', ''));
                            console.log('Fetched available models:', modelsToTry);
                        }
                    } catch (e) {
                        console.log('Could not list models:', e);
                    }
                    
                    // Fallback to default models if still empty
                    if (modelsToTry.length === 0) {
                        modelsToTry = [
                            'gemini-1.5-flash',
                            'gemini-1.5-pro', 
                            'gemini-pro'
                        ];
                        console.log('Using default models:', modelsToTry);
                    }
                }

                let data = null;
                let lastError = null;
                let successfulModel = null;

                for (const model of modelsToTry) {
                    try {
                        // Try both v1 and v1beta endpoints
                        const endpoints = [
                            `https://generativelanguage.googleapis.com/v1/models/${model}:generateContent?key=${apiKey}`,
                            `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`
                        ];

                        for (const url of endpoints) {
                            try {
                                const response = await fetch(url, {
                                    method: 'POST',
                                    headers: {
                                        'Content-Type': 'application/json'
                                    },
                                    body: JSON.stringify({
                                        contents: [{
                                            parts: [{
                                                text: prompt
                                            }]
                                        }],
                                        generationConfig: {
                                            temperature: 0.7,
                                            maxOutputTokens: Math.max(4096, numQuestions * 1000)  // Scale with number of questions, min 4K
                                        }
                                    })
                                });

                                if (response.ok) {
                                    data = await response.json();
                                    
                                    // Check if response indicates an error even with 200 status
                                    if (data.error) {
                                        lastError = data.error.message || 'API returned an error';
                                        console.log(`Model ${model} returned error:`, data.error);
                                        continue; // Try next endpoint
                                    }
                                    
                                    successfulModel = model;
                                    console.log(`Successfully used model: ${model} with endpoint: ${url}`);
                                    console.log('API Response structure:', JSON.stringify(data, null, 2));
                                    break; // Success, exit endpoint loop
                                } else {
                                    const errorData = await response.json().catch(() => ({}));
                                    lastError = errorData.error?.message || `HTTP ${response.status}: ${response.statusText}`;
                                    console.log(`Model ${model} failed with ${url}:`, lastError);
                                }
                            } catch (err) {
                                lastError = err.message;
                                console.log(`Model ${model} error with ${url}:`, err.message);
                            }
                        }

                        if (data) break; // Success, exit model loop
                    } catch (err) {
                        lastError = err.message;
                        console.log(`Model ${model} error:`, err.message);
                        continue; // Try next model
                    }
                }

                if (!data) {
                    throw new Error(lastError || 'Failed to generate questions. Please check your API key and ensure the Generative AI API is enabled in your Google Cloud project.');
                }

                // Handle different response structures from Gemini API
                let content = '';
                console.log('Parsing response, data structure:', data);
                
                // Check for finish reason
                if (data.candidates && data.candidates[0] && data.candidates[0].finishReason) {
                    const finishReason = data.candidates[0].finishReason;
                    if (finishReason === 'MAX_TOKENS') {
                        console.warn('Response was truncated due to MAX_TOKENS limit. Consider reducing number of questions or text length.');
                    }
                }
                
                // Try multiple possible response structures
                if (data.candidates && Array.isArray(data.candidates) && data.candidates.length > 0) {
                    const candidate = data.candidates[0];
                    console.log('Found candidate:', candidate);
                    
                    // Check if content.parts exists and has data
                    if (candidate.content && candidate.content.parts && Array.isArray(candidate.content.parts) && candidate.content.parts.length > 0) {
                        // Standard structure: candidates[0].content.parts[0].text
                        const part = candidate.content.parts[0];
                        if (part.text) {
                            content = part.text;
                            console.log('Extracted from candidate.content.parts[0].text');
                        } else if (part.functionCall) {
                            // Handle function calls if any
                            console.warn('Response contains function call, not text');
                        }
                    } else if (candidate.text) {
                        // Alternative: candidates[0].text
                        content = candidate.text;
                        console.log('Extracted from candidate.text');
                    } else if (candidate.content && typeof candidate.content === 'string') {
                        // Another alternative: candidates[0].content as string
                        content = candidate.content;
                        console.log('Extracted from candidate.content (string)');
                    } else {
                        // Content structure exists but no parts - might be truncated
                        console.warn('Candidate content exists but no parts found. Response may be truncated.');
                        console.log('Candidate content:', candidate.content);
                    }
                } else if (data.text) {
                    // Direct text property
                    content = data.text;
                    console.log('Extracted from data.text');
                } else if (data.content) {
                    if (typeof data.content === 'string') {
                        content = data.content;
                        console.log('Extracted from data.content (string)');
                    } else if (data.content.parts && Array.isArray(data.content.parts) && data.content.parts.length > 0) {
                        content = data.content.parts[0].text || '';
                        console.log('Extracted from data.content.parts[0].text');
                    }
                } else if (data.response && data.response.text) {
                    // Another possible structure
                    content = data.response.text;
                    console.log('Extracted from data.response.text');
                } else {
                    console.error('Unexpected response structure. Full data:', JSON.stringify(data, null, 2));
                    throw new Error('Unexpected response format from API. Check console for details.');
                }

                if (!content || content.trim() === '') {
                    const finishReason = data.candidates?.[0]?.finishReason;
                    let errorMsg = 'No content received from API. ';
                    if (finishReason === 'MAX_TOKENS') {
                        errorMsg += 'Response was truncated due to token limit. Try reducing the number of questions or the text length.';
                    } else {
                        errorMsg += 'The response may be empty or in an unexpected format.';
                    }
                    console.error('Content is empty. Full response:', JSON.stringify(data, null, 2));
                    throw new Error(errorMsg);
                }

                content = content.trim();
                
                // Clean up the response (remove markdown code blocks if present)
                let jsonContent = content;
                if (content.startsWith('```')) {
                    jsonContent = content.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
                }

                questions = JSON.parse(jsonContent);
                
                // Update level badge
                const levelNames = {
                    1: "Level 1 - Familiarisation",
                    2: "Level 2 - General Knowledge",
                    3: "Level 3 - Detailed Knowledge"
                };
                document.getElementById('levelBadge').textContent = levelNames[currentKnowledgeLevel] || "Unknown Level";
                
                displayQuestions();
            } catch (error) {
                alert('Error generating questions: ' + error.message + '\n\nMake sure your API key is correct and you have not exceeded the free tier limits.');
                console.error(error);
            } finally {
                document.getElementById('loadingSpinner').classList.remove('active');
                document.getElementById('generateSection').style.display = 'block';
            }
        }

        function displayQuestions() {
            const container = document.getElementById('questionsList');
            container.innerHTML = '';

            questions.forEach((q, index) => {
                const questionCard = document.createElement('div');
                questionCard.className = 'question-card';
                
                const questionHtml = `
                    <div class="question-number">Question ${index + 1}</div>
                    <div class="question-text">${q.question}</div>
                    <div class="options">
                        ${Object.entries(q.options).map(([key, value]) => 
                            `<div class="option" data-option="${key}">
                                <strong>${key}.</strong> ${value}
                            </div>`
                        ).join('')}
                    </div>
                    <div class="mt-3">
                        <small class="text-muted">
                            <strong>Correct Answer:</strong> <span class="badge bg-success">${q.correct}</span>
                        </small>
                    </div>
                `;
                
                questionCard.innerHTML = questionHtml;
                
                // Add click handlers to show correct/incorrect
                const options = questionCard.querySelectorAll('.option');
                options.forEach(option => {
                    option.addEventListener('click', function() {
                        const selectedOption = this.dataset.option;
                        options.forEach(opt => {
                            opt.classList.remove('correct', 'incorrect');
                            if (opt.dataset.option === q.correct) {
                                opt.classList.add('correct');
                            } else if (opt.dataset.option === selectedOption && selectedOption !== q.correct) {
                                opt.classList.add('incorrect');
                            }
                        });
                    });
                });
                
                container.appendChild(questionCard);
            });

            document.getElementById('questionsContainer').style.display = 'block';
        }

        function exportQuestions() {
            try {
                // Create Excel workbook
                const wb = XLSX.utils.book_new();
                
                // Get level name
                const levelNames = {
                    1: "Level 1 - Familiarisation",
                    2: "Level 2 - General Knowledge",
                    3: "Level 3 - Detailed Knowledge"
                };
                const levelName = levelNames[currentKnowledgeLevel] || "Unknown Level";
                
                // Prepare data for Excel - horizontal format
                const excelData = [
                    // Header row with level info
                    ['Knowledge Level', levelName, '', '', ''],
                    ['', '', '', '', ''],
                    ['Question', 'Option A', 'Option B', 'Option C', 'Correct Answer']
                ];
                
                // Add each question as a row
                questions.forEach((q, index) => {
                    const row = [
                        q.question,
                        q.options.A || '',
                        q.options.B || '',
                        q.options.C || '',
                        q.correct
                    ];
                    excelData.push(row);
                });
                
                // Create worksheet
                const ws = XLSX.utils.aoa_to_sheet(excelData);
                
                // Set column widths for better readability
                ws['!cols'] = [
                    { wch: 60 },  // Question column - wider
                    { wch: 40 },  // Option A
                    { wch: 40 },  // Option B
                    { wch: 40 },  // Option C
                    { wch: 15 }   // Correct Answer
                ];
                
                // Add worksheet to workbook
                XLSX.utils.book_append_sheet(wb, ws, 'Questions');
                
                // Generate Excel file and download
                const fileName = `generated_questions_${new Date().toISOString().split('T')[0]}.xlsx`;
                XLSX.writeFile(wb, fileName);
                
                // Show success message
                alert(`Questions exported successfully to ${fileName}`);
            } catch (error) {
                console.error('Export error:', error);
                alert('Error exporting to Excel. Trying text format instead...');
                
                // Fallback to text export
                let exportText = 'PDF Question Generator - Generated Questions\n';
                exportText += '='.repeat(50) + '\n\n';

                questions.forEach((q, index) => {
                    exportText += `Question ${index + 1}: ${q.question}\n\n`;
                    Object.entries(q.options).forEach(([key, value]) => {
                        exportText += `  ${key}. ${value}\n`;
                    });
                    exportText += `\nCorrect Answer: ${q.correct}\n\n`;
                    exportText += '-'.repeat(50) + '\n\n';
                });

                const blob = new Blob([exportText], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'generated_questions.txt';
                a.click();
                URL.revokeObjectURL(url);
            }
        }
    </script>
</body>
</html>

