<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="format-detection" content="telephone=no">
    <title>PDF Question Generator - Tool Tracking</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <link rel="stylesheet" href="css/common.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://apis.google.com/js/api.js"></script>
    <script src="https://accounts.google.com/gsi/client"></script>
    <style>
        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .main-container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .card {
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            border: none;
            margin-bottom: 20px;
        }

        .card-header {
            background: linear-gradient(135deg, #FF9800 0%, #F57C00 100%);
            color: white;
            border-radius: 15px 15px 0 0 !important;
            padding: 20px;
            font-weight: bold;
            font-size: 1.5rem;
        }

        .upload-area {
            border: 3px dashed #667eea;
            border-radius: 10px;
            padding: 40px;
            text-align: center;
            background: white;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .upload-area:hover {
            border-color: #764ba2;
            background: #f8f9fa;
        }

        .upload-area.dragover {
            border-color: #FF9800;
            background: #fff3e0;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 8px;
            padding: 12px 30px;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-success {
            background: linear-gradient(135deg, #4CAF50 0%, #388E3C 100%);
            border: none;
            border-radius: 8px;
            padding: 12px 30px;
            font-weight: bold;
        }

        .btn-danger {
            background: linear-gradient(135deg, #f44336 0%, #d32f2f 100%);
            border: none;
            border-radius: 8px;
            padding: 12px 30px;
            font-weight: bold;
        }

        .edit-question-form {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #007bff;
        }

        .edit-question-form .form-label {
            font-weight: 600;
            color: #495057;
        }

        .question-card {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            border-left: 4px solid #667eea;
            position: relative;
        }

        .question-card.selected {
            border-left: 4px solid #28a745;
            background: #f8fff9;
        }

        .question-checkbox {
            width: 20px;
            height: 20px;
            cursor: pointer;
            margin-right: 8px;
        }

        .question-number {
            font-weight: bold;
            color: #667eea;
            font-size: 1.2rem;
            margin-bottom: 10px;
        }

        .question-text {
            font-size: 1.1rem;
            margin-bottom: 15px;
            color: #333;
        }

        .option {
            padding: 12px;
            margin: 8px 0;
            border-radius: 8px;
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .option:hover {
            background: #e9ecef;
            border-color: #667eea;
        }

        .option.correct {
            background: #d4edda;
            border-color: #4CAF50;
            color: #155724;
        }

        .option.incorrect {
            background: #f8d7da;
            border-color: #f44336;
            color: #721c24;
        }

        .loading-spinner {
            display: none;
            text-align: center;
            padding: 40px;
        }

        .loading-spinner.active {
            display: block;
        }

        .spinner-border {
            width: 3rem;
            height: 3rem;
            border-width: 0.3em;
        }

        .api-key-section {
            background: #fff3cd;
            border: 2px solid #ffc107;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .pdf-preview {
            max-height: 400px;
            overflow-y: auto;
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .settings-section {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .form-label {
            font-weight: bold;
            color: #333;
        }

        .alert {
            border-radius: 8px;
            border: none;
        }
    </style>
</head>
<body>
    <div class="main-container">
        <div class="card">
            <div class="card-header">
                <i class="fas fa-file-pdf me-2"></i>
                PDF Question Generator
            </div>
            <div class="card-body p-4">
                <!-- API Key Section -->
                <div class="api-key-section" style="background: #d4edda; border-color: #28a745;">
                    <h5><i class="fas fa-key me-2"></i>Google Gemini API Configuration (FREE!)</h5>
                    <p class="mb-2"><strong>Free to use!</strong> Google Gemini offers a generous free tier. Enter your API key to generate questions. Your key is stored locally and never sent to our servers.</p>
                    <div class="input-group mb-2">
                        <span class="input-group-text"><i class="fas fa-lock"></i></span>
                        <input type="password" id="apiKey" class="form-control" placeholder="AIza..." value="">
                        <button class="btn btn-outline-secondary" type="button" id="toggleApiKey">
                            <i class="fas fa-eye"></i>
                        </button>
                    </div>
                    <small class="text-muted">
                        Get your FREE API key from <a href="https://aistudio.google.com/app/apikey" target="_blank">Google AI Studio</a> (No credit card required!)
                        <br>
                        <strong>Note:</strong> The default project works fine! Just create an API key from Google AI Studio - no need to create a new project.
                    </small>
                    <div class="mt-2">
                        <button class="btn btn-sm btn-info" id="testApiKeyBtn" onclick="testApiKey()">
                            <i class="fas fa-check-circle me-1"></i>Test API Key
                        </button>
                        <small id="apiKeyStatus" class="ms-2"></small>
                    </div>
                </div>

                <!-- Import from Excel Section -->
                <div class="settings-section mb-4" style="background: #e7f3ff; border-left: 4px solid #2196F3;">
                    <h5><i class="fas fa-file-upload me-2"></i>Import Questions from Excel</h5>
                    <p class="mb-2 text-muted">Already have questions in Excel? Import them directly to create Google Forms.</p>
                    <button class="btn btn-info" onclick="document.getElementById('excelImportFile').click()">
                        <i class="fas fa-file-upload me-2"></i>Import from Excel
                    </button>
                    <input type="file" id="excelImportFile" accept=".xlsx,.xls" style="display: none;" onchange="importFromExcel(event)">
                    <small class="d-block mt-2 text-muted">
                        <i class="fas fa-info-circle me-1"></i>Expected format: Question, Option A, Option B, Option C, Correct Answer, Knowledge Level
                    </small>
                </div>

                <!-- Settings Section -->
                <div class="settings-section">
                    <h5><i class="fas fa-cog me-2"></i>Generation Settings</h5>
                    <div class="row">
                        <div class="col-md-4 mb-3">
                            <label class="form-label">Level 1 Questions</label>
                            <input type="number" id="numQuestionsL1" class="form-control" value="5" min="0" max="20">
                            <small class="text-muted">Familiarisation level</small>
                        </div>
                        <div class="col-md-4 mb-3">
                            <label class="form-label">Level 2 Questions</label>
                            <input type="number" id="numQuestionsL2" class="form-control" value="5" min="0" max="20">
                            <small class="text-muted">General knowledge level</small>
                        </div>
                        <div class="col-md-4 mb-3">
                            <label class="form-label">Level 3 Questions</label>
                            <input type="number" id="numQuestionsL3" class="form-control" value="5" min="0" max="20">
                            <small class="text-muted">Detailed knowledge level</small>
                        </div>
                    </div>
                    <div class="row">
                        <div class="col-md-12 mb-3">
                            <label class="form-label">Page Range</label>
                            <div class="input-group" style="max-width: 300px;">
                                <input type="number" id="startPage" class="form-control" placeholder="Start" value="1" min="1" max="1000">
                                <span class="input-group-text">to</span>
                                <input type="number" id="endPage" class="form-control" placeholder="End" value="0" min="0" max="1000">
                            </div>
                            <small class="text-muted">Leave End as 0 for all pages from start</small>
                        </div>
                    </div>
                </div>

                <!-- PDF Upload Section -->
                <div class="upload-area" id="uploadArea">
                    <i class="fas fa-cloud-upload-alt fa-3x mb-3 text-primary"></i>
                    <h4>Drop your PDF file here</h4>
                    <p class="text-muted">or click to browse</p>
                    <input type="file" id="pdfFile" accept=".pdf" style="display: none;">
                    <button class="btn btn-primary mt-3" onclick="document.getElementById('pdfFile').click()">
                        <i class="fas fa-file-pdf me-2"></i>Select PDF File
                    </button>
                </div>

                <div id="fileInfo" class="mt-3" style="display: none;">
                    <div class="alert alert-info">
                        <i class="fas fa-file-pdf me-2"></i>
                        <span id="fileName"></span>
                        <button class="btn btn-sm btn-danger float-end" onclick="clearFile()">
                            <i class="fas fa-times"></i> Remove
                        </button>
                    </div>
                </div>

                <!-- PDF Text Preview -->
                <div id="pdfPreview" style="display: none;">
                    <h5 class="mt-4 mb-3"><i class="fas fa-eye me-2"></i>Extracted Text Preview</h5>
                    <div class="pdf-preview" id="extractedText"></div>
                </div>

                <!-- Generate Button -->
                <div class="text-center mt-4" id="generateSection" style="display: none;">
                    <button class="btn btn-success btn-lg" id="generateBtn">
                        <i class="fas fa-magic me-2"></i>Generate Questions
                    </button>
                </div>

                <!-- Loading Spinner -->
                <div class="loading-spinner" id="loadingSpinner">
                    <div class="spinner-border text-primary" role="status">
                        <span class="visually-hidden">Loading...</span>
                    </div>
                    <p class="mt-3">Processing PDF and generating questions...</p>
                </div>

                <!-- Questions Display -->
                <div id="questionsContainer" style="display: none;">
                    <h4 class="mt-4 mb-3">
                        <i class="fas fa-question-circle me-2"></i>Generated Questions
                    </h4>
                    <div class="mb-3 d-flex justify-content-between align-items-center">
                        <div>
                            <button class="btn btn-sm btn-outline-primary" onclick="selectAllQuestions()">
                                <i class="fas fa-check-square me-1"></i>Select All
                            </button>
                            <button class="btn btn-sm btn-outline-secondary ms-2" onclick="deselectAllQuestions()">
                                <i class="fas fa-square me-1"></i>Deselect All
                            </button>
                            <span class="ms-3 text-muted" id="selectedCount">0 selected</span>
                        </div>
                    </div>
                    <div id="questionsList"></div>
                    <!-- Google Form Settings -->
                    <div class="card mt-4 mb-4" style="background: #f8f9fa;">
                        <div class="card-header">
                            <h5><i class="fas fa-cog me-2"></i>Google Form Settings</h5>
                        </div>
                        <div class="card-body">
                            <div class="row">
                                <div class="col-md-4 mb-3">
                                    <label class="form-label"><strong>Chapter Number</strong></label>
                                    <input type="text" id="chapterNumber" class="form-control" placeholder="e.g., CH24" value="">
                                </div>
                                <div class="col-md-4 mb-3">
                                    <label class="form-label"><strong>Chapter Title</strong></label>
                                    <input type="text" id="chapterTitle" class="form-control" placeholder="e.g., Electrical System" value="">
                                </div>
                                <div class="col-md-4 mb-3">
                                    <label class="form-label"><strong>Date</strong></label>
                                    <input type="date" id="formDate" class="form-control" value="">
                                </div>
                            </div>
                            <small class="text-muted"><i class="fas fa-info-circle me-1"></i>These will be included in Section 1 of the Google Form</small>
                        </div>
                    </div>
                    
                    <div class="text-center mt-4">
                        <button class="btn btn-primary" onclick="exportQuestions()">
                            <i class="fas fa-file-excel me-2"></i>Export to Excel
                        </button>
                        <button class="btn btn-success ms-2" onclick="createGoogleForm()" id="createFormBtn">
                            <i class="fab fa-google me-2"></i>Create Google Form
                            <span class="badge bg-light text-dark ms-2" id="selectedForForm">0</span>
                        </button>
                        <button class="btn btn-secondary ms-2" onclick="clearAll()">
                            <i class="fas fa-redo me-2"></i>Start Over
                        </button>
                    </div>
                    <div id="googleAuthStatus" class="mt-3 text-center" style="display: none;"></div>
                    <div class="alert alert-info mt-3" style="display: none;" id="googleFormsInfo">
                        <small>
                            <strong>Note:</strong> To use Google Forms creation, you need to enable the Google Forms API in your Google Cloud Console.
                            <br>Go to <a href="https://console.cloud.google.com/apis/library/forms.googleapis.com" target="_blank">Google Cloud Console</a> and enable "Google Forms API" for your project.
                        </small>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // Set up PDF.js worker
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        let pdfText = '';
        let questions = []; // Array of {level: 1|2|3, questions: [...]}
        let availableModels = []; // Store available models from API
        let googleAccessToken = null; // Store Google OAuth token
        let authenticatedEmail = null; // Store authenticated user's email
        const GOOGLE_CLIENT_ID = '813615362050-qopq5cb1ebtbhhicokg8ae0cko8krn77.apps.googleusercontent.com'; // From Firebase config
        const GOOGLE_FORMS_API = 'https://forms.googleapis.com/v1/forms';

        // Load API key from localStorage
        const savedApiKey = localStorage.getItem('gemini_api_key');
        if (savedApiKey) {
            document.getElementById('apiKey').value = savedApiKey;
        }

        // Toggle API key visibility
        document.getElementById('toggleApiKey').addEventListener('click', function() {
            const apiKeyInput = document.getElementById('apiKey');
            const icon = this.querySelector('i');
            if (apiKeyInput.type === 'password') {
                apiKeyInput.type = 'text';
                icon.classList.remove('fa-eye');
                icon.classList.add('fa-eye-slash');
            } else {
                apiKeyInput.type = 'password';
                icon.classList.remove('fa-eye-slash');
                icon.classList.add('fa-eye');
            }
        });

        // Save API key when changed and clear cached models
        document.getElementById('apiKey').addEventListener('change', function() {
            localStorage.setItem('gemini_api_key', this.value);
            availableModels = []; // Clear cached models when key changes
        });


        // File upload handling
        const uploadArea = document.getElementById('uploadArea');
        const pdfFileInput = document.getElementById('pdfFile');

        uploadArea.addEventListener('click', () => pdfFileInput.click());

        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0 && files[0].type === 'application/pdf') {
                handleFile(files[0]);
            }
        });

        pdfFileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFile(e.target.files[0]);
            }
        });

        async function handleFile(file) {
            if (!file) {
                alert('No file selected');
                return;
            }

            if (!file.type.includes('pdf')) {
                alert('Please select a PDF file');
                return;
            }

            if (typeof pdfjsLib === 'undefined') {
                alert('PDF.js library not loaded. Please refresh the page.');
                console.error('pdfjsLib is not defined');
                return;
            }

            document.getElementById('fileName').textContent = file.name;
            document.getElementById('fileInfo').style.display = 'block';
            document.getElementById('pdfPreview').style.display = 'none';
            document.getElementById('generateSection').style.display = 'none';
            document.getElementById('questionsContainer').style.display = 'none';

            try {
                const arrayBuffer = await file.arrayBuffer();
                const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                
                let fullText = '';
                let startPage = parseInt(document.getElementById('startPage').value) || 1;
                let endPage = parseInt(document.getElementById('endPage').value) || 0;
                
                // Validate and set page range
                if (startPage < 1) startPage = 1;
                if (startPage > pdf.numPages) startPage = pdf.numPages;
                if (endPage === 0 || endPage > pdf.numPages) endPage = pdf.numPages;
                if (endPage < startPage) endPage = startPage;
                
                const pagesToProcess = endPage - startPage + 1;
                
                // Show progress for large PDFs
                if (pdf.numPages > 10) {
                    document.getElementById('fileInfo').innerHTML = `
                        <div class="alert alert-info">
                            <i class="fas fa-file-pdf me-2"></i>
                            <span id="fileName">${file.name}</span>
                            <span class="ms-2">Processing pages ${startPage}-${endPage} (${pagesToProcess} pages) of ${pdf.numPages} total...</span>
                            <button class="btn btn-sm btn-danger float-end" onclick="clearFile()">
                                <i class="fas fa-times"></i> Remove
                            </button>
                        </div>
                    `;
                }
                
                for (let i = startPage; i <= endPage; i++) {
                    const page = await pdf.getPage(i);
                    const textContent = await page.getTextContent();
                    const pageText = textContent.items.map(item => item.str).join(' ');
                    fullText += pageText + '\n\n';
                }
                
                if (startPage > 1 || endPage < pdf.numPages) {
                    fullText += `\n[Note: Processed pages ${startPage}-${endPage} out of ${pdf.numPages} total pages]`;
                }

                pdfText = fullText;
                
                // Show preview (truncated if too long)
                const previewText = fullText.length > 2000 ? fullText.substring(0, 2000) + '...' : fullText;
                document.getElementById('extractedText').textContent = previewText;
                document.getElementById('pdfPreview').style.display = 'block';
                document.getElementById('generateSection').style.display = 'block';
            } catch (error) {
                alert('Error reading PDF: ' + error.message);
                console.error(error);
            }
        }

        function clearFile() {
            pdfFileInput.value = '';
            pdfText = '';
            document.getElementById('fileInfo').style.display = 'none';
            document.getElementById('pdfPreview').style.display = 'none';
            document.getElementById('generateSection').style.display = 'none';
            document.getElementById('questionsContainer').style.display = 'none';
        }

        function clearAll() {
            clearFile();
            questions = [];
            document.getElementById('questionsList').innerHTML = '';
        }

        document.getElementById('generateBtn').addEventListener('click', generateQuestions);

        // Function to test API key and list available models
        async function testApiKey() {
            const apiKey = document.getElementById('apiKey').value.trim();
            if (!apiKey) {
                alert('Please enter your API key first');
                return;
            }

            const statusEl = document.getElementById('apiKeyStatus');
            statusEl.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Testing...';
            statusEl.className = 'ms-2 text-info';

            try {
                // Try to list available models
                const response = await fetch(`https://generativelanguage.googleapis.com/v1/models?key=${apiKey}`);
                
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.error?.message || `HTTP ${response.status}`);
                }

                const data = await response.json();
                const models = data.models || [];
                
                // Get models that support generateContent and are Gemini models
                const geminiModels = models
                    .filter(m => {
                        const name = m.name.toLowerCase();
                        return name.includes('gemini') && 
                               m.supportedGenerationMethods && 
                               m.supportedGenerationMethods.includes('generateContent');
                    })
                    .map(m => {
                        // Extract just the model name (remove 'models/' prefix)
                        return m.name.replace('models/', '');
                    });
                
                // Store available models globally
                availableModels = geminiModels;
                
                if (geminiModels.length > 0) {
                    statusEl.innerHTML = `<i class="fas fa-check-circle text-success"></i> API Key works! Available models: ${geminiModels.length}`;
                    statusEl.className = 'ms-2 text-success';
                    console.log('Available Gemini models with generateContent:', geminiModels);
                } else {
                    statusEl.innerHTML = '<i class="fas fa-exclamation-triangle text-warning"></i> API Key works but no Gemini models found';
                    statusEl.className = 'ms-2 text-warning';
                    availableModels = [];
                }
            } catch (error) {
                statusEl.innerHTML = `<i class="fas fa-times-circle text-danger"></i> Error: ${error.message}`;
                statusEl.className = 'ms-2 text-danger';
                console.error('API Key test failed:', error);
                availableModels = [];
            }
        }

        // Randomly shuffle options for each question to ensure balanced distribution of correct answers
        function shuffleQuestionOptions(questions) {
            // Use Fisher-Yates shuffle for truly random distribution
            function shuffleArray(array) {
                const shuffled = [...array];
                for (let i = shuffled.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                }
                return shuffled;
            }
            
            return questions.map(q => {
                // Get current options as array with their keys
                const options = [
                    { key: 'A', value: q.options.A || '' },
                    { key: 'B', value: q.options.B || '' },
                    { key: 'C', value: q.options.C || '' }
                ];
                
                // Find the current correct answer value
                const currentCorrectKey = q.correct || 'A';
                const correctValue = options.find(opt => opt.key === currentCorrectKey)?.value || options[0].value;
                
                // Randomly shuffle the options array
                const shuffledOptions = shuffleArray(options);
                
                // Rebuild options object with shuffled order
                const newOptions = {
                    A: shuffledOptions[0].value,
                    B: shuffledOptions[1].value,
                    C: shuffledOptions[2].value
                };
                
                // Find which position (A, B, or C) now contains the correct answer
                let newCorrectKey = 'A';
                if (shuffledOptions[1].value === correctValue) {
                    newCorrectKey = 'B';
                } else if (shuffledOptions[2].value === correctValue) {
                    newCorrectKey = 'C';
                }
                
                return {
                    question: q.question,
                    options: newOptions,
                    correct: newCorrectKey
                };
            });
        }

        async function generateQuestions() {
            const apiKey = document.getElementById('apiKey')?.value?.trim();
            if (!apiKey) {
                alert('Please enter your Google Gemini API key');
                return;
            }

            if (!pdfText) {
                alert('Please upload a PDF file first');
                return;
            }

            // Save API key
            localStorage.setItem('gemini_api_key', apiKey);

            // Get form values with null checks
            const numQuestionsL1 = parseInt(document.getElementById('numQuestionsL1')?.value || 0);
            const numQuestionsL2 = parseInt(document.getElementById('numQuestionsL2')?.value || 0);
            const numQuestionsL3 = parseInt(document.getElementById('numQuestionsL3')?.value || 0);
            
            // Check if at least one level has questions
            if (numQuestionsL1 === 0 && numQuestionsL2 === 0 && numQuestionsL3 === 0) {
                alert('Please specify at least one question count for any level (Level 1, 2, or 3)');
                return;
            }
            
            // Define level objectives
            const levelObjectives = {
                1: {
                    name: "Level 1 - Familiarisation",
                    description: "Familiarisation with the principal elements of the subject",
                    objectives: [
                        "The applicant should be familiar with the basic elements of the subject",
                        "The applicant should be able to give a simple description of the whole subject using common words and examples",
                        "The applicant should be able to use typical terms"
                    ]
                },
                2: {
                    name: "Level 2 - General Knowledge",
                    description: "General knowledge of the theoretical and practical aspects of the subject",
                    objectives: [
                        "The applicant should be able to understand the theoretical fundamentals of the subject",
                        "The applicant should be able to give a general description of the subject using typical examples",
                        "The applicant should be able to use mathematical formulae in conjunction with physical laws",
                        "The applicant should be able to read and understand sketches, drawings and schematics",
                        "The applicant should be able to apply knowledge in a practical manner using detailed procedures"
                    ]
                },
                3: {
                    name: "Level 3 - Detailed Knowledge",
                    description: "Detailed knowledge of the theoretical and practical aspects of the subject",
                    objectives: [
                        "The applicant should know the theory of the subject and its interrelationships with other subjects",
                        "The applicant should be able to give a detailed description using theoretical fundamentals and specific examples",
                        "The applicant should understand and be able to use mathematical formulae related to the subject",
                        "The applicant should be able to read, understand and prepare sketches, simple drawings and schematics",
                        "The applicant should be able to apply knowledge in a practical manner using manufacturer's instructions",
                        "The applicant should be able to interpret results from various sources and measurements and apply corrective action"
                    ]
                }
            };
            
            // Calculate total questions for text truncation
            const totalQuestions = numQuestionsL1 + numQuestionsL2 + numQuestionsL3;

            document.getElementById('loadingSpinner').classList.add('active');
            document.getElementById('generateSection').style.display = 'none';
            document.getElementById('questionsContainer').style.display = 'none';

            try {
                // Truncate text to prevent MAX_TOKENS error
                // Reduce text size based on total number of questions
                const baseLength = 20000;
                const lengthPerQuestion = 3000;
                const maxLength = baseLength + (totalQuestions * lengthPerQuestion);
                const adjustedLength = Math.min(maxLength, 50000); // Cap at 50K to ensure output space
                
                const textToUse = pdfText.length > adjustedLength 
                    ? pdfText.substring(0, adjustedLength) + '\n\n[Text truncated to ensure sufficient output tokens]' 
                    : pdfText;
                
                console.log(`Using ${textToUse.length} characters from PDF (${pdfText.length} total available)`);
                
                // Clear previous questions
                questions = [];
                
                // Generate questions for each level
                const levelsToGenerate = [
                    { level: 1, count: numQuestionsL1 },
                    { level: 2, count: numQuestionsL2 },
                    { level: 3, count: numQuestionsL3 }
                ].filter(l => l.count > 0);
                
                // Get available models once (outside the loop)
                let modelsToTry = [];
                
                if (availableModels.length > 0) {
                    modelsToTry = availableModels;
                    console.log('Using cached available models:', modelsToTry);
                } else {
                    try {
                        const listResponse = await fetch(`https://generativelanguage.googleapis.com/v1/models?key=${apiKey}`);
                        if (listResponse.ok) {
                            const listData = await listResponse.json();
                            modelsToTry = (listData.models || [])
                                .filter(m => {
                                    const name = m.name.toLowerCase();
                                    return name.includes('gemini') && 
                                           m.supportedGenerationMethods && 
                                           m.supportedGenerationMethods.includes('generateContent');
                                })
                                .map(m => m.name.replace('models/', ''));
                            console.log('Fetched available models:', modelsToTry);
                        }
                    } catch (e) {
                        console.log('Could not list models:', e);
                    }
                    
                    if (modelsToTry.length === 0) {
                        modelsToTry = ['gemini-1.5-flash', 'gemini-1.5-pro', 'gemini-pro'];
                        console.log('Using default models:', modelsToTry);
                    }
                }

                // Generate questions for each level
                for (const { level, count } of levelsToGenerate) {
                    const levelInfo = levelObjectives[level];
                    console.log(`Generating ${count} questions for ${levelInfo.name}...`);
                    
                    // For Level 3, add specific instructions about complexity
                    const complexityNote = level === 3 
                        ? '\nIMPORTANT FOR LEVEL 3: Generate detailed, complex questions that require deep understanding. Keep questions and options concise but comprehensive. Ensure the JSON response is complete and valid.'
                        : '';
                    
                    const levelPrompt = `Based on the following text from a PDF document, generate ${count} multiple choice questions at ${levelInfo.name}.${complexityNote}

KNOWLEDGE LEVEL REQUIREMENTS:
${levelInfo.description}

The questions must align with these objectives:
${levelInfo.objectives.map((obj, idx) => `${idx + 1}. ${obj}`).join('\n')}

Each question should have:
- A clear question stem appropriate for ${levelInfo.name}
- 3 answer options (A, B, C)
- One correct answer clearly marked
- IMPORTANT: Distribute correct answers evenly and randomly across A, B, and C options. 
  For ${count} questions, ensure roughly equal distribution (not all A, not all B, not all C, and not in a pattern like first=A, middle=B, last=C).
- Questions should test knowledge at the specified level depth
- Questions should be varied in style (factual, comprehension, application, analysis) as appropriate for the level

Format the response as a JSON array with this structure:
[
  {
    "question": "Question text here?",
    "options": {
      "A": "Option A text",
      "B": "Option B text",
      "C": "Option C text"
    },
    "correct": "A"
  }
]

Text content:
${textToUse}

Return ONLY the JSON array, no additional text or markdown formatting.`;

                    let data = null;
                    let lastError = null;

                    // Try to generate questions for this level
                    for (const model of modelsToTry) {
                        try {
                            const endpoints = [
                                `https://generativelanguage.googleapis.com/v1/models/${model}:generateContent?key=${apiKey}`,
                                `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`
                            ];

                            for (const url of endpoints) {
                                try {
                                    const response = await fetch(url, {
                                        method: 'POST',
                                        headers: { 'Content-Type': 'application/json' },
                                        body: JSON.stringify({
                                            contents: [{ parts: [{ text: levelPrompt }] }],
                                            generationConfig: {
                                                temperature: 0.7,
                                                // Level 3 questions are more complex and need more tokens
                                                maxOutputTokens: level === 3 ? Math.max(8192, count * 1500) : Math.max(4096, count * 1000)
                                            }
                                        })
                                    });

                                    if (response.ok) {
                                        data = await response.json();
                                        if (data.error) {
                                            lastError = data.error.message || 'API returned an error';
                                            continue;
                                        }
                                        
                                        // Check for truncation issues (especially for Level 3)
                                        if (data.candidates?.[0]?.finishReason === 'MAX_TOKENS') {
                                            console.warn(`Response truncated for Level ${level}. May need more tokens.`);
                                            if (level === 3) {
                                                console.warn('Level 3 response was truncated. Try generating fewer questions at once or the response may be incomplete.');
                                            }
                                            // Still try to use what we got, but warn user
                                        }
                                        
                                        console.log(`Successfully used model: ${model} for Level ${level}`);
                                        break;
                                    } else {
                                        const errorData = await response.json().catch(() => ({}));
                                        lastError = errorData.error?.message || `HTTP ${response.status}`;
                                    }
                                } catch (err) {
                                    lastError = err.message;
                                }
                            }

                            if (data) break;
                        } catch (err) {
                            lastError = err.message;
                            continue;
                        }
                    }

                    if (!data) {
                        console.error(`Failed to generate Level ${level} questions:`, lastError);
                        continue; // Skip this level and continue with others
                    }

                    // Parse response
                    let content = '';
                    if (data.candidates?.[0]?.content?.parts?.[0]?.text) {
                        content = data.candidates[0].content.parts[0].text;
                    } else if (data.candidates?.[0]?.text) {
                        content = data.candidates[0].text;
                    } else {
                        console.error(`No content in response for Level ${level}`);
                        continue;
                    }

                    content = content.trim();
                    if (content.startsWith('```')) {
                        content = content.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
                    }

                    try {
                        // Try to fix common JSON issues before parsing
                        let cleanedContent = content;
                        
                        // Remove any text before the first [
                        const firstBracket = cleanedContent.indexOf('[');
                        if (firstBracket > 0) {
                            cleanedContent = cleanedContent.substring(firstBracket);
                        }
                        
                        // Remove any text after the last ]
                        const lastBracket = cleanedContent.lastIndexOf(']');
                        if (lastBracket > 0 && lastBracket < cleanedContent.length - 1) {
                            cleanedContent = cleanedContent.substring(0, lastBracket + 1);
                        }
                        
                        // Fix common JSON issues
                        cleanedContent = cleanedContent
                            .replace(/([{,]\s*)(\w+)(\s*:)/g, '$1"$2"$3') // Fix unquoted keys
                            .replace(/,\s*}/g, '}') // Remove trailing commas
                            .replace(/,\s*]/g, ']'); // Remove trailing commas in arrays
                        
                        let levelQuestions = JSON.parse(cleanedContent);
                        
                        // Validate it's an array
                        if (!Array.isArray(levelQuestions)) {
                            throw new Error('Response is not an array');
                        }
                        
                        // Randomly shuffle options for each question to ensure balanced distribution of correct answers
                        levelQuestions = shuffleQuestionOptions(levelQuestions);
                        
                        questions.push({ level, levelName: levelInfo.name, questions: levelQuestions });
                        console.log(`Successfully generated ${levelQuestions.length} questions for ${levelInfo.name}`);
                    } catch (parseError) {
                        console.error(`Failed to parse questions for Level ${level}:`, parseError);
                        console.error('Content that failed to parse:', content.substring(0, 1000));
                        
                        // For Level 3, show more detailed error info
                        if (level === 3) {
                            console.error('Level 3 parsing error details:', {
                                contentLength: content.length,
                                firstChars: content.substring(0, 200),
                                lastChars: content.substring(Math.max(0, content.length - 200)),
                                errorMessage: parseError.message
                            });
                        }
                        
                        // Try to extract questions manually if JSON parsing fails
                        try {
                            let manualQuestions = extractQuestionsFromText(content);
                            if (manualQuestions.length > 0) {
                                // Randomly shuffle options for manually extracted questions too
                                manualQuestions = shuffleQuestionOptions(manualQuestions);
                                questions.push({ level, levelName: levelInfo.name, questions: manualQuestions });
                                console.log(`Manually extracted ${manualQuestions.length} questions for ${levelInfo.name}`);
                            } else {
                                const errorMsg = level === 3 
                                    ? `Could not extract any questions for Level 3. The response may be incomplete or truncated. Try generating fewer Level 3 questions at once, or check the console for details.`
                                    : `Could not extract any questions for Level ${level}. The response may be incomplete.`;
                                console.warn(errorMsg);
                                // Still continue - other levels may have worked
                            }
                        } catch (extractError) {
                            console.error(`Failed to extract questions manually:`, extractError);
                            if (level === 3) {
                                console.error('Level 3 manual extraction also failed. The API response may be malformed or incomplete. Try reducing the number of Level 3 questions.');
                            }
                            // Continue with other levels
                        }
                    }
                }

                if (questions.length === 0) {
                    throw new Error('Failed to generate questions for any level. Please check your API key and try again.');
                }
                
                displayQuestions();
            } catch (error) {
                alert('Error generating questions: ' + error.message + '\n\nMake sure your API key is correct and you have not exceeded the free tier limits.');
                console.error(error);
            } finally {
                document.getElementById('loadingSpinner').classList.remove('active');
                document.getElementById('generateSection').style.display = 'block';
            }
        }

        function displayQuestions() {
            const container = document.getElementById('questionsList');
            container.innerHTML = '';

            // Display questions grouped by level
            questions.forEach((levelGroup) => {
                // Add level header
                const levelHeader = document.createElement('div');
                levelHeader.className = 'mb-4';
                levelHeader.innerHTML = `
                    <h5 class="text-primary mb-3">
                        <i class="fas fa-layer-group me-2"></i>${levelGroup.levelName}
                        <span class="badge bg-secondary ms-2">${levelGroup.questions.length} questions</span>
                    </h5>
                `;
                container.appendChild(levelHeader);

                // Display questions for this level
                levelGroup.questions.forEach((q, index) => {
                    const questionCard = document.createElement('div');
                    questionCard.className = 'question-card';
                    questionCard.dataset.level = levelGroup.level;
                    questionCard.dataset.questionIndex = index;
                    
                    // Create unique ID for checkbox
                    const checkboxId = `q-${levelGroup.level}-${index}`;
                    
                    const questionHtml = `
                        <div class="d-flex justify-content-between align-items-start mb-2">
                            <div class="d-flex align-items-center">
                                <input type="checkbox" class="question-checkbox" id="${checkboxId}" checked onchange="updateSelectionCount()">
                                <div class="question-number ms-2">Question ${index + 1}</div>
                            </div>
                            <button class="btn btn-sm btn-outline-primary edit-question-btn" onclick="editQuestion(${levelGroup.level}, ${index})">
                                <i class="fas fa-edit me-1"></i>Edit
                            </button>
                        </div>
                        <div class="question-content" id="question-content-${levelGroup.level}-${index}">
                            <div class="question-text">${q.question}</div>
                            <div class="options">
                                ${Object.entries(q.options).map(([key, value]) => 
                                    `<div class="option" data-option="${key}">
                                        <strong>${key}.</strong> ${value}
                                    </div>`
                                ).join('')}
                            </div>
                            <div class="mt-3">
                                <small class="text-muted">
                                    <strong>Correct Answer:</strong> <span class="badge bg-success">${q.correct}</span>
                                </small>
                            </div>
                        </div>
                    `;
                    
                    questionCard.innerHTML = questionHtml;
                    
                    // Add visual feedback for selection
                    const checkbox = questionCard.querySelector('.question-checkbox');
                    checkbox.addEventListener('change', function() {
                        if (this.checked) {
                            questionCard.classList.add('selected');
                        } else {
                            questionCard.classList.remove('selected');
                        }
                        updateSelectionCount();
                    });
                    
                    // Initially selected
                    questionCard.classList.add('selected');
                    
                    // Add click handlers to show correct/incorrect
                    const options = questionCard.querySelectorAll('.option');
                    options.forEach(option => {
                        option.addEventListener('click', function() {
                            const selectedOption = this.dataset.option;
                            options.forEach(opt => {
                                opt.classList.remove('correct', 'incorrect');
                                if (opt.dataset.option === q.correct) {
                                    opt.classList.add('correct');
                                } else if (opt.dataset.option === selectedOption && selectedOption !== q.correct) {
                                    opt.classList.add('incorrect');
                                }
                            });
                        });
                    });
                    
                    container.appendChild(questionCard);
                });
            });

            document.getElementById('questionsContainer').style.display = 'block';
            updateSelectionCount(); // Update count after displaying questions
        }

        function exportQuestions() {
            try {
                // Create Excel workbook
                const wb = XLSX.utils.book_new();
                
                // Prepare data for Excel - horizontal format, grouped by level
                const excelData = [
                    // Header row
                    ['Question', 'Option A', 'Option B', 'Option C', 'Correct Answer', 'Knowledge Level']
                ];
                
                // Add questions grouped by level
                questions.forEach((levelGroup) => {
                    // Add level separator row
                    excelData.push([`--- ${levelGroup.levelName} ---`, '', '', '', '', '']);
                    
                    // Add each question as a row
                    levelGroup.questions.forEach((q) => {
                        const row = [
                            q.question,
                            q.options.A || '',
                            q.options.B || '',
                            q.options.C || '',
                            q.correct,
                            levelGroup.levelName
                        ];
                        excelData.push(row);
                    });
                    
                    // Add empty row between levels
                    excelData.push(['', '', '', '', '', '']);
                });
                
                // Create worksheet
                const ws = XLSX.utils.aoa_to_sheet(excelData);
                
                // Set column widths for better readability
                ws['!cols'] = [
                    { wch: 60 },  // Question column - wider
                    { wch: 40 },  // Option A
                    { wch: 40 },  // Option B
                    { wch: 40 },  // Option C
                    { wch: 15 },  // Correct Answer
                    { wch: 30 }   // Knowledge Level
                ];
                
                // Add worksheet to workbook
                XLSX.utils.book_append_sheet(wb, ws, 'Questions');
                
                // Generate Excel file and download
                const fileName = `generated_questions_${new Date().toISOString().split('T')[0]}.xlsx`;
                XLSX.writeFile(wb, fileName);
                
                // Show success message
                alert(`Questions exported successfully to ${fileName}`);
            } catch (error) {
                console.error('Export error:', error);
                alert('Error exporting to Excel. Trying text format instead...');
                
                // Fallback to text export
                let exportText = 'PDF Question Generator - Generated Questions\n';
                exportText += '='.repeat(50) + '\n\n';

                questions.forEach((levelGroup) => {
                    exportText += `${levelGroup.levelName}\n`;
                    exportText += '='.repeat(50) + '\n\n';
                    
                    levelGroup.questions.forEach((q, index) => {
                        exportText += `Question ${index + 1}: ${q.question}\n\n`;
                        Object.entries(q.options).forEach(([key, value]) => {
                            exportText += `  ${key}. ${value}\n`;
                        });
                        exportText += `\nCorrect Answer: ${q.correct}\n\n`;
                        exportText += '-'.repeat(50) + '\n\n';
                    });
                });

                const blob = new Blob([exportText], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'generated_questions.txt';
                a.click();
                URL.revokeObjectURL(url);
            }
        }

        // Import questions from Excel file
        async function importFromExcel(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (!file.name.match(/\.(xlsx|xls)$/i)) {
                alert('Please select an Excel file (.xlsx or .xls)');
                return;
            }

            try {
                const arrayBuffer = await file.arrayBuffer();
                const workbook = XLSX.read(arrayBuffer, { type: 'array' });
                const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                const data = XLSX.utils.sheet_to_json(firstSheet, { header: 1, defval: '' });

                // Parse Excel data - expect format: Question, Option A, Option B, Option C, Correct Answer, Knowledge Level
                const importedQuestions = [];
                let currentLevel = null;
                let currentLevelName = null;
                let levelQuestions = [];

                for (let i = 0; i < data.length; i++) {
                    const row = data[i];
                    
                    // Skip empty rows
                    if (!row || row.length === 0 || !row[0]) continue;

                    const firstCell = String(row[0]).trim();

                    // Check if it's a level header (starts with "---" or contains "Level")
                    if (firstCell.includes('Level') || firstCell.startsWith('---')) {
                        // Save previous level if exists
                        if (currentLevel !== null && levelQuestions.length > 0) {
                            importedQuestions.push({
                                level: currentLevel,
                                levelName: currentLevelName,
                                questions: levelQuestions
                            });
                            levelQuestions = [];
                        }

                        // Extract level from header
                        if (firstCell.includes('Level 1') || firstCell.includes('Familiarisation')) {
                            currentLevel = 1;
                            currentLevelName = 'Level 1 - Familiarisation';
                        } else if (firstCell.includes('Level 2') || firstCell.includes('General')) {
                            currentLevel = 2;
                            currentLevelName = 'Level 2 - General Knowledge';
                        } else if (firstCell.includes('Level 3') || firstCell.includes('Detailed')) {
                            currentLevel = 3;
                            currentLevelName = 'Level 3 - Detailed Knowledge';
                        }
                        continue;
                    }

                    // Check if it's a header row
                    if (firstCell.toLowerCase().includes('question') && 
                        (row[1] && String(row[1]).toLowerCase().includes('option'))) {
                        continue; // Skip header row
                    }

                    // Parse question row
                    if (row[0] && row[1] && row[2] && row[3]) {
                        const question = {
                            question: String(row[0]).trim(),
                            options: {
                                A: String(row[1] || '').trim(),
                                B: String(row[2] || '').trim(),
                                C: String(row[3] || '').trim()
                            },
                            correct: String(row[4] || 'A').trim().toUpperCase()
                        };

                        // Determine level from row or use current level
                        let questionLevel = currentLevel;
                        if (row[5]) {
                            const levelText = String(row[5]).trim();
                            if (levelText.includes('Level 1') || levelText.includes('Familiarisation')) {
                                questionLevel = 1;
                            } else if (levelText.includes('Level 2') || levelText.includes('General')) {
                                questionLevel = 2;
                            } else if (levelText.includes('Level 3') || levelText.includes('Detailed')) {
                                questionLevel = 3;
                            }
                        }

                        if (!questionLevel) questionLevel = 2; // Default to Level 2

                        // Add to appropriate level
                        let levelGroup = importedQuestions.find(q => q.level === questionLevel);
                        if (!levelGroup) {
                            const levelNames = {
                                1: 'Level 1 - Familiarisation',
                                2: 'Level 2 - General Knowledge',
                                3: 'Level 3 - Detailed Knowledge'
                            };
                            levelGroup = {
                                level: questionLevel,
                                levelName: levelNames[questionLevel],
                                questions: []
                            };
                            importedQuestions.push(levelGroup);
                        }
                        levelGroup.questions.push(question);
                    }
                }

                // Add remaining questions from current level
                if (currentLevel !== null && levelQuestions.length > 0) {
                    let levelGroup = importedQuestions.find(q => q.level === currentLevel);
                    if (!levelGroup) {
                        levelGroup = {
                            level: currentLevel,
                            levelName: currentLevelName,
                            questions: []
                        };
                        importedQuestions.push(levelGroup);
                    }
                    levelGroup.questions.push(...levelQuestions);
                }

                if (importedQuestions.length === 0) {
                    alert('No questions found in the Excel file. Please check the format.');
                    return;
                }

                questions = importedQuestions;
                displayQuestions();
                updateSelectionCount();
                
                const totalQuestions = importedQuestions.reduce((sum, lg) => sum + lg.questions.length, 0);
                alert(`Successfully imported ${totalQuestions} questions from ${importedQuestions.length} level(s)`);
                
                // Clear file input
                event.target.value = '';
            } catch (error) {
                console.error('Import error:', error);
                alert('Error importing Excel file: ' + error.message);
            }
        }

        // Initialize Google Sign-In (not used for OAuth, but kept for compatibility)
        function initializeGoogleSignIn() {
            // OAuth uses tokenClient directly, no need to initialize ID
        }

        // Handle Google Sign-In callback
        function handleGoogleSignIn(response) {
            if (response.credential) {
                // Exchange credential for access token
                fetch('https://oauth2.googleapis.com/token', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                    body: new URLSearchParams({
                        code: response.credential,
                        client_id: GOOGLE_CLIENT_ID,
                        grant_type: 'authorization_code',
                        redirect_uri: window.location.origin + window.location.pathname
                    })
                }).then(r => r.json())
                .then(data => {
                    googleAccessToken = data.access_token;
                    document.getElementById('googleAuthStatus').innerHTML = 
                        '<div class="alert alert-success"><i class="fas fa-check-circle me-2"></i>Signed in to Google. You can now create forms!</div>';
                    document.getElementById('googleAuthStatus').style.display = 'block';
                    createGoogleForm();
                })
                .catch(err => {
                    console.error('Token exchange error:', err);
                    // Try direct approach with Forms API
                    authenticateAndCreateForm();
                });
            }
        }

        // Alternative authentication using Google Identity Services
        async function authenticateAndCreateForm() {
            if (questions.length === 0) {
                alert('Please generate questions first');
                return;
            }

            const statusEl = document.getElementById('googleAuthStatus');
            statusEl.style.display = 'block';
            statusEl.innerHTML = '<div class="alert alert-info"><i class="fas fa-spinner fa-spin me-2"></i>Authenticating with Google...</div>';

            try {
                // Use Google Identity Services for authentication
                const tokenClient = google.accounts.oauth2.initTokenClient({
                    client_id: GOOGLE_CLIENT_ID,
                    scope: 'https://www.googleapis.com/auth/forms.body https://www.googleapis.com/auth/drive.file',
                    callback: async (tokenResponse) => {
                        if (tokenResponse.error) {
                            console.error('OAuth error:', tokenResponse.error);
                            statusEl.innerHTML = '<div class="alert alert-danger"><i class="fas fa-times-circle me-2"></i>Authentication failed: ' + tokenResponse.error + '. Please check your Google Cloud Console OAuth settings.</div>';
                            return;
                        }
                        googleAccessToken = tokenResponse.access_token;
                        
                        // Get user info to show which account is authenticated
                        try {
                            const userInfoResponse = await fetch('https://www.googleapis.com/oauth2/v2/userinfo', {
                                headers: {
                                    'Authorization': `Bearer ${googleAccessToken}`
                                }
                            });
                            if (userInfoResponse.ok) {
                                const userInfo = await userInfoResponse.json();
                                authenticatedEmail = userInfo.email;
                                console.log('Authenticated as:', authenticatedEmail);
                            }
                        } catch (e) {
                            console.log('Could not fetch user info:', e);
                        }
                        
                        createFormWithAPI();
                    }
                });

                // Request access token - OAuth2 uses postMessage by default, no redirect_uri needed
                // Use 'select_account' to let user choose the correct account
                tokenClient.requestAccessToken({ prompt: 'select_account consent' });
            } catch (error) {
                console.error('Auth error:', error);
                statusEl.innerHTML = '<div class="alert alert-danger"><i class="fas fa-times-circle me-2"></i>Authentication failed. Please try again.</div>';
            }
        }

        // Create Google Form using the API
        async function createFormWithAPI() {
            const statusEl = document.getElementById('googleAuthStatus');
            
            if (!googleAccessToken) {
                await authenticateAndCreateForm();
                return;
            }

            statusEl.innerHTML = '<div class="alert alert-info"><i class="fas fa-spinner fa-spin me-2"></i>Creating Google Form...</div>';

            try {
                // Create form - ONLY title can be set during creation
                const formData = {
                    info: {
                        title: `PDF Generated Quiz - ${new Date().toLocaleDateString()}`
                    }
                };

                // Create the form
                const createResponse = await fetch(GOOGLE_FORMS_API, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${googleAccessToken}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(formData)
                });

                if (!createResponse.ok) {
                    const error = await createResponse.json();
                    const errorMessage = error.error?.message || 'Failed to create form';
                    
                    // Check if it's an API not enabled error
                    if (errorMessage.includes('has not been used') || errorMessage.includes('is disabled') || errorMessage.includes('Enable it by visiting')) {
                        // Extract the enable URL if present
                        const urlMatch = errorMessage.match(/https:\/\/[^\s]+/);
                        const enableUrl = urlMatch ? urlMatch[0] : `https://console.cloud.google.com/apis/api/forms.googleapis.com/overview?project=813615362050`;
                        
                        throw new Error('API_NOT_ENABLED:' + enableUrl);
                    }
                    
                    throw new Error(errorMessage);
                }

                const form = await createResponse.json();
                const formId = form.formId;

                // Get selected questions only
                const selectedQuestions = getSelectedQuestions();
                
                if (selectedQuestions.length === 0) {
                    statusEl.innerHTML = '<div class="alert alert-warning"><i class="fas fa-exclamation-triangle me-2"></i>Please select at least one question to include in the form.</div>';
                    return;
                }

                // Prepare batch update requests
                const requests = [];
                
                // First, set quiz settings and description via batchUpdate
                requests.push({
                    updateSettings: {
                        settings: {
                            quizSettings: {
                                isQuiz: true
                            }
                        },
                        updateMask: 'quizSettings.isQuiz'
                    }
                });
                
                // Get form metadata
                const chapterNumber = document.getElementById('chapterNumber')?.value?.trim() || '';
                const chapterTitle = document.getElementById('chapterTitle')?.value?.trim() || '';
                const formDate = document.getElementById('formDate')?.value || new Date().toISOString().split('T')[0];
                
                // Format date for display
                const dateObj = new Date(formDate);
                const formattedDate = dateObj.toLocaleDateString('en-GB', { day: '2-digit', month: '2-digit', year: 'numeric' });
                
                // Create form title
                let formTitle = '';
                if (chapterNumber && chapterTitle) {
                    formTitle = `${chapterNumber} ${chapterTitle} - ${formattedDate}`;
                } else if (chapterNumber) {
                    formTitle = `${chapterNumber} - ${formattedDate}`;
                } else if (chapterTitle) {
                    formTitle = `${chapterTitle} - ${formattedDate}`;
                } else {
                    formTitle = `Quiz - ${formattedDate}`;
                }
                
                requests.push({
                    updateFormInfo: {
                        info: {
                            title: formTitle,
                            description: ''
                        },
                        updateMask: 'title,description'
                    }
                });
                
                // Section descriptions mapping
                const sectionDescriptions = {
                    1: 'Simple descriptions, common terms',
                    2: 'Theoretical fundamentals, procedures, schematics',
                    3: 'Interrelationships, manufacturer instructions, corrective actions'
                };
                
                let questionIndex = 0;
                let lastLevel = null;
                
                // Add Section 1: Chapter info and name field
                requests.push({
                    createItem: {
                        item: {
                            title: 'Chapter Number',
                            questionItem: {
                                question: {
                                    textQuestion: {}
                                },
                                required: true
                            }
                        },
                        location: { index: questionIndex++ }
                    }
                });
                
                requests.push({
                    createItem: {
                        item: {
                            title: 'Chapter Title',
                            questionItem: {
                                question: {
                                    textQuestion: {}
                                },
                                required: true
                            }
                        },
                        location: { index: questionIndex++ }
                    }
                });
                
                requests.push({
                    createItem: {
                        item: {
                            title: 'Date',
                            questionItem: {
                                question: {
                                    textQuestion: {}
                                },
                                required: true
                            }
                        },
                        location: { index: questionIndex++ }
                    }
                });
                
                requests.push({
                    createItem: {
                        item: {
                            title: 'Full Name',
                            questionItem: {
                                question: {
                                    textQuestion: {}
                                },
                                required: true
                            }
                        },
                        location: { index: questionIndex++ }
                    }
                });
                
                // Add page break after Section 1
                requests.push({
                    createItem: {
                        item: {
                            title: '',
                            pageBreakItem: {}
                        },
                        location: { index: questionIndex++ }
                    }
                });

                selectedQuestions.forEach((item) => {
                    const { levelGroup, question, level } = item;
                    
                    // Add a page break/section for each level (only if level changed)
                    if (lastLevel !== null && lastLevel !== level && questionIndex > 0) {
                        // Add page break before new section
                        requests.push({
                            createItem: {
                                item: {
                                    title: '',
                                    pageBreakItem: {}
                                },
                                location: { index: questionIndex }
                            }
                        });
                        questionIndex++;
                    }
                    
                    // Add section title and description for each level (first time we see it)
                    if (lastLevel !== level) {
                        const sectionTitle = levelGroup.levelName;
                        const sectionDesc = sectionDescriptions[level] || '';
                        
                        // Add section title as a text question (non-required, just for display)
                        requests.push({
                            createItem: {
                                item: {
                                    title: sectionTitle,
                                    questionItem: {
                                        question: {
                                            textQuestion: {}
                                        },
                                        required: false
                                    }
                                },
                                location: { index: questionIndex }
                            }
                        });
                        questionIndex++;
                        
                        // Add section description if available
                        if (sectionDesc) {
                            requests.push({
                                createItem: {
                                    item: {
                                        title: sectionDesc,
                                        questionItem: {
                                            question: {
                                                textQuestion: {}
                                            },
                                            required: false
                                        }
                                    },
                                    location: { index: questionIndex }
                                }
                            });
                            questionIndex++;
                        }
                    }
                    
                    lastLevel = level;

                    requests.push({
                        createItem: {
                            item: {
                                title: question.question,
                                questionItem: {
                                    question: {
                                        choiceQuestion: {
                                            type: 'RADIO',
                                            options: [
                                                { value: question.options.A || '' },
                                                { value: question.options.B || '' },
                                                { value: question.options.C || '' }
                                            ],
                                            shuffle: false
                                        },
                                        grading: {
                                            pointValue: 1,
                                            correctAnswers: {
                                                answers: [{
                                                    value: question.options[question.correct] || question.options.A
                                                }]
                                            }
                                        }
                                    },
                                    required: true
                                }
                            },
                            location: { index: questionIndex }
                        }
                    });
                    questionIndex++;
                });

                // Batch update the form with all questions
                const updateResponse = await fetch(`${GOOGLE_FORMS_API}/${formId}:batchUpdate`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${googleAccessToken}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ requests })
                });

                if (!updateResponse.ok) {
                    const error = await updateResponse.json();
                    throw new Error(error.error?.message || 'Failed to add questions');
                }

                // Correct answers are already set in the createItem requests above

                // Get form URL
                const formUrl = `https://docs.google.com/forms/d/${formId}/edit`;
                const publishedUrl = `https://docs.google.com/forms/d/${formId}/viewform`;

                // Build success message with account info
                let accountInfo = '';
                if (authenticatedEmail) {
                    accountInfo = `<div class="mt-2 p-2 bg-light rounded"><small><i class="fas fa-user me-1"></i><strong>Form created with account:</strong> ${authenticatedEmail}</small></div>`;
                }
                
                statusEl.innerHTML = `
                    <div class="alert alert-success">
                        <i class="fas fa-check-circle me-2"></i>Google Form created successfully!
                        ${accountInfo}
                        <div class="mt-3">
                            <a href="${formUrl}" target="_blank" class="btn btn-sm btn-primary me-2" onclick="window.open('${formUrl}', '_blank'); return false;">
                                <i class="fas fa-edit me-1"></i>Edit Form
                            </a>
                            <a href="${publishedUrl}" target="_blank" class="btn btn-sm btn-success">
                                <i class="fas fa-external-link-alt me-1"></i>View Published Form
                            </a>
                        </div>
                        ${authenticatedEmail ? `
                        <div class="alert alert-info mt-3 mb-0">
                            <small><i class="fas fa-info-circle me-1"></i><strong>Important:</strong> Make sure you're logged into Google with the account <strong>${authenticatedEmail}</strong> when editing the form. 
                            If the form opens with a different account, sign out of Google and sign back in with the correct account, then click "Edit Form" again.</small>
                        </div>
                        ` : ''}
                    </div>
                `;

            } catch (error) {
                console.error('Form creation error:', error);
                
                // Check if it's an API not enabled error
                if (error.message.startsWith('API_NOT_ENABLED:')) {
                    const enableUrl = error.message.replace('API_NOT_ENABLED:', '');
                    statusEl.innerHTML = `
                        <div class="alert alert-warning">
                            <h5><i class="fas fa-exclamation-triangle me-2"></i>Google Forms API Needs to be Enabled</h5>
                            <p class="mb-2"><strong>Don't worry - this is easy to fix!</strong> You don't need to be a developer. Just follow these simple steps:</p>
                            <ol class="mb-3">
                                <li>Click the button below to open Google Cloud Console</li>
                                <li>Click the <strong>"Enable"</strong> button (big blue button at the top)</li>
                                <li>Wait 1-2 minutes for it to activate</li>
                                <li>Come back here and try creating the form again</li>
                            </ol>
                            <a href="${enableUrl}" target="_blank" class="btn btn-primary">
                                <i class="fas fa-external-link-alt me-2"></i>Enable Google Forms API
                            </a>
                            <p class="mt-3 mb-0"><small><strong>Note:</strong> You need to be signed in to the Google account that owns this project. If you don't have access, ask the project owner to enable it for you.</small></p>
                        </div>
                    `;
                } else {
                    statusEl.innerHTML = `
                        <div class="alert alert-danger">
                            <h5><i class="fas fa-times-circle me-2"></i>Error creating form</h5>
                            <p>${error.message}</p>
                            <small>If this is an API error, you may need to enable the Google Forms API in Google Cloud Console.</small>
                        </div>
                    `;
                }
            }
        }

        // Set correct answers for quiz questions
        async function setCorrectAnswers(formId, questionsData) {
            try {
                // Get form structure first
                const formResponse = await fetch(`${GOOGLE_FORMS_API}/${formId}`, {
                    headers: {
                        'Authorization': `Bearer ${googleAccessToken}`
                    }
                });

                const form = await formResponse.json();
                const items = form.items || [];
                
                let questionIndex = 0;
                const answerRequests = [];

                questionsData.forEach((levelGroup) => {
                    // Skip page break items
                    if (items[questionIndex]?.pageBreakItem) {
                        questionIndex++;
                    }

                    levelGroup.questions.forEach((q) => {
                        const item = items[questionIndex];
                        if (item && item.questionItem) {
                            const choices = item.questionItem.question.choiceQuestion.options;
                            const correctIndex = choices.findIndex(opt => 
                                opt.value.charAt(0) === q.correct || 
                                opt.value === q.options[q.correct]
                            );

                            if (correctIndex >= 0) {
                                answerRequests.push({
                                    updateItem: {
                                        item: {
                                            itemId: item.itemId,
                                            questionItem: {
                                                question: {
                                                    choiceQuestion: {
                                                        type: 'RADIO',
                                                        options: choices,
                                                        shuffle: false
                                                    },
                                                    grading: {
                                                        pointValue: 1,
                                                        correctAnswers: {
                                                            answers: [{
                                                                value: choices[correctIndex].value
                                                            }]
                                                        }
                                                    }
                                                }
                                            }
                                        },
                                        updateMask: 'questionItem.question.choiceQuestion,questionItem.question.grading',
                                        location: { index: questionIndex }
                                    }
                                });
                            }
                        }
                        questionIndex++;
                    });
                });

                // Batch update with correct answers
                if (answerRequests.length > 0) {
                    await fetch(`${GOOGLE_FORMS_API}/${formId}:batchUpdate`, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${googleAccessToken}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ requests: answerRequests })
                    });
                }
            } catch (error) {
                console.error('Error setting correct answers:', error);
                // Non-critical error, form will still be created
            }
        }

        // Main function to create Google Form
        async function createGoogleForm() {
            if (questions.length === 0) {
                alert('Please generate questions first');
                return;
            }

            // Show info about API setup
            document.getElementById('googleFormsInfo').style.display = 'block';

            // Check if Google API is loaded
            if (typeof google === 'undefined' || !google.accounts) {
                alert('Google API libraries are loading. Please wait a moment and try again.');
                return;
            }

            // Check if already authenticated
            if (!googleAccessToken) {
                await authenticateAndCreateForm();
            } else {
                await createFormWithAPI();
            }
        }

        // Get selected questions
        function getSelectedQuestions() {
            const selected = [];
            const checkboxes = document.querySelectorAll('.question-checkbox:checked');
            
            checkboxes.forEach(checkbox => {
                const card = checkbox.closest('.question-card');
                const level = parseInt(card.dataset.level);
                const questionIndex = parseInt(card.dataset.questionIndex);
                
                // Find the question in our questions array
                const levelGroup = questions.find(q => q.level === level);
                if (levelGroup && levelGroup.questions[questionIndex]) {
                    selected.push({
                        levelGroup: levelGroup,
                        question: levelGroup.questions[questionIndex],
                        level: level
                    });
                }
            });
            
            return selected;
        }

        // Update selection count
        function updateSelectionCount() {
            const selected = document.querySelectorAll('.question-checkbox:checked').length;
            const total = document.querySelectorAll('.question-checkbox').length;
            document.getElementById('selectedCount').textContent = `${selected} of ${total} selected`;
            document.getElementById('selectedForForm').textContent = selected;
        }

        // Select all questions
        function selectAllQuestions() {
            document.querySelectorAll('.question-checkbox').forEach(cb => {
                cb.checked = true;
                cb.closest('.question-card').classList.add('selected');
            });
            updateSelectionCount();
        }

        // Deselect all questions
        function deselectAllQuestions() {
            document.querySelectorAll('.question-checkbox').forEach(cb => {
                cb.checked = false;
                cb.closest('.question-card').classList.remove('selected');
            });
            updateSelectionCount();
        }

        // Edit a question
        function editQuestion(level, questionIndex) {
            const levelGroup = questions.find(q => q.level === level);
            if (!levelGroup || !levelGroup.questions[questionIndex]) {
                alert('Question not found');
                return;
            }

            const question = levelGroup.questions[questionIndex];
            const contentDiv = document.getElementById(`question-content-${level}-${questionIndex}`);
            
            // Create editable form
            const editHtml = `
                <div class="edit-question-form">
                    <div class="mb-3">
                        <label class="form-label"><strong>Question:</strong></label>
                        <textarea class="form-control edit-question-text" rows="3">${question.question}</textarea>
                    </div>
                    <div class="mb-3">
                        <label class="form-label"><strong>Options:</strong></label>
                        <div class="input-group mb-2">
                            <span class="input-group-text">A.</span>
                            <input type="text" class="form-control edit-option-A" value="${question.options.A || ''}">
                        </div>
                        <div class="input-group mb-2">
                            <span class="input-group-text">B.</span>
                            <input type="text" class="form-control edit-option-B" value="${question.options.B || ''}">
                        </div>
                        <div class="input-group mb-2">
                            <span class="input-group-text">C.</span>
                            <input type="text" class="form-control edit-option-C" value="${question.options.C || ''}">
                        </div>
                    </div>
                    <div class="mb-3">
                        <label class="form-label"><strong>Correct Answer:</strong></label>
                        <select class="form-select edit-correct-answer">
                            <option value="A" ${question.correct === 'A' ? 'selected' : ''}>A</option>
                            <option value="B" ${question.correct === 'B' ? 'selected' : ''}>B</option>
                            <option value="C" ${question.correct === 'C' ? 'selected' : ''}>C</option>
                        </select>
                    </div>
                    <div class="d-flex gap-2">
                        <button class="btn btn-sm btn-success" onclick="saveQuestion(${level}, ${questionIndex})">
                            <i class="fas fa-save me-1"></i>Save
                        </button>
                        <button class="btn btn-sm btn-secondary" onclick="cancelEdit(${level}, ${questionIndex})">
                            <i class="fas fa-times me-1"></i>Cancel
                        </button>
                    </div>
                </div>
            `;
            
            contentDiv.innerHTML = editHtml;
        }

        // Save edited question
        function saveQuestion(level, questionIndex) {
            const levelGroup = questions.find(q => q.level === level);
            if (!levelGroup || !levelGroup.questions[questionIndex]) {
                alert('Question not found');
                return;
            }

            const contentDiv = document.getElementById(`question-content-${level}-${questionIndex}`);
            const questionText = contentDiv.querySelector('.edit-question-text').value.trim();
            const optionA = contentDiv.querySelector('.edit-option-A').value.trim();
            const optionB = contentDiv.querySelector('.edit-option-B').value.trim();
            const optionC = contentDiv.querySelector('.edit-option-C').value.trim();
            const correctAnswer = contentDiv.querySelector('.edit-correct-answer').value;

            // Validate
            if (!questionText) {
                alert('Question text cannot be empty');
                return;
            }
            if (!optionA || !optionB || !optionC) {
                alert('All three options must be filled');
                return;
            }

            // Update question in array
            levelGroup.questions[questionIndex] = {
                question: questionText,
                options: {
                    A: optionA,
                    B: optionB,
                    C: optionC
                },
                correct: correctAnswer
            };

            // Re-display the question
            displayQuestions();
            
            // Show success message
            const alertDiv = document.createElement('div');
            alertDiv.className = 'alert alert-success alert-dismissible fade show';
            alertDiv.innerHTML = `
                <i class="fas fa-check-circle me-2"></i>Question saved successfully!
                <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
            `;
            document.getElementById('questionsContainer').insertBefore(alertDiv, document.getElementById('questionsContainer').firstChild);
            
            // Auto-dismiss after 3 seconds
            setTimeout(() => {
                alertDiv.remove();
            }, 3000);
        }

        // Cancel editing
        function cancelEdit(level, questionIndex) {
            // Just re-display questions to restore original view
            displayQuestions();
        }

        // Extract questions from text when JSON parsing fails
        function extractQuestionsFromText(text) {
            const extracted = [];
            const lines = text.split('\n');
            let currentQuestion = null;
            let optionCount = 0;

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;

                // Look for question patterns
                if (line.match(/^\d+[\.\)]\s*[A-Z]/) || line.match(/^[Qq]uestion\s*\d+[\.:]/) || 
                    (line.length > 20 && !line.match(/^[A-C][\.\)]/))) {
                    if (currentQuestion && currentQuestion.question && optionCount >= 2) {
                        extracted.push(currentQuestion);
                    }
                    currentQuestion = {
                        question: line.replace(/^\d+[\.\)]\s*/, '').replace(/^[Qq]uestion\s*\d+[\.:]\s*/, ''),
                        options: {},
                        correct: 'A'
                    };
                    optionCount = 0;
                }
                // Look for option patterns
                else if (line.match(/^[A-C][\.\)]\s*/) && currentQuestion) {
                    const option = line.charAt(0);
                    const optionText = line.substring(line.indexOf(')') + 1).trim();
                    if (optionText) {
                        currentQuestion.options[option] = optionText;
                        optionCount++;
                    }
                }
                // Look for correct answer
                else if (line.match(/[Cc]orrect\s*[Aa]nswer/i) && currentQuestion) {
                    const match = line.match(/[A-C]/);
                    if (match) {
                        currentQuestion.correct = match[0];
                    }
                }
            }

            // Add last question
            if (currentQuestion && currentQuestion.question && optionCount >= 2) {
                extracted.push(currentQuestion);
            }

            return extracted;
        }

        // Initialize Google Sign-In on page load
        window.addEventListener('load', () => {
            if (typeof google !== 'undefined' && google.accounts) {
                initializeGoogleSignIn();
            }
            updateSelectionCount();
        });
    </script>
</body>
</html>

