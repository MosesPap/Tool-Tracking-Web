<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="format-detection" content="telephone=no">
    <title>PDF Question Generator - Tool Tracking</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <link rel="stylesheet" href="css/common.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://apis.google.com/js/api.js"></script>
    <script src="https://accounts.google.com/gsi/client"></script>
    <style>
        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .main-container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .card {
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            border: none;
            margin-bottom: 20px;
        }

        .card-header {
            background: linear-gradient(135deg, #FF9800 0%, #F57C00 100%);
            color: white;
            border-radius: 15px 15px 0 0 !important;
            padding: 20px;
            font-weight: bold;
            font-size: 1.5rem;
        }

        .upload-area {
            border: 3px dashed #667eea;
            border-radius: 10px;
            padding: 40px;
            text-align: center;
            background: white;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .upload-area:hover {
            border-color: #764ba2;
            background: #f8f9fa;
        }

        .upload-area.dragover {
            border-color: #FF9800;
            background: #fff3e0;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 8px;
            padding: 12px 30px;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-success {
            background: linear-gradient(135deg, #4CAF50 0%, #388E3C 100%);
            border: none;
            border-radius: 8px;
            padding: 12px 30px;
            font-weight: bold;
        }

        .btn-danger {
            background: linear-gradient(135deg, #f44336 0%, #d32f2f 100%);
            border: none;
            border-radius: 8px;
            padding: 12px 30px;
            font-weight: bold;
        }

        .edit-question-form {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #007bff;
        }

        .edit-question-form .form-label {
            font-weight: 600;
            color: #495057;
        }

        .question-card {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            border-left: 4px solid #667eea;
            position: relative;
        }

        .question-card.selected {
            border-left: 4px solid #28a745;
            background: #f8fff9;
        }

        .question-checkbox {
            width: 20px;
            height: 20px;
            cursor: pointer;
            margin-right: 8px;
        }

        .question-number {
            font-weight: bold;
            color: #667eea;
            font-size: 1.2rem;
            margin-bottom: 10px;
        }

        .question-text {
            font-size: 1.1rem;
            margin-bottom: 15px;
            color: #333;
        }

        .option {
            padding: 12px;
            margin: 8px 0;
            border-radius: 8px;
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .option:hover {
            background: #e9ecef;
            border-color: #667eea;
        }

        .option.correct {
            background: #d4edda;
            border-color: #4CAF50;
            color: #155724;
        }

        .option.incorrect {
            background: #f8d7da;
            border-color: #f44336;
            color: #721c24;
        }

        .loading-spinner {
            display: none;
            text-align: center;
            padding: 40px;
        }

        .loading-spinner.active {
            display: block;
        }

        .spinner-border {
            width: 3rem;
            height: 3rem;
            border-width: 0.3em;
        }

        .api-key-section {
            background: #fff3cd;
            border: 2px solid #ffc107;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .pdf-preview {
            max-height: 400px;
            overflow-y: auto;
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .settings-section {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .form-label {
            font-weight: bold;
            color: #333;
        }

        .alert {
            border-radius: 8px;
            border: none;
        }
    </style>
</head>
<body>
    <div class="main-container">
        <div class="card">
            <div class="card-header d-flex justify-content-between align-items-center">
                <div>
                    <i class="fas fa-file-pdf me-2"></i>
                    PDF Question Generator
                </div>
                <button class="btn btn-sm btn-outline-light" onclick="goToMainMenu()" title="Return to Main Menu">
                    <i class="fas fa-arrow-left me-1"></i>Back to Menu
                </button>
            </div>
            <div class="card-body p-4">
                <!-- API Key Section -->
                <div class="api-key-section" style="background: #d4edda; border-color: #28a745;">
                    <h5><i class="fas fa-key me-2"></i>Google Gemini API Configuration (FREE!)</h5>
                    <p class="mb-2"><strong>Free to use!</strong> Google Gemini offers a generous free tier. Enter your API key to generate questions. Your key is saved securely and synced across all your devices when you're logged in.</p>
                    <div class="input-group mb-2">
                        <span class="input-group-text"><i class="fas fa-lock"></i></span>
                        <input type="password" id="apiKey" class="form-control" placeholder="AIza..." value="">
                        <button class="btn btn-outline-secondary" type="button" id="toggleApiKey">
                            <i class="fas fa-eye"></i>
                        </button>
                    </div>
                    <small class="text-muted">
                        Get your FREE API key from <a href="https://aistudio.google.com/app/apikey" target="_blank">Google AI Studio</a> (No credit card required!)
                        <br>
                        <strong>Note:</strong> The default project works fine! Just create an API key from Google AI Studio - no need to create a new project.
                    </small>
                    <div class="mt-2">
                        <button class="btn btn-sm btn-info" id="testApiKeyBtn" onclick="testApiKey()">
                            <i class="fas fa-check-circle me-1"></i>Test API Key
                        </button>
                        <small id="apiKeyStatus" class="ms-2"></small>
                    </div>
                </div>

                <!-- API Usage Analytics -->
                <div class="analytics-section mt-3 mb-4" style="background: #fff3cd; border-left: 4px solid #ffc107; padding: 15px; border-radius: 5px;">
                    <h5><i class="fas fa-chart-line me-2"></i>API Usage Analytics (Free Tier)</h5>
                    <div class="row mt-2">
                        <div class="col-md-4">
                            <div class="card bg-light mb-2">
                                <div class="card-body p-2">
                                    <small class="text-muted d-block">Requests Per Minute</small>
                                    <div class="d-flex justify-content-between align-items-center">
                                        <span id="rpmUsed" class="fw-bold">0</span>
                                        <span class="text-muted">/ <span id="rpmLimit">15</span></span>
                                    </div>
                                    <div class="progress mt-1" style="height: 5px;">
                                        <div id="rpmProgress" class="progress-bar" role="progressbar" style="width: 0%"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="col-md-4">
                            <div class="card bg-light mb-2">
                                <div class="card-body p-2">
                                    <small class="text-muted d-block">Requests Today</small>
                                    <div class="d-flex justify-content-between align-items-center">
                                        <span id="dailyUsed" class="fw-bold">0</span>
                                        <span class="text-muted">/ <span id="dailyLimit">1500</span></span>
                                    </div>
                                    <div class="progress mt-1" style="height: 5px;">
                                        <div id="dailyProgress" class="progress-bar bg-success" role="progressbar" style="width: 0%"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="col-md-4">
                            <div class="card bg-light mb-2">
                                <div class="card-body p-2">
                                    <small class="text-muted d-block">Total Requests</small>
                                    <div>
                                        <span id="totalRequests" class="fw-bold">0</span>
                                    </div>
                                    <small class="text-muted" id="resetTime"></small>
                                </div>
                            </div>
                        </div>
                    </div>
                    <button class="btn btn-sm btn-outline-secondary mt-2" onclick="resetAnalytics()">
                        <i class="fas fa-redo me-1"></i>Reset Analytics
                    </button>
                </div>

                <!-- Import from Excel Section -->
                <div class="settings-section mb-4" style="background: #e7f3ff; border-left: 4px solid #2196F3;">
                    <h5><i class="fas fa-file-upload me-2"></i>Import Questions from Excel</h5>
                    <p class="mb-2 text-muted">Already have questions in Excel? Import them directly to create Google Forms.</p>
                    <button class="btn btn-info" onclick="document.getElementById('excelImportFile').click()">
                        <i class="fas fa-file-upload me-2"></i>Import from Excel
                    </button>
                    <input type="file" id="excelImportFile" accept=".xlsx,.xls" style="display: none;" onchange="importFromExcel(event)">
                    <small class="d-block mt-2 text-muted">
                        <i class="fas fa-info-circle me-1"></i>Expected format: Question, Option A, Option B, Option C, Correct Answer, Knowledge Level
                    </small>
                </div>

                <!-- Settings Section -->
                <div class="settings-section">
                    <h5><i class="fas fa-cog me-2"></i>Generation Settings</h5>
                    <div class="row">
                        <div class="col-md-4 mb-3">
                            <label class="form-label">Level 1 Questions</label>
                            <input type="number" id="numQuestionsL1" class="form-control" value="5" min="0" max="20">
                            <small class="text-muted">Familiarisation level</small>
                        </div>
                        <div class="col-md-4 mb-3">
                            <label class="form-label">Level 2 Questions</label>
                            <input type="number" id="numQuestionsL2" class="form-control" value="5" min="0" max="20">
                            <small class="text-muted">General knowledge level</small>
                        </div>
                        <div class="col-md-4 mb-3">
                            <label class="form-label">Level 3 Questions</label>
                            <input type="number" id="numQuestionsL3" class="form-control" value="5" min="0" max="20">
                            <small class="text-muted">Detailed knowledge level</small>
                        </div>
                    </div>
                    <div class="row">
                        <div class="col-md-12 mb-3">
                            <label class="form-label">Page Range</label>
                            <div class="input-group" style="max-width: 300px;">
                                <input type="number" id="startPage" class="form-control" placeholder="Start" value="1" min="1" max="1000">
                                <span class="input-group-text">to</span>
                                <input type="number" id="endPage" class="form-control" placeholder="End" value="0" min="0" max="1000">
                            </div>
                            <small class="text-muted">Leave End as 0 for all pages from start</small>
                        </div>
                    </div>
                </div>

                <!-- PDF Upload Section -->
                <div class="upload-area" id="uploadArea">
                    <i class="fas fa-cloud-upload-alt fa-3x mb-3 text-primary"></i>
                    <h4>Drop your PDF file here</h4>
                    <p class="text-muted">or click to browse</p>
                    <input type="file" id="pdfFile" accept=".pdf" style="display: none;">
                    <button class="btn btn-primary mt-3" id="selectPdfButton">
                        <i class="fas fa-file-pdf me-2"></i>Select PDF File
                    </button>
                </div>

                <div id="fileInfo" class="mt-3" style="display: none;">
                    <div class="alert alert-info">
                        <i class="fas fa-file-pdf me-2"></i>
                        <span id="fileName"></span>
                        <button class="btn btn-sm btn-danger float-end" onclick="clearFile()">
                            <i class="fas fa-times"></i> Remove
                        </button>
                    </div>
                </div>

                <!-- PDF Text Preview -->
                <div id="pdfPreview" style="display: none;">
                    <h5 class="mt-4 mb-3"><i class="fas fa-eye me-2"></i>Extracted Text Preview</h5>
                    <div class="pdf-preview" id="extractedText"></div>
                </div>

                <!-- Generate Button -->
                <div class="text-center mt-4" id="generateSection" style="display: none;">
                    <button class="btn btn-success btn-lg" id="generateBtn">
                        <i class="fas fa-magic me-2"></i>Generate Questions
                    </button>
                </div>

                <!-- Loading Spinner -->
                <div class="loading-spinner" id="loadingSpinner">
                    <div class="spinner-border text-primary" role="status">
                        <span class="visually-hidden">Loading...</span>
                    </div>
                    <p class="mt-3">Processing PDF and generating questions...</p>
                </div>

                <!-- Questions Display -->
                <div id="questionsContainer" style="display: none;">
                    <h4 class="mt-4 mb-3">
                        <i class="fas fa-question-circle me-2"></i>Generated Questions
                    </h4>
                    <div class="mb-3 d-flex justify-content-between align-items-center">
                        <div>
                            <button class="btn btn-sm btn-outline-primary" onclick="selectAllQuestions()">
                                <i class="fas fa-check-square me-1"></i>Select All
                            </button>
                            <button class="btn btn-sm btn-outline-secondary ms-2" onclick="deselectAllQuestions()">
                                <i class="fas fa-square me-1"></i>Deselect All
                            </button>
                            <button class="btn btn-sm btn-danger ms-2" onclick="deleteSelectedQuestions()">
                                <i class="fas fa-trash me-1"></i>Delete Selected
                            </button>
                            <span class="ms-3 text-muted" id="selectedCount">0 selected</span>
                        </div>
                    </div>
                    <div id="questionsList"></div>
                    <!-- Google Form Settings -->
                    <div class="card mt-4 mb-4" style="background: #f8f9fa;">
                        <div class="card-header">
                            <h5><i class="fas fa-cog me-2"></i>Google Form Settings</h5>
                        </div>
                        <div class="card-body">
                            <div class="row">
                                <div class="col-md-4 mb-3">
                                    <label class="form-label"><strong>Chapter Number</strong></label>
                                    <input type="text" id="chapterNumber" class="form-control" placeholder="e.g., CH24" value="">
                                </div>
                                <div class="col-md-4 mb-3">
                                    <label class="form-label"><strong>Chapter Title</strong></label>
                                    <input type="text" id="chapterTitle" class="form-control" placeholder="e.g., Electrical System" value="">
                                </div>
                                <div class="col-md-4 mb-3">
                                    <label class="form-label"><strong>Date</strong></label>
                                    <input type="date" id="formDate" class="form-control" value="">
                                </div>
                            </div>
                            <small class="text-muted"><i class="fas fa-info-circle me-1"></i>These will be included in Section 1 of the Google Form</small>
                        </div>
                    </div>
                    
                    <div class="text-center mt-4">
                        <button class="btn btn-primary" onclick="exportQuestions()">
                            <i class="fas fa-file-excel me-2"></i>Export to Excel
                        </button>
                        <button class="btn btn-success ms-2" onclick="createGoogleForm()" id="createFormBtn">
                            <i class="fab fa-google me-2"></i>Create Google Form
                            <span class="badge bg-light text-dark ms-2" id="selectedForForm">0</span>
                        </button>
                        <button class="btn btn-secondary ms-2" onclick="clearAll()">
                            <i class="fas fa-redo me-2"></i>Start Over
                        </button>
                    </div>
                    <div id="googleAuthStatus" class="mt-3 text-center" style="display: none;"></div>
                    <div class="alert alert-info mt-3" style="display: none;" id="googleFormsInfo">
                        <small>
                            <strong>Note:</strong> To use Google Forms creation, you need to enable the Google Forms API in your Google Cloud Console.
                            <br>Go to <a href="https://console.cloud.google.com/apis/library/forms.googleapis.com" target="_blank">Google Cloud Console</a> and enable "Google Forms API" for your project.
                        </small>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <!-- Firebase SDK for syncing API key across devices -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>
    <script>
        // Initialize Firebase (same config as index.html)
        const firebaseConfig = {
            apiKey: "AIzaSyDmI0v_pVt_qFJlsqmw8QlIOi-4VLjyn54",
            authDomain: "tool-tracking-system-15e84.firebaseapp.com",
            projectId: "tool-tracking-system-15e84",
            storageBucket: "tool-tracking-system-15e84.firebasestorage.app",
            messagingSenderId: "813615362050",
            appId: "1:813615362050:web:1fa435f0b725dd1f8cb71b"
        };
        
        // Initialize Firebase if not already initialized
        if (typeof firebase !== 'undefined' && !firebase.apps.length) {
            firebase.initializeApp(firebaseConfig);
        }
    </script>
    <script>
        // Set up PDF.js worker
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        let pdfText = '';
        let questions = []; // Array of {level: 1|2|3, questions: [...]}
        let availableModels = []; // Store available models from API
        let googleAccessToken = null; // Store Google OAuth token
        let authenticatedEmail = null; // Store authenticated user's email
        const GOOGLE_CLIENT_ID = '813615362050-qopq5cb1ebtbhhicokg8ae0cko8krn77.apps.googleusercontent.com'; // From Firebase config
        const GOOGLE_FORMS_API = 'https://forms.googleapis.com/v1/forms';
        
        // API Usage Analytics Constants
        const FREE_TIER_LIMITS = {
            requestsPerMinute: 15,
            requestsPerDay: 1500
        };

        // Initialize Firebase (if not already initialized)
        let firebaseInitialized = false;
        let auth = null;
        let db = null;
        let currentUser = null;

        // Check if Firebase is available (from index.html)
        if (typeof firebase !== 'undefined') {
            try {
                // Firebase should already be initialized from index.html
                // Just get references to auth and db
                auth = firebase.auth();
                db = firebase.firestore();
                firebaseInitialized = true;
                
                // Listen for auth state changes
                auth.onAuthStateChanged((user) => {
                    currentUser = user;
                    if (user) {
                        loadApiKeyFromFirestore(user.uid);
                    } else {
                        // Fallback to localStorage if not logged in
                        loadApiKeyFromLocalStorage();
                    }
                });
            } catch (error) {
                console.warn('Firebase not available, using localStorage only:', error);
                loadApiKeyFromLocalStorage();
            }
        } else {
            // Firebase not available, use localStorage only
            loadApiKeyFromLocalStorage();
        }

        // Load API key from Firestore (synced across devices)
        async function loadApiKeyFromFirestore(userId) {
            try {
                // First, try to load from current user's document
                const userDoc = await db.collection('technicians').doc(userId).get();
                if (userDoc.exists) {
                    const userData = userDoc.data();
                    // Check if user is an instructor
                    if (userData.isInstructor && userData.geminiApiKey) {
                        document.getElementById('apiKey').value = userData.geminiApiKey;
                        localStorage.setItem('gemini_api_key', userData.geminiApiKey);
                        console.log('API key loaded from current instructor document');
                        return;
                    }
                    // If not instructor but has key, use it
                    if (userData.geminiApiKey) {
                        document.getElementById('apiKey').value = userData.geminiApiKey;
                        localStorage.setItem('gemini_api_key', userData.geminiApiKey);
                        console.log('API key loaded from current user document');
                        return;
                    }
                }
                
                // If current user is an instructor but doesn't have key, try to load from any instructor
                if (userDoc.exists && userDoc.data().isInstructor) {
                    const instructorsQuery = await db.collection('technicians')
                        .where('isInstructor', '==', true)
                        .limit(1)
                        .get();
                    
                    if (!instructorsQuery.empty) {
                        const instructorDoc = instructorsQuery.docs[0];
                        const instructorData = instructorDoc.data();
                        if (instructorData.geminiApiKey) {
                            document.getElementById('apiKey').value = instructorData.geminiApiKey;
                            localStorage.setItem('gemini_api_key', instructorData.geminiApiKey);
                            console.log('API key loaded from another instructor document');
                            return;
                        }
                    }
                }
                
                // Fallback to localStorage if not in Firestore
                loadApiKeyFromLocalStorage();
            } catch (error) {
                console.error('Error loading API key from Firestore:', error);
                loadApiKeyFromLocalStorage();
            }
        }

        // Load API key from localStorage (fallback)
        function loadApiKeyFromLocalStorage() {
            const savedApiKey = localStorage.getItem('gemini_api_key');
            if (savedApiKey) {
                document.getElementById('apiKey').value = savedApiKey;
            }
        }

        // Save API key to both Firestore and localStorage
        async function saveApiKey(apiKey) {
            // Save to localStorage immediately
            localStorage.setItem('gemini_api_key', apiKey);
            
            // Save to Firestore if user is logged in
            if (firebaseInitialized && currentUser) {
                try {
                    // First, save to current user's document
                    await db.collection('technicians').doc(currentUser.uid).set({
                        geminiApiKey: apiKey
                    }, { merge: true });
                    console.log('API key saved to current user document');
                    
                    // Check if current user is an instructor
                    const userDoc = await db.collection('technicians').doc(currentUser.uid).get();
                    if (userDoc.exists && userDoc.data().isInstructor) {
                        // If user is an instructor, save to ALL instructor documents
                        const instructorsQuery = await db.collection('technicians')
                            .where('isInstructor', '==', true)
                            .get();
                        
                        const updatePromises = [];
                        instructorsQuery.forEach((doc) => {
                            updatePromises.push(
                                db.collection('technicians').doc(doc.id).set({
                                    geminiApiKey: apiKey
                                }, { merge: true })
                            );
                        });
                        
                        await Promise.all(updatePromises);
                        console.log(`API key saved to ${instructorsQuery.size} instructor document(s) (synced across all instructors)`);
                    }
                } catch (error) {
                    console.error('Error saving API key to Firestore:', error);
                    // Continue anyway - at least localStorage is saved
                }
            }
        }

        // Toggle API key visibility
        document.getElementById('toggleApiKey').addEventListener('click', function() {
            const apiKeyInput = document.getElementById('apiKey');
            const icon = this.querySelector('i');
            if (apiKeyInput.type === 'password') {
                apiKeyInput.type = 'text';
                icon.classList.remove('fa-eye');
                icon.classList.add('fa-eye-slash');
            } else {
                apiKeyInput.type = 'password';
                icon.classList.remove('fa-eye-slash');
                icon.classList.add('fa-eye');
            }
        });

        // Save API key when changed and clear cached models
        document.getElementById('apiKey').addEventListener('change', async function() {
            const apiKey = this.value.trim();
            if (apiKey) {
                await saveApiKey(apiKey);
            }
            availableModels = []; // Clear cached models when key changes
        });
        
        // Also save on blur (when user leaves the field)
        document.getElementById('apiKey').addEventListener('blur', async function() {
            const apiKey = this.value.trim();
            if (apiKey) {
                await saveApiKey(apiKey);
            }
        });

        // Initialize analytics on page load
        updateAnalyticsDisplay();
        setInterval(updateAnalyticsDisplay, 1000); // Update every second
        
        // Back button function - must be in global scope for onclick
        // Use exact same logic as register-tools.html
        function handleBackNavigation() {
            // Set flag to skip splash video - do this FIRST before any navigation
            // Must be 'true' string to match index.html check
            sessionStorage.setItem('skipSplash', 'true');
            // Also set a flag to ensure menu is shown
            sessionStorage.setItem('showMenu', 'true');
            // Use href (same as register-tools.html) - replace might cause issues
            window.location.href = 'index.html';
        }
        
        // Make it available globally for onclick
        window.goToMainMenu = handleBackNavigation;
        window.handleBackNavigation = handleBackNavigation;

        // ========== API USAGE ANALYTICS ==========
        function trackApiCall() {
            try {
                const now = Date.now();
                const today = new Date().toDateString();
                
                // Get existing data
                let analytics = JSON.parse(localStorage.getItem('api_analytics') || '{}');
                
                // Initialize if needed
                if (!analytics.requests) analytics.requests = [];
                if (!analytics.dailyCount) analytics.dailyCount = {};
                if (!analytics.lastReset) analytics.lastReset = today;
                
                // Reset daily count if new day
                if (analytics.lastReset !== today) {
                    analytics.dailyCount = {};
                    analytics.lastReset = today;
                }
                
                // Add new request
                analytics.requests.push(now);
                analytics.dailyCount[today] = (analytics.dailyCount[today] || 0) + 1;
                
                // Clean up old requests (keep only last 2 minutes for RPM calculation)
                const twoMinutesAgo = now - 120000;
                analytics.requests = analytics.requests.filter(timestamp => timestamp > twoMinutesAgo);
                
                // Save back to localStorage
                localStorage.setItem('api_analytics', JSON.stringify(analytics));
                
                console.log('API call tracked:', {
                    timestamp: now,
                    today: today,
                    dailyCount: analytics.dailyCount[today],
                    totalRequests: analytics.requests.length
                });
                
                // Update display
                updateAnalyticsDisplay();
            } catch (error) {
                console.error('Error tracking API call:', error);
            }
        }

        function getAnalytics() {
            const analytics = JSON.parse(localStorage.getItem('api_analytics') || '{}');
            const now = Date.now();
            const oneMinuteAgo = now - 60000;
            const today = new Date().toDateString();
            
            // Count requests in last minute
            const requestsLastMinute = (analytics.requests || []).filter(timestamp => timestamp > oneMinuteAgo).length;
            
            // Count requests today
            const requestsToday = analytics.dailyCount?.[today] || 0;
            
            // Total requests (all time)
            const totalRequests = Object.values(analytics.dailyCount || {}).reduce((sum, count) => sum + count, 0);
            
            return {
                rpm: requestsLastMinute,
                daily: requestsToday,
                total: totalRequests,
                lastReset: analytics.lastReset || today
            };
        }

        function updateAnalyticsDisplay() {
            try {
                const stats = getAnalytics();
                
                // Check if elements exist
                const rpmUsedEl = document.getElementById('rpmUsed');
                const rpmLimitEl = document.getElementById('rpmLimit');
                const rpmProgressEl = document.getElementById('rpmProgress');
                const dailyUsedEl = document.getElementById('dailyUsed');
                const dailyLimitEl = document.getElementById('dailyLimit');
                const dailyProgressEl = document.getElementById('dailyProgress');
                const totalRequestsEl = document.getElementById('totalRequests');
                const resetTimeEl = document.getElementById('resetTime');
                
                if (!rpmUsedEl || !rpmLimitEl || !rpmProgressEl || !dailyUsedEl || !dailyLimitEl || !dailyProgressEl || !totalRequestsEl || !resetTimeEl) {
                    console.warn('Analytics display elements not found');
                    return;
                }
                
                // Update RPM
                const rpmUsed = stats.rpm;
                const rpmLimit = FREE_TIER_LIMITS.requestsPerMinute;
                const rpmPercent = Math.min((rpmUsed / rpmLimit) * 100, 100);
                rpmUsedEl.textContent = rpmUsed;
                rpmLimitEl.textContent = rpmLimit;
                rpmProgressEl.style.width = rpmPercent + '%';
                rpmProgressEl.className = rpmPercent >= 100 ? 'progress-bar bg-danger' : 
                                       rpmPercent >= 80 ? 'progress-bar bg-warning' : 
                                       'progress-bar bg-success';
                
                // Update Daily
                const dailyUsed = stats.daily;
                const dailyLimit = FREE_TIER_LIMITS.requestsPerDay;
                const dailyPercent = Math.min((dailyUsed / dailyLimit) * 100, 100);
                dailyUsedEl.textContent = dailyUsed;
                dailyLimitEl.textContent = dailyLimit;
                dailyProgressEl.style.width = dailyPercent + '%';
                dailyProgressEl.className = dailyPercent >= 100 ? 'progress-bar bg-danger' : 
                                         dailyPercent >= 80 ? 'progress-bar bg-warning' : 
                                         'progress-bar bg-success';
                
                // Update Total
                totalRequestsEl.textContent = stats.total;
                
                // Calculate reset time (next day at midnight)
                const tomorrow = new Date();
                tomorrow.setDate(tomorrow.getDate() + 1);
                tomorrow.setHours(0, 0, 0, 0);
                const hoursUntilReset = Math.floor((tomorrow - new Date()) / (1000 * 60 * 60));
                const minutesUntilReset = Math.floor(((tomorrow - new Date()) % (1000 * 60 * 60)) / (1000 * 60));
                resetTimeEl.textContent = `Resets in ${hoursUntilReset}h ${minutesUntilReset}m`;
                
                // Only log if values actually changed (not every second)
                if (updateAnalyticsDisplay.lastStats) {
                    const changed = updateAnalyticsDisplay.lastStats.rpm !== stats.rpm || 
                                   updateAnalyticsDisplay.lastStats.daily !== stats.daily ||
                                   updateAnalyticsDisplay.lastStats.total !== stats.total;
                    if (changed) {
                        console.log('Analytics updated:', stats);
                    }
                } else {
                    console.log('Analytics initialized:', stats);
                }
                updateAnalyticsDisplay.lastStats = stats;
            } catch (error) {
                console.error('Error updating analytics display:', error);
            }
        }

        function resetAnalytics() {
            if (confirm('Are you sure you want to reset all analytics data? This cannot be undone.')) {
                localStorage.removeItem('api_analytics');
                updateAnalyticsDisplay();
                alert('Analytics data has been reset.');
            }
        }

        // ========== DUPLICATE DETECTION ==========
        function isDuplicateQuestion(newQuestion, existingQuestions) {
            // Normalize question text for comparison (lowercase, remove extra spaces)
            const normalize = (text) => text.toLowerCase().trim().replace(/\s+/g, ' ');
            const newQText = normalize(newQuestion.question);
            
            // Check against all existing questions across all levels
            for (const levelGroup of existingQuestions) {
                for (const existingQ of levelGroup.questions) {
                    const existingQText = normalize(existingQ.question);
                    
                    // Check if question text is the same or very similar (90% similarity)
                    if (newQText === existingQText || calculateSimilarity(newQText, existingQText) > 0.9) {
                        // Also check if answers are the same
                        const newOptions = Object.values(newQuestion.options).map(v => normalize(v)).sort().join('|');
                        const existingOptions = Object.values(existingQ.options).map(v => normalize(v)).sort().join('|');
                        
                        if (newOptions === existingOptions) {
                            return true; // Duplicate question with same answers
                        }
                    }
                }
            }
            return false;
        }

        function calculateSimilarity(str1, str2) {
            // Simple similarity calculation using longest common subsequence
            const longer = str1.length > str2.length ? str1 : str2;
            const shorter = str1.length > str2.length ? str2 : str1;
            if (longer.length === 0) return 1.0;
            const editDistance = levenshteinDistance(longer, shorter);
            return (longer.length - editDistance) / longer.length;
        }

        function levenshteinDistance(str1, str2) {
            const matrix = [];
            for (let i = 0; i <= str2.length; i++) {
                matrix[i] = [i];
            }
            for (let j = 0; j <= str1.length; j++) {
                matrix[0][j] = j;
            }
            for (let i = 1; i <= str2.length; i++) {
                for (let j = 1; j <= str1.length; j++) {
                    if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
                        matrix[i][j] = matrix[i - 1][j - 1];
                    } else {
                        matrix[i][j] = Math.min(
                            matrix[i - 1][j - 1] + 1,
                            matrix[i][j - 1] + 1,
                            matrix[i - 1][j] + 1
                        );
                    }
                }
            }
            return matrix[str2.length][str1.length];
        }

        // ========== DELETE FUNCTIONALITY ==========
        function deleteQuestion(level, questionIndex) {
            if (!confirm('Are you sure you want to delete this question?')) {
                return;
            }
            
            const levelGroup = questions.find(q => q.level === level);
            if (!levelGroup || !levelGroup.questions[questionIndex]) {
                alert('Question not found');
                return;
            }
            
            levelGroup.questions.splice(questionIndex, 1);
            
            // Remove level group if no questions left
            if (levelGroup.questions.length === 0) {
                const index = questions.findIndex(q => q.level === level);
                if (index > -1) {
                    questions.splice(index, 1);
                }
            }
            
            displayQuestions();
        }

        function deleteSelectedQuestions() {
            const checkboxes = document.querySelectorAll('.question-checkbox:checked');
            if (checkboxes.length === 0) {
                alert('Please select at least one question to delete.');
                return;
            }
            
            if (!confirm(`Are you sure you want to delete ${checkboxes.length} selected question(s)?`)) {
                return;
            }
            
            // Collect questions to delete (in reverse order to maintain indices)
            const toDelete = [];
            checkboxes.forEach(checkbox => {
                const card = checkbox.closest('.question-card');
                const level = parseInt(card.dataset.level);
                const questionIndex = parseInt(card.dataset.questionIndex);
                toDelete.push({ level, questionIndex });
            });
            
            // Sort by level and index in reverse order
            toDelete.sort((a, b) => {
                if (a.level !== b.level) return b.level - a.level;
                return b.questionIndex - a.questionIndex;
            });
            
            // Delete questions
            toDelete.forEach(({ level, questionIndex }) => {
                const levelGroup = questions.find(q => q.level === level);
                if (levelGroup && levelGroup.questions[questionIndex]) {
                    levelGroup.questions.splice(questionIndex, 1);
                }
            });
            
            // Remove empty level groups
            questions = questions.filter(q => q.questions.length > 0);
            
            displayQuestions();
        }


        // File upload handling
        const uploadArea = document.getElementById('uploadArea');
        const pdfFileInput = document.getElementById('pdfFile');
        const selectPdfButton = document.getElementById('selectPdfButton');

        // Handle upload area click (but not if clicking the button)
        uploadArea.addEventListener('click', (e) => {
            // Don't trigger if clicking the button
            if (e.target.closest('#selectPdfButton')) {
                return;
            }
            pdfFileInput.click();
        });
        
        // Handle button click separately
        if (selectPdfButton) {
            selectPdfButton.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent upload area click
                pdfFileInput.click();
            });
        }

        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0 && files[0].type === 'application/pdf') {
                handleFile(files[0]);
            }
        });

        pdfFileInput.addEventListener('change', (e) => {
            if (e.target.files && e.target.files.length > 0) {
                const file = e.target.files[0];
                if (file) {
                    handleFile(file);
                }
            }
        });

        async function handleFile(file) {
            if (!file) {
                alert('No file selected');
                return;
            }

            if (!file.type.includes('pdf')) {
                alert('Please select a PDF file');
                return;
            }

            if (typeof pdfjsLib === 'undefined') {
                alert('PDF.js library not loaded. Please refresh the page.');
                console.error('pdfjsLib is not defined');
                return;
            }

            document.getElementById('fileName').textContent = file.name;
            document.getElementById('fileInfo').style.display = 'block';
            document.getElementById('pdfPreview').style.display = 'none';
            document.getElementById('generateSection').style.display = 'none';
            document.getElementById('questionsContainer').style.display = 'none';

            try {
                const arrayBuffer = await file.arrayBuffer();
                const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
                
                let fullText = '';
                let startPage = parseInt(document.getElementById('startPage').value) || 1;
                let endPage = parseInt(document.getElementById('endPage').value) || 0;
                
                // Validate and set page range
                if (startPage < 1) startPage = 1;
                if (startPage > pdf.numPages) startPage = pdf.numPages;
                if (endPage === 0 || endPage > pdf.numPages) endPage = pdf.numPages;
                if (endPage < startPage) endPage = startPage;
                
                const pagesToProcess = endPage - startPage + 1;
                
                // Show progress for large PDFs
                if (pdf.numPages > 10) {
                    document.getElementById('fileInfo').innerHTML = `
                        <div class="alert alert-info">
                            <i class="fas fa-file-pdf me-2"></i>
                            <span id="fileName">${file.name}</span>
                            <span class="ms-2">Processing pages ${startPage}-${endPage} (${pagesToProcess} pages) of ${pdf.numPages} total...</span>
                            <button class="btn btn-sm btn-danger float-end" onclick="clearFile()">
                                <i class="fas fa-times"></i> Remove
                            </button>
                        </div>
                    `;
                }
                
                for (let i = startPage; i <= endPage; i++) {
                    const page = await pdf.getPage(i);
                    const textContent = await page.getTextContent();
                    const pageText = textContent.items.map(item => item.str).join(' ');
                    fullText += pageText + '\n\n';
                }
                
                if (startPage > 1 || endPage < pdf.numPages) {
                    fullText += `\n[Note: Processed pages ${startPage}-${endPage} out of ${pdf.numPages} total pages]`;
                }

                pdfText = fullText;
                
                // Show preview (truncated if too long)
                const previewText = fullText.length > 2000 ? fullText.substring(0, 2000) + '...' : fullText;
                document.getElementById('extractedText').textContent = previewText;
                document.getElementById('pdfPreview').style.display = 'block';
                document.getElementById('generateSection').style.display = 'block';
                
                // Don't clear input value immediately - let user see the file is loaded
                // Only clear when they explicitly remove it via clearFile()
            } catch (error) {
                alert('Error reading PDF: ' + error.message);
                console.error(error);
                // Clear input on error too
                setTimeout(() => {
                    pdfFileInput.value = '';
                }, 100);
            }
        }

        function clearFile() {
            pdfFileInput.value = '';
            pdfText = '';
            document.getElementById('fileInfo').style.display = 'none';
            document.getElementById('pdfPreview').style.display = 'none';
            document.getElementById('generateSection').style.display = 'none';
            document.getElementById('questionsContainer').style.display = 'none';
        }

        function clearAll() {
            clearFile();
            questions = [];
            document.getElementById('questionsList').innerHTML = '';
        }

        document.getElementById('generateBtn').addEventListener('click', generateQuestions);

        // Function to test API key and list available models
        async function testApiKey() {
            const apiKey = document.getElementById('apiKey').value.trim();
            if (!apiKey) {
                alert('Please enter your API key first');
                return;
            }

            const statusEl = document.getElementById('apiKeyStatus');
            statusEl.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Testing...';
            statusEl.className = 'ms-2 text-info';

            try {
                // Try to list available models
                const response = await fetch(`https://generativelanguage.googleapis.com/v1/models?key=${apiKey}`);
                
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.error?.message || `HTTP ${response.status}`);
                }

                const data = await response.json();
                const models = data.models || [];
                
                // Get models that support generateContent and are Gemini models
                const geminiModels = models
                    .filter(m => {
                        const name = m.name.toLowerCase();
                        return name.includes('gemini') && 
                               m.supportedGenerationMethods && 
                               m.supportedGenerationMethods.includes('generateContent');
                    })
                    .map(m => {
                        // Extract just the model name (remove 'models/' prefix)
                        return m.name.replace('models/', '');
                    });
                
                // Store available models globally
                availableModels = geminiModels;
                
                if (geminiModels.length > 0) {
                    statusEl.innerHTML = `<i class="fas fa-check-circle text-success"></i> API Key works! Available models: ${geminiModels.length}`;
                    statusEl.className = 'ms-2 text-success';
                    console.log('Available Gemini models with generateContent:', geminiModels);
                } else {
                    statusEl.innerHTML = '<i class="fas fa-exclamation-triangle text-warning"></i> API Key works but no Gemini models found';
                    statusEl.className = 'ms-2 text-warning';
                    availableModels = [];
                }
            } catch (error) {
                statusEl.innerHTML = `<i class="fas fa-times-circle text-danger"></i> Error: ${error.message}`;
                statusEl.className = 'ms-2 text-danger';
                console.error('API Key test failed:', error);
                availableModels = [];
            }
        }

        // Randomly shuffle options for each question to ensure balanced distribution of correct answers
        function shuffleQuestionOptions(questions) {
            // Use Fisher-Yates shuffle for truly random distribution
            function shuffleArray(array) {
                const shuffled = [...array];
                for (let i = shuffled.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                }
                return shuffled;
            }
            
            // First, shuffle each question's options randomly
            let shuffledQuestions = questions.map(q => {
                // Get current options as array with their keys
                const options = [
                    { key: 'A', value: q.options.A || '' },
                    { key: 'B', value: q.options.B || '' },
                    { key: 'C', value: q.options.C || '' }
                ];
                
                // Find the current correct answer value
                const currentCorrectKey = q.correct || 'A';
                const correctValue = options.find(opt => opt.key === currentCorrectKey)?.value || options[0].value;
                
                // Randomly shuffle the options array
                const shuffledOptions = shuffleArray(options);
                
                // Rebuild options object with shuffled order
                const newOptions = {
                    A: shuffledOptions[0].value,
                    B: shuffledOptions[1].value,
                    C: shuffledOptions[2].value
                };
                
                // Find which position (A, B, or C) now contains the correct answer
                let newCorrectKey = 'A';
                if (shuffledOptions[1].value === correctValue) {
                    newCorrectKey = 'B';
                } else if (shuffledOptions[2].value === correctValue) {
                    newCorrectKey = 'C';
                }
                
                return {
                    question: q.question,
                    options: newOptions,
                    correct: newCorrectKey
                };
            });
            
            // Now ensure even distribution of correct answers across A, B, C
            const totalQuestions = shuffledQuestions.length;
            if (totalQuestions > 0) {
                // Count current distribution
                const counts = { A: 0, B: 0, C: 0 };
                shuffledQuestions.forEach(q => {
                    counts[q.correct] = (counts[q.correct] || 0) + 1;
                });
                
                // Target: roughly equal distribution (within 1 of each other)
                const targetPerLetter = Math.floor(totalQuestions / 3);
                const remainder = totalQuestions % 3;
                const targets = {
                    A: targetPerLetter + (remainder > 0 ? 1 : 0),
                    B: targetPerLetter + (remainder > 1 ? 1 : 0),
                    C: targetPerLetter
                };
                
                // If distribution is very uneven (difference > 2), rebalance
                const maxCount = Math.max(counts.A, counts.B, counts.C);
                const minCount = Math.min(counts.A, counts.B, counts.C);
                
                if (maxCount - minCount > 2) {
                    // Rebalance by swapping options to achieve even distribution
                    const letters = ['A', 'B', 'C'];
                    let rebalancedCounts = { A: 0, B: 0, C: 0 };
                    
                    shuffledQuestions = shuffledQuestions.map((q, index) => {
                        // Calculate what the correct answer should be for even distribution
                        const desiredLetter = letters[index % 3];
                        
                        // If current correct answer doesn't match desired distribution, swap options
                        if (q.correct !== desiredLetter && counts[q.correct] > targets[q.correct] && rebalancedCounts[desiredLetter] < targets[desiredLetter]) {
                            // Swap the option values so the correct answer becomes the desired letter
                            const currentCorrectValue = q.options[q.correct];
                            const desiredValue = q.options[desiredLetter];
                            
                            // Swap the values
                            const newOptions = { ...q.options };
                            newOptions[desiredLetter] = currentCorrectValue;
                            newOptions[q.correct] = desiredValue;
                            
                            counts[q.correct]--;
                            rebalancedCounts[desiredLetter]++;
                            
                            return {
                                question: q.question,
                                options: newOptions,
                                correct: desiredLetter
                            };
                        }
                        rebalancedCounts[q.correct] = (rebalancedCounts[q.correct] || 0) + 1;
                        return q;
                    });
                }
            }
            
            return shuffledQuestions;
        }

        async function generateQuestions() {
            const apiKey = document.getElementById('apiKey')?.value?.trim();
            if (!apiKey) {
                alert('Please enter your Google Gemini API key');
                return;
            }

            if (!pdfText) {
                alert('Please upload a PDF file first');
                return;
            }

            // Save API key (to both Firestore and localStorage)
            await saveApiKey(apiKey);

            // Get form values with null checks
            const numQuestionsL1 = parseInt(document.getElementById('numQuestionsL1')?.value || 0);
            const numQuestionsL2 = parseInt(document.getElementById('numQuestionsL2')?.value || 0);
            const numQuestionsL3 = parseInt(document.getElementById('numQuestionsL3')?.value || 0);
            
            // Check if at least one level has questions
            if (numQuestionsL1 === 0 && numQuestionsL2 === 0 && numQuestionsL3 === 0) {
                alert('Please specify at least one question count for any level (Level 1, 2, or 3)');
                return;
            }
            
            // Define level objectives
            const levelObjectives = {
                1: {
                    name: "Level 1 - Familiarisation",
                    description: "Familiarisation with the principal elements of the subject",
                    objectives: [
                        "The applicant should be familiar with the basic elements of the subject",
                        "The applicant should be able to give a simple description of the whole subject using common words and examples",
                        "The applicant should be able to use typical terms"
                    ]
                },
                2: {
                    name: "Level 2 - General Knowledge",
                    description: "General knowledge of the theoretical and practical aspects of the subject",
                    objectives: [
                        "The applicant should be able to understand the theoretical fundamentals of the subject",
                        "The applicant should be able to give a general description of the subject using typical examples",
                        "The applicant should be able to use mathematical formulae in conjunction with physical laws",
                        "The applicant should be able to read and understand sketches, drawings and schematics",
                        "The applicant should be able to apply knowledge in a practical manner using detailed procedures"
                    ]
                },
                3: {
                    name: "Level 3 - Detailed Knowledge",
                    description: "Detailed knowledge of the theoretical and practical aspects of the subject",
                    objectives: [
                        "The applicant should know the theory of the subject and its interrelationships with other subjects",
                        "The applicant should be able to give a detailed description using theoretical fundamentals and specific examples",
                        "The applicant should understand and be able to use mathematical formulae related to the subject",
                        "The applicant should be able to read, understand and prepare sketches, simple drawings and schematics",
                        "The applicant should be able to apply knowledge in a practical manner using manufacturer's instructions",
                        "The applicant should be able to interpret results from various sources and measurements and apply corrective action"
                    ]
                }
            };
            
            // Calculate total questions for text truncation
            const totalQuestions = numQuestionsL1 + numQuestionsL2 + numQuestionsL3;

            document.getElementById('loadingSpinner').classList.add('active');
            document.getElementById('generateSection').style.display = 'none';
            document.getElementById('questionsContainer').style.display = 'none';

            try {
                // Truncate text to prevent MAX_TOKENS error
                // Reduce text size based on total number of questions
                const baseLength = 20000;
                const lengthPerQuestion = 3000;
                const maxLength = baseLength + (totalQuestions * lengthPerQuestion);
                const adjustedLength = Math.min(maxLength, 50000); // Cap at 50K to ensure output space
                
                const textToUse = pdfText.length > adjustedLength 
                    ? pdfText.substring(0, adjustedLength) + '\n\n[Text truncated to ensure sufficient output tokens]' 
                    : pdfText;
                
                console.log(`Using ${textToUse.length} characters from PDF (${pdfText.length} total available)`);
                
                // Clear previous questions
                questions = [];
                
                // Generate questions for each level
                const levelsToGenerate = [
                    { level: 1, count: numQuestionsL1 },
                    { level: 2, count: numQuestionsL2 },
                    { level: 3, count: numQuestionsL3 }
                ].filter(l => l.count > 0);
                
                // Get available models once (outside the loop)
                let modelsToTry = [];
                
                if (availableModels.length > 0) {
                    modelsToTry = availableModels;
                    console.log('Using cached available models:', modelsToTry);
                } else {
                    try {
                        const listResponse = await fetch(`https://generativelanguage.googleapis.com/v1/models?key=${apiKey}`);
                        if (listResponse.ok) {
                            const listData = await listResponse.json();
                            modelsToTry = (listData.models || [])
                                .filter(m => {
                                    const name = m.name.toLowerCase();
                                    return name.includes('gemini') && 
                                           m.supportedGenerationMethods && 
                                           m.supportedGenerationMethods.includes('generateContent');
                                })
                                .map(m => m.name.replace('models/', ''));
                            console.log('Fetched available models:', modelsToTry);
                        }
                    } catch (e) {
                        console.log('Could not list models:', e);
                    }
                    
                    if (modelsToTry.length === 0) {
                        modelsToTry = ['gemini-1.5-flash', 'gemini-1.5-pro', 'gemini-pro'];
                        console.log('Using default models:', modelsToTry);
                    }
                }

                // Generate questions for each level
                for (const { level, count } of levelsToGenerate) {
                    const levelInfo = levelObjectives[level];
                    console.log(`Generating ${count} questions for ${levelInfo.name}...`);
                    
                    // For Level 3, add specific instructions about complexity
                    const complexityNote = level === 3 
                        ? '\nIMPORTANT FOR LEVEL 3: Generate detailed, complex questions that require deep understanding. Keep questions and options concise but comprehensive. Ensure the JSON response is complete and valid.'
                        : '';
                    
                    const levelPrompt = `Based on the following text from a PDF document, generate ${count} multiple choice questions at ${levelInfo.name}.${complexityNote}

KNOWLEDGE LEVEL REQUIREMENTS:
${levelInfo.description}

The questions must align with these objectives:
${levelInfo.objectives.map((obj, idx) => `${idx + 1}. ${obj}`).join('\n')}

Each question should have:
- A clear question stem appropriate for ${levelInfo.name}
- 3 answer options (A, B, C)
- One correct answer clearly marked
- IMPORTANT: Distribute correct answers evenly and randomly across A, B, and C options. 
  For ${count} questions, ensure roughly equal distribution (not all A, not all B, not all C, and not in a pattern like first=A, middle=B, last=C).
- Questions should test knowledge at the specified level depth
- Questions should be varied in style (factual, comprehension, application, analysis) as appropriate for the level

Format the response as a JSON array with this structure:
[
  {
    "question": "Question text here?",
    "options": {
      "A": "Option A text",
      "B": "Option B text",
      "C": "Option C text"
    },
    "correct": "A"
  }
]

Text content:
${textToUse}

Return ONLY the JSON array, no additional text or markdown formatting.`;

                    let data = null;
                    let lastError = null;

                    // Try to generate questions for this level
                    for (const model of modelsToTry) {
                        try {
                            const endpoints = [
                                `https://generativelanguage.googleapis.com/v1/models/${model}:generateContent?key=${apiKey}`,
                                `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`
                            ];

                            let apiCallTracked = false; // Track if we've already counted this API call
                            
                            for (const url of endpoints) {
                                try {
                                    const response = await fetch(url, {
                                        method: 'POST',
                                        headers: { 'Content-Type': 'application/json' },
                                        body: JSON.stringify({
                                            contents: [{ parts: [{ text: levelPrompt }] }],
                                            generationConfig: {
                                                temperature: 0.7,
                                                // Level 3 questions are more complex and need more tokens
                                                maxOutputTokens: level === 3 ? Math.max(8192, count * 1500) : Math.max(4096, count * 1000)
                                            }
                                        })
                                    });

                                    if (response.ok) {
                                        // Track API call for analytics - only once per level generation
                                        if (!apiCallTracked) {
                                            trackApiCall();
                                            apiCallTracked = true;
                                            console.log('API call tracked for Level', level);
                                        }
                                        
                                        data = await response.json();
                                        if (data.error) {
                                            lastError = data.error.message || 'API returned an error';
                                            continue;
                                        }
                                        
                                        // Check for truncation issues (especially for Level 3)
                                        if (data.candidates?.[0]?.finishReason === 'MAX_TOKENS') {
                                            console.warn(`Response truncated for Level ${level}. May need more tokens.`);
                                            if (level === 3) {
                                                console.warn('Level 3 response was truncated. Try generating fewer questions at once or the response may be incomplete.');
                                            }
                                            // Still try to use what we got, but warn user
                                        }
                                        
                                        console.log(`Successfully used model: ${model} for Level ${level}`);
                                        break;
                                    } else {
                                        const errorData = await response.json().catch(() => ({}));
                                        lastError = errorData.error?.message || `HTTP ${response.status}`;
                                    }
                                } catch (err) {
                                    lastError = err.message;
                                }
                            }

                            if (data) break;
                        } catch (err) {
                            lastError = err.message;
                            continue;
                        }
                    }

                    if (!data) {
                        console.error(`Failed to generate Level ${level} questions:`, lastError);
                        continue; // Skip this level and continue with others
                    }

                    // Parse response
                    let content = '';
                    if (data.candidates?.[0]?.content?.parts?.[0]?.text) {
                        content = data.candidates[0].content.parts[0].text;
                    } else if (data.candidates?.[0]?.text) {
                        content = data.candidates[0].text;
                    } else {
                        console.error(`No content in response for Level ${level}`);
                        continue;
                    }

                    content = content.trim();
                    if (content.startsWith('```')) {
                        content = content.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
                    }

                    try {
                        // Try to fix common JSON issues before parsing
                        let cleanedContent = content;
                        
                        // Remove any text before the first [
                        const firstBracket = cleanedContent.indexOf('[');
                        if (firstBracket > 0) {
                            cleanedContent = cleanedContent.substring(firstBracket);
                        }
                        
                        // Remove any text after the last ]
                        const lastBracket = cleanedContent.lastIndexOf(']');
                        if (lastBracket > 0 && lastBracket < cleanedContent.length - 1) {
                            cleanedContent = cleanedContent.substring(0, lastBracket + 1);
                        }
                        
                        // Fix common JSON issues
                        cleanedContent = cleanedContent
                            .replace(/([{,]\s*)(\w+)(\s*:)/g, '$1"$2"$3') // Fix unquoted keys
                            .replace(/,\s*}/g, '}') // Remove trailing commas
                            .replace(/,\s*]/g, ']'); // Remove trailing commas in arrays
                        
                        let levelQuestions = JSON.parse(cleanedContent);
                        
                        // Validate it's an array
                        if (!Array.isArray(levelQuestions)) {
                            throw new Error('Response is not an array');
                        }
                        
                        // Randomly shuffle options for each question to ensure balanced distribution of correct answers
                        levelQuestions = shuffleQuestionOptions(levelQuestions);
                        
                        // Filter out duplicates before adding
                        const existingQuestions = questions; // All questions generated so far
                        const uniqueQuestions = levelQuestions.filter(q => !isDuplicateQuestion(q, existingQuestions));
                        const duplicatesRemoved = levelQuestions.length - uniqueQuestions.length;
                        
                        if (duplicatesRemoved > 0) {
                            console.warn(`Removed ${duplicatesRemoved} duplicate question(s) from Level ${level}`);
                        }
                        
                        if (uniqueQuestions.length > 0) {
                            questions.push({ level, levelName: levelInfo.name, questions: uniqueQuestions });
                            console.log(`Successfully generated ${uniqueQuestions.length} questions for ${levelInfo.name}${duplicatesRemoved > 0 ? ` (${duplicatesRemoved} duplicates removed)` : ''}`);
                        } else {
                            console.warn(`All questions for Level ${level} were duplicates. Skipping this level.`);
                        }
                    } catch (parseError) {
                        console.error(`Failed to parse questions for Level ${level}:`, parseError);
                        console.error('Content that failed to parse:', content.substring(0, 1000));
                        
                        // For Level 3, show more detailed error info
                        if (level === 3) {
                            console.error('Level 3 parsing error details:', {
                                contentLength: content.length,
                                firstChars: content.substring(0, 200),
                                lastChars: content.substring(Math.max(0, content.length - 200)),
                                errorMessage: parseError.message
                            });
                        }
                        
                        // Try to extract questions manually if JSON parsing fails
                        try {
                            let manualQuestions = extractQuestionsFromText(content);
                            if (manualQuestions.length > 0) {
                                // Randomly shuffle options for manually extracted questions too
                                manualQuestions = shuffleQuestionOptions(manualQuestions);
                                
                                // Filter out duplicates
                                const existingQuestions = questions;
                                const uniqueManualQuestions = manualQuestions.filter(q => !isDuplicateQuestion(q, existingQuestions));
                                const duplicatesRemoved = manualQuestions.length - uniqueManualQuestions.length;
                                
                                if (duplicatesRemoved > 0) {
                                    console.warn(`Removed ${duplicatesRemoved} duplicate question(s) from manually extracted Level ${level} questions`);
                                }
                                
                                if (uniqueManualQuestions.length > 0) {
                                    questions.push({ level, levelName: levelInfo.name, questions: uniqueManualQuestions });
                                    console.log(`Manually extracted ${uniqueManualQuestions.length} questions for ${levelInfo.name}`);
                                } else {
                                    console.warn(`All manually extracted questions for Level ${level} were duplicates.`);
                                }
                            } else {
                                const errorMsg = level === 3 
                                    ? `Could not extract any questions for Level 3. The response may be incomplete or truncated. Try generating fewer Level 3 questions at once, or check the console for details.`
                                    : `Could not extract any questions for Level ${level}. The response may be incomplete.`;
                                console.warn(errorMsg);
                                // Still continue - other levels may have worked
                            }
                        } catch (extractError) {
                            console.error(`Failed to extract questions manually:`, extractError);
                            if (level === 3) {
                                console.error('Level 3 manual extraction also failed. The API response may be malformed or incomplete. Try reducing the number of Level 3 questions.');
                            }
                            // Continue with other levels
                        }
                    }
                }

                if (questions.length === 0) {
                    throw new Error('Failed to generate questions for any level. Please check your API key and try again.');
                }
                
                displayQuestions();
            } catch (error) {
                alert('Error generating questions: ' + error.message + '\n\nMake sure your API key is correct and you have not exceeded the free tier limits.');
                console.error(error);
            } finally {
                document.getElementById('loadingSpinner').classList.remove('active');
                document.getElementById('generateSection').style.display = 'block';
            }
        }

        function displayQuestions() {
            const container = document.getElementById('questionsList');
            container.innerHTML = '';

            // Display questions grouped by level
            questions.forEach((levelGroup) => {
                // Add level header
                const levelHeader = document.createElement('div');
                levelHeader.className = 'mb-4';
                levelHeader.innerHTML = `
                    <h5 class="text-primary mb-3">
                        <i class="fas fa-layer-group me-2"></i>${levelGroup.levelName}
                        <span class="badge bg-secondary ms-2">${levelGroup.questions.length} questions</span>
                    </h5>
                `;
                container.appendChild(levelHeader);

                // Display questions for this level
                levelGroup.questions.forEach((q, index) => {
                    const questionCard = document.createElement('div');
                    questionCard.className = 'question-card';
                    questionCard.dataset.level = levelGroup.level;
                    questionCard.dataset.questionIndex = index;
                    
                    // Create unique ID for checkbox
                    const checkboxId = `q-${levelGroup.level}-${index}`;
                    
                    const questionHtml = `
                        <div class="d-flex justify-content-between align-items-start mb-2">
                            <div class="d-flex align-items-center">
                                <input type="checkbox" class="question-checkbox" id="${checkboxId}" checked onchange="updateSelectionCount()">
                                <div class="question-number ms-2">Question ${index + 1}</div>
                            </div>
                            <div>
                                <button class="btn btn-sm btn-outline-primary edit-question-btn" onclick="editQuestion(${levelGroup.level}, ${index})">
                                    <i class="fas fa-edit me-1"></i>Edit
                                </button>
                                <button class="btn btn-sm btn-outline-danger ms-1" onclick="deleteQuestion(${levelGroup.level}, ${index})" title="Delete this question">
                                    <i class="fas fa-trash"></i>
                                </button>
                            </div>
                        </div>
                        <div class="question-content" id="question-content-${levelGroup.level}-${index}">
                            <div class="question-text">${q.question}</div>
                            <div class="options">
                                ${Object.entries(q.options).map(([key, value]) => 
                                    `<div class="option" data-option="${key}">
                                        <strong>${key}.</strong> ${value}
                                    </div>`
                                ).join('')}
                            </div>
                            <div class="mt-3">
                                <small class="text-muted">
                                    <strong>Correct Answer:</strong> <span class="badge bg-success">${q.correct}</span>
                                </small>
                            </div>
                        </div>
                    `;
                    
                    questionCard.innerHTML = questionHtml;
                    
                    // Add visual feedback for selection
                    const checkbox = questionCard.querySelector('.question-checkbox');
                    checkbox.addEventListener('change', function() {
                        if (this.checked) {
                            questionCard.classList.add('selected');
                        } else {
                            questionCard.classList.remove('selected');
                        }
                        updateSelectionCount();
                    });
                    
                    // Initially selected
                    questionCard.classList.add('selected');
                    
                    // Add click handlers to show correct/incorrect
                    const options = questionCard.querySelectorAll('.option');
                    options.forEach(option => {
                        option.addEventListener('click', function() {
                            const selectedOption = this.dataset.option;
                            options.forEach(opt => {
                                opt.classList.remove('correct', 'incorrect');
                                if (opt.dataset.option === q.correct) {
                                    opt.classList.add('correct');
                                } else if (opt.dataset.option === selectedOption && selectedOption !== q.correct) {
                                    opt.classList.add('incorrect');
                                }
                            });
                        });
                    });
                    
                    container.appendChild(questionCard);
                });
            });

            document.getElementById('questionsContainer').style.display = 'block';
            updateSelectionCount(); // Update count after displaying questions
        }

        async function exportQuestions() {
            try {
                // Create Excel workbook
                const wb = XLSX.utils.book_new();
                
                // Prepare data for Excel - horizontal format, grouped by level
                const excelData = [
                    // Header row
                    ['Question', 'Option A', 'Option B', 'Option C', 'Correct Answer', 'Knowledge Level']
                ];
                
                // Add questions grouped by level
                questions.forEach((levelGroup) => {
                    // Add level separator row
                    excelData.push([`--- ${levelGroup.levelName} ---`, '', '', '', '', '']);
                    
                    // Add each question as a row
                    levelGroup.questions.forEach((q) => {
                        const row = [
                            q.question,
                            q.options.A || '',
                            q.options.B || '',
                            q.options.C || '',
                            q.correct,
                            levelGroup.levelName
                        ];
                        excelData.push(row);
                    });
                    
                    // Add empty row between levels
                    excelData.push(['', '', '', '', '', '']);
                });
                
                // Create worksheet
                const ws = XLSX.utils.aoa_to_sheet(excelData);
                
                // Set column widths for better readability
                ws['!cols'] = [
                    { wch: 60 },  // Question column - wider
                    { wch: 40 },  // Option A
                    { wch: 40 },  // Option B
                    { wch: 40 },  // Option C
                    { wch: 15 },  // Correct Answer
                    { wch: 30 }   // Knowledge Level
                ];
                
                // Add worksheet to workbook
                XLSX.utils.book_append_sheet(wb, ws, 'Questions');
                
                // Generate Excel file and let user choose save location
                const fileName = `generated_questions_${new Date().toISOString().split('T')[0]}.xlsx`;
                
                // Try to use File System Access API to let user choose folder (Chrome/Edge)
                if ('showSaveFilePicker' in window) {
                    try {
                        const fileHandle = await window.showSaveFilePicker({
                            suggestedName: fileName,
                            types: [{
                                description: 'Excel files',
                                accept: { 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet': ['.xlsx'] }
                            }]
                        });
                        
                        // Convert workbook to array buffer
                        const excelBuffer = XLSX.write(wb, { type: 'array', bookType: 'xlsx' });
                        
                        // Write to the selected file
                        const writable = await fileHandle.createWritable();
                        await writable.write(new Blob([excelBuffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' }));
                        await writable.close();
                        
                        // Show success message
                        alert(`Questions exported successfully to ${fileHandle.name}`);
                    } catch (error) {
                        // User cancelled or error occurred, fall back to automatic download
                        if (error.name !== 'AbortError') {
                            console.warn('File System Access API failed, using fallback:', error);
                        }
                        // Fall through to automatic download
                        XLSX.writeFile(wb, fileName);
                        alert(`Questions exported successfully to ${fileName} (saved to Downloads folder)`);
                    }
                } else {
                    // Fallback for browsers that don't support File System Access API
                    XLSX.writeFile(wb, fileName);
                    alert(`Questions exported successfully to ${fileName} (saved to Downloads folder)\n\nNote: To choose a custom folder, use Chrome or Edge browser.`);
                }
            } catch (error) {
                console.error('Export error:', error);
                alert('Error exporting to Excel. Trying text format instead...');
                
                // Fallback to text export
                let exportText = 'PDF Question Generator - Generated Questions\n';
                exportText += '='.repeat(50) + '\n\n';

                questions.forEach((levelGroup) => {
                    exportText += `${levelGroup.levelName}\n`;
                    exportText += '='.repeat(50) + '\n\n';
                    
                    levelGroup.questions.forEach((q, index) => {
                        exportText += `Question ${index + 1}: ${q.question}\n\n`;
                        Object.entries(q.options).forEach(([key, value]) => {
                            exportText += `  ${key}. ${value}\n`;
                        });
                        exportText += `\nCorrect Answer: ${q.correct}\n\n`;
                        exportText += '-'.repeat(50) + '\n\n';
                    });
                });

                const blob = new Blob([exportText], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'generated_questions.txt';
                a.click();
                URL.revokeObjectURL(url);
            }
        }

        // Import questions from Excel file
        async function importFromExcel(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (!file.name.match(/\.(xlsx|xls)$/i)) {
                alert('Please select an Excel file (.xlsx or .xls)');
                return;
            }

            try {
                const arrayBuffer = await file.arrayBuffer();
                const workbook = XLSX.read(arrayBuffer, { type: 'array' });
                const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                const data = XLSX.utils.sheet_to_json(firstSheet, { header: 1, defval: '' });

                // Parse Excel data - expect format: Question, Option A, Option B, Option C, Correct Answer, Knowledge Level
                const importedQuestions = [];
                let currentLevel = null;
                let currentLevelName = null;
                let levelQuestions = [];

                for (let i = 0; i < data.length; i++) {
                    const row = data[i];
                    
                    // Skip empty rows
                    if (!row || row.length === 0 || !row[0]) continue;

                    const firstCell = String(row[0]).trim();

                    // Check if it's a level header (starts with "---" or contains "Level")
                    if (firstCell.includes('Level') || firstCell.startsWith('---')) {
                        // Save previous level if exists
                        if (currentLevel !== null && levelQuestions.length > 0) {
                            importedQuestions.push({
                                level: currentLevel,
                                levelName: currentLevelName,
                                questions: levelQuestions
                            });
                            levelQuestions = [];
                        }

                        // Extract level from header
                        if (firstCell.includes('Level 1') || firstCell.includes('Familiarisation')) {
                            currentLevel = 1;
                            currentLevelName = 'Level 1 - Familiarisation';
                        } else if (firstCell.includes('Level 2') || firstCell.includes('General')) {
                            currentLevel = 2;
                            currentLevelName = 'Level 2 - General Knowledge';
                        } else if (firstCell.includes('Level 3') || firstCell.includes('Detailed')) {
                            currentLevel = 3;
                            currentLevelName = 'Level 3 - Detailed Knowledge';
                        }
                        continue;
                    }

                    // Check if it's a header row
                    if (firstCell.toLowerCase().includes('question') && 
                        (row[1] && String(row[1]).toLowerCase().includes('option'))) {
                        continue; // Skip header row
                    }

                    // Parse question row
                    if (row[0] && row[1] && row[2] && row[3]) {
                        const question = {
                            question: String(row[0]).trim(),
                            options: {
                                A: String(row[1] || '').trim(),
                                B: String(row[2] || '').trim(),
                                C: String(row[3] || '').trim()
                            },
                            correct: String(row[4] || 'A').trim().toUpperCase()
                        };

                        // Determine level from row or use current level
                        let questionLevel = currentLevel;
                        if (row[5]) {
                            const levelText = String(row[5]).trim();
                            if (levelText.includes('Level 1') || levelText.includes('Familiarisation')) {
                                questionLevel = 1;
                            } else if (levelText.includes('Level 2') || levelText.includes('General')) {
                                questionLevel = 2;
                            } else if (levelText.includes('Level 3') || levelText.includes('Detailed')) {
                                questionLevel = 3;
                            }
                        }

                        if (!questionLevel) questionLevel = 2; // Default to Level 2

                        // Add to appropriate level
                        let levelGroup = importedQuestions.find(q => q.level === questionLevel);
                        if (!levelGroup) {
                            const levelNames = {
                                1: 'Level 1 - Familiarisation',
                                2: 'Level 2 - General Knowledge',
                                3: 'Level 3 - Detailed Knowledge'
                            };
                            levelGroup = {
                                level: questionLevel,
                                levelName: levelNames[questionLevel],
                                questions: []
                            };
                            importedQuestions.push(levelGroup);
                        }
                        levelGroup.questions.push(question);
                    }
                }

                // Add remaining questions from current level
                if (currentLevel !== null && levelQuestions.length > 0) {
                    let levelGroup = importedQuestions.find(q => q.level === currentLevel);
                    if (!levelGroup) {
                        levelGroup = {
                            level: currentLevel,
                            levelName: currentLevelName,
                            questions: []
                        };
                        importedQuestions.push(levelGroup);
                    }
                    levelGroup.questions.push(...levelQuestions);
                }

                if (importedQuestions.length === 0) {
                    alert('No questions found in the Excel file. Please check the format.');
                    return;
                }

                questions = importedQuestions;
                displayQuestions();
                updateSelectionCount();
                
                const totalQuestions = importedQuestions.reduce((sum, lg) => sum + lg.questions.length, 0);
                alert(`Successfully imported ${totalQuestions} questions from ${importedQuestions.length} level(s)`);
                
                // Clear file input
                event.target.value = '';
            } catch (error) {
                console.error('Import error:', error);
                alert('Error importing Excel file: ' + error.message);
            }
        }

        // Initialize Google Sign-In (not used for OAuth, but kept for compatibility)
        function initializeGoogleSignIn() {
            // OAuth uses tokenClient directly, no need to initialize ID
        }

        // Handle Google Sign-In callback
        function handleGoogleSignIn(response) {
            if (response.credential) {
                // Exchange credential for access token
                fetch('https://oauth2.googleapis.com/token', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                    body: new URLSearchParams({
                        code: response.credential,
                        client_id: GOOGLE_CLIENT_ID,
                        grant_type: 'authorization_code',
                        redirect_uri: window.location.origin + window.location.pathname
                    })
                }).then(r => r.json())
                .then(data => {
                    googleAccessToken = data.access_token;
                    document.getElementById('googleAuthStatus').innerHTML = 
                        '<div class="alert alert-success"><i class="fas fa-check-circle me-2"></i>Signed in to Google. You can now create forms!</div>';
                    document.getElementById('googleAuthStatus').style.display = 'block';
                    createGoogleForm();
                })
                .catch(err => {
                    console.error('Token exchange error:', err);
                    // Try direct approach with Forms API
                    authenticateAndCreateForm();
                });
            }
        }

        // Alternative authentication using Google Identity Services
        async function authenticateAndCreateForm() {
            if (questions.length === 0) {
                alert('Please generate questions first');
                return;
            }

            const statusEl = document.getElementById('googleAuthStatus');
            statusEl.style.display = 'block';
            statusEl.innerHTML = '<div class="alert alert-info"><i class="fas fa-spinner fa-spin me-2"></i>Authenticating with Google...</div>';

            try {
                // Use Google Identity Services for authentication
                const tokenClient = google.accounts.oauth2.initTokenClient({
                    client_id: GOOGLE_CLIENT_ID,
                    scope: 'https://www.googleapis.com/auth/forms.body https://www.googleapis.com/auth/drive.file',
                    callback: async (tokenResponse) => {
                        if (tokenResponse.error) {
                            console.error('OAuth error:', tokenResponse.error);
                            statusEl.innerHTML = '<div class="alert alert-danger"><i class="fas fa-times-circle me-2"></i>Authentication failed: ' + tokenResponse.error + '. Please check your Google Cloud Console OAuth settings.</div>';
                            return;
                        }
                        googleAccessToken = tokenResponse.access_token;
                        
                        // Get user info to show which account is authenticated
                        try {
                            const userInfoResponse = await fetch('https://www.googleapis.com/oauth2/v2/userinfo', {
                                headers: {
                                    'Authorization': `Bearer ${googleAccessToken}`
                                }
                            });
                            if (userInfoResponse.ok) {
                                const userInfo = await userInfoResponse.json();
                                authenticatedEmail = userInfo.email;
                                console.log('Authenticated as:', authenticatedEmail);
                            }
                        } catch (e) {
                            console.log('Could not fetch user info:', e);
                        }
                        
                        createFormWithAPI();
                    }
                });

                // Request access token - OAuth2 uses postMessage by default, no redirect_uri needed
                // Use 'select_account' to let user choose the correct account
                tokenClient.requestAccessToken({ prompt: 'select_account consent' });
            } catch (error) {
                console.error('Auth error:', error);
                statusEl.innerHTML = '<div class="alert alert-danger"><i class="fas fa-times-circle me-2"></i>Authentication failed. Please try again.</div>';
            }
        }

        // Create Google Form using the API
        async function createFormWithAPI() {
            const statusEl = document.getElementById('googleAuthStatus');
            
            if (!googleAccessToken) {
                await authenticateAndCreateForm();
                return;
            }

            statusEl.innerHTML = '<div class="alert alert-info"><i class="fas fa-spinner fa-spin me-2"></i>Creating Google Form...</div>';

            try {
                // Create form - ONLY title can be set during creation
                const initialFormData = {
                    info: {
                        title: `PDF Generated Quiz - ${new Date().toLocaleDateString()}`
                    }
                };

                // Create the form
                const initialCreateResponse = await fetch(GOOGLE_FORMS_API, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${googleAccessToken}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(initialFormData)
                });

                if (!initialCreateResponse.ok) {
                    const error = await initialCreateResponse.json();
                    const errorMessage = error.error?.message || 'Failed to create form';
                    
                    // Check if it's an API not enabled error
                    if (errorMessage.includes('has not been used') || errorMessage.includes('is disabled') || errorMessage.includes('Enable it by visiting')) {
                        // Extract the enable URL if present
                        const urlMatch = errorMessage.match(/https:\/\/[^\s]+/);
                        const enableUrl = urlMatch ? urlMatch[0] : `https://console.cloud.google.com/apis/api/forms.googleapis.com/overview?project=813615362050`;
                        
                        throw new Error('API_NOT_ENABLED:' + enableUrl);
                    }
                    
                    throw new Error(errorMessage);
                }

                const initialForm = await initialCreateResponse.json();
                const formId = initialForm.formId;

                // Get selected questions only
                const selectedQuestions = getSelectedQuestions();
                
                if (selectedQuestions.length === 0) {
                    statusEl.innerHTML = '<div class="alert alert-warning"><i class="fas fa-exclamation-triangle me-2"></i>Please select at least one question to include in the form.</div>';
                    return;
                }

                // Prepare batch update requests
                const requests = [];
                
                // First, set quiz settings and description via batchUpdate
                requests.push({
                    updateSettings: {
                        settings: {
                            quizSettings: {
                                isQuiz: true
                            }
                        },
                        updateMask: 'quizSettings.isQuiz'
                    }
                });
                
                // Get form metadata
                const chapterNumber = document.getElementById('chapterNumber')?.value?.trim() || '';
                const chapterTitle = document.getElementById('chapterTitle')?.value?.trim() || '';
                const formDate = document.getElementById('formDate')?.value || new Date().toISOString().split('T')[0];
                
                // Format date for display
                const dateObj = new Date(formDate);
                const formattedDate = dateObj.toLocaleDateString('en-GB', { day: '2-digit', month: '2-digit', year: 'numeric' });
                
                // Create form title
                let formTitle = '';
                if (chapterNumber && chapterTitle) {
                    formTitle = `${chapterNumber} ${chapterTitle} - ${formattedDate}`;
                } else if (chapterNumber) {
                    formTitle = `${chapterNumber} - ${formattedDate}`;
                } else if (chapterTitle) {
                    formTitle = `${chapterTitle} - ${formattedDate}`;
                } else {
                    formTitle = `Quiz - ${formattedDate}`;
                }
                
                requests.push({
                    updateFormInfo: {
                        info: {
                            title: formTitle,
                            description: ''
                        },
                        updateMask: 'title,description'
                    }
                });
                
                // Section descriptions mapping
                const sectionDescriptions = {
                    1: 'Simple descriptions, common terms',
                    2: 'Theoretical fundamentals, procedures, schematics',
                    3: 'Interrelationships, manufacturer instructions, corrective actions'
                };
                
                let questionIndex = 0;
                let lastLevel = null;
                
                // Track item indices for setting required status later
                const requiredItemIndices = [];
                
                // Add Section 1: Chapter info and name field
                requests.push({
                    createItem: {
                        item: {
                            title: 'Chapter Number',
                            questionItem: {
                                question: {
                                    textQuestion: {}
                                }
                            }
                        },
                        location: { index: questionIndex }
                    }
                });
                requiredItemIndices.push(questionIndex++);
                
                requests.push({
                    createItem: {
                        item: {
                            title: 'Chapter Title',
                            questionItem: {
                                question: {
                                    textQuestion: {}
                                }
                            }
                        },
                        location: { index: questionIndex }
                    }
                });
                requiredItemIndices.push(questionIndex++);
                
                requests.push({
                    createItem: {
                        item: {
                            title: 'Date',
                            questionItem: {
                                question: {
                                    textQuestion: {}
                                }
                            }
                        },
                        location: { index: questionIndex }
                    }
                });
                requiredItemIndices.push(questionIndex++);
                
                requests.push({
                    createItem: {
                        item: {
                            title: 'Full Name',
                            questionItem: {
                                question: {
                                    textQuestion: {}
                                }
                            }
                        },
                        location: { index: questionIndex }
                    }
                });
                requiredItemIndices.push(questionIndex++);
                
                // Add page break after Section 1
                requests.push({
                    createItem: {
                        item: {
                            title: '',
                            pageBreakItem: {}
                        },
                        location: { index: questionIndex++ }
                    }
                });

                selectedQuestions.forEach((item) => {
                    const { levelGroup, question, level } = item;
                    
                    // Add a page break/section for each level (only if level changed)
                    if (lastLevel !== null && lastLevel !== level && questionIndex > 0) {
                        // Add page break before new section
                        requests.push({
                            createItem: {
                                item: {
                                    title: '',
                                    pageBreakItem: {}
                                },
                                location: { index: questionIndex }
                            }
                        });
                        questionIndex++;
                    }
                    
                    // Add section title and description for each level (first time we see it)
                    if (lastLevel !== level) {
                        const sectionTitle = levelGroup.levelName;
                        const sectionDesc = sectionDescriptions[level] || '';
                        
                        // Add section title as a text question (non-required, just for display)
                        requests.push({
                            createItem: {
                                item: {
                                    title: sectionTitle,
                                    questionItem: {
                                        question: {
                                            textQuestion: {}
                                        }
                                    }
                                },
                                location: { index: questionIndex }
                            }
                        });
                        questionIndex++;
                        
                        // Add section description if available
                        if (sectionDesc) {
                            requests.push({
                                createItem: {
                                    item: {
                                        title: sectionDesc,
                                        questionItem: {
                                            question: {
                                                textQuestion: {}
                                            }
                                        }
                                    },
                                    location: { index: questionIndex }
                                }
                            });
                            questionIndex++;
                        }
                    }
                    
                    lastLevel = level;

                    requests.push({
                        createItem: {
                            item: {
                                title: question.question,
                                questionItem: {
                                    question: {
                                        choiceQuestion: {
                                            type: 'RADIO',
                                            options: [
                                                { value: question.options.A || '' },
                                                { value: question.options.B || '' },
                                                { value: question.options.C || '' }
                                            ],
                                            shuffle: false
                                        },
                                        grading: {
                                            pointValue: 1,
                                            correctAnswers: {
                                                answers: [{
                                                    value: question.options[question.correct] || question.options.A
                                                }]
                                            }
                                        }
                                    }
                                }
                            },
                            location: { index: questionIndex }
                        }
                    });
                    requiredItemIndices.push(questionIndex++);
                });

                // First batch: Create all items
                const batchCreateResponse = await fetch(`${GOOGLE_FORMS_API}/${formId}:batchUpdate`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${googleAccessToken}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ requests })
                });

                if (!batchCreateResponse.ok) {
                    const error = await batchCreateResponse.json();
                    throw new Error(error.error?.message || 'Failed to add questions');
                }

                // Get the created items to update them
                const formFetchResponse = await fetch(`${GOOGLE_FORMS_API}/${formId}`, {
                    headers: {
                        'Authorization': `Bearer ${googleAccessToken}`
                    }
                });
                
                if (!formFetchResponse.ok) {
                    throw new Error('Failed to fetch form structure');
                }
                
                const fetchedFormData = await formFetchResponse.json();
                const items = fetchedFormData.items || [];
                
                // Second batch: Set required status for all questions
                const updateRequests = [];
                requiredItemIndices.forEach(index => {
                    if (items[index] && items[index].questionItem) {
                        updateRequests.push({
                            updateItem: {
                                item: {
                                    questionItem: {
                                        question: items[index].questionItem.question || {},
                                        required: true
                                    }
                                },
                                location: { index },
                                updateMask: 'questionItem.required'
                            }
                        });
                    }
                });
                
                // Update required status if there are items to update
                if (updateRequests.length > 0) {
                    const updateResponse = await fetch(`${GOOGLE_FORMS_API}/${formId}:batchUpdate`, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${googleAccessToken}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ requests: updateRequests })
                    });

                    if (!updateResponse.ok) {
                        const error = await updateResponse.json();
                        console.warn('Failed to set required status:', error.error?.message);
                        // Non-critical error, continue anyway
                    }
                }

                // Correct answers are already set in the createItem requests above

                // Get form URL
                const formUrl = `https://docs.google.com/forms/d/${formId}/edit`;
                const publishedUrl = `https://docs.google.com/forms/d/${formId}/viewform`;

                // Build success message with account info
                let accountInfo = '';
                if (authenticatedEmail) {
                    accountInfo = `<div class="mt-2 p-2 bg-light rounded"><small><i class="fas fa-user me-1"></i><strong>Form created with account:</strong> ${authenticatedEmail}</small></div>`;
                }
                
                statusEl.innerHTML = `
                    <div class="alert alert-success">
                        <i class="fas fa-check-circle me-2"></i>Google Form created successfully!
                        ${accountInfo}
                        <div class="mt-3">
                            <a href="${formUrl}" target="_blank" class="btn btn-sm btn-primary me-2" onclick="window.open('${formUrl}', '_blank'); return false;">
                                <i class="fas fa-edit me-1"></i>Edit Form
                            </a>
                            <a href="${publishedUrl}" target="_blank" class="btn btn-sm btn-success">
                                <i class="fas fa-external-link-alt me-1"></i>View Published Form
                            </a>
                        </div>
                        ${authenticatedEmail ? `
                        <div class="alert alert-info mt-3 mb-0">
                            <small><i class="fas fa-info-circle me-1"></i><strong>Important:</strong> Make sure you're logged into Google with the account <strong>${authenticatedEmail}</strong> when editing the form. 
                            If the form opens with a different account, sign out of Google and sign back in with the correct account, then click "Edit Form" again.</small>
                        </div>
                        ` : ''}
                    </div>
                `;

            } catch (error) {
                console.error('Form creation error:', error);
                
                // Check if it's an API not enabled error
                if (error.message.startsWith('API_NOT_ENABLED:')) {
                    const enableUrl = error.message.replace('API_NOT_ENABLED:', '');
                    statusEl.innerHTML = `
                        <div class="alert alert-warning">
                            <h5><i class="fas fa-exclamation-triangle me-2"></i>Google Forms API Needs to be Enabled</h5>
                            <p class="mb-2"><strong>Don't worry - this is easy to fix!</strong> You don't need to be a developer. Just follow these simple steps:</p>
                            <ol class="mb-3">
                                <li>Click the button below to open Google Cloud Console</li>
                                <li>Click the <strong>"Enable"</strong> button (big blue button at the top)</li>
                                <li>Wait 1-2 minutes for it to activate</li>
                                <li>Come back here and try creating the form again</li>
                            </ol>
                            <a href="${enableUrl}" target="_blank" class="btn btn-primary">
                                <i class="fas fa-external-link-alt me-2"></i>Enable Google Forms API
                            </a>
                            <p class="mt-3 mb-0"><small><strong>Note:</strong> You need to be signed in to the Google account that owns this project. If you don't have access, ask the project owner to enable it for you.</small></p>
                        </div>
                    `;
                } else {
                    statusEl.innerHTML = `
                        <div class="alert alert-danger">
                            <h5><i class="fas fa-times-circle me-2"></i>Error creating form</h5>
                            <p>${error.message}</p>
                            <small>If this is an API error, you may need to enable the Google Forms API in Google Cloud Console.</small>
                        </div>
                    `;
                }
            }
        }

        // Set correct answers for quiz questions
        async function setCorrectAnswers(formId, questionsData) {
            try {
                // Get form structure first
                const formResponse = await fetch(`${GOOGLE_FORMS_API}/${formId}`, {
                    headers: {
                        'Authorization': `Bearer ${googleAccessToken}`
                    }
                });

                const form = await formResponse.json();
                const items = form.items || [];
                
                let questionIndex = 0;
                const answerRequests = [];

                questionsData.forEach((levelGroup) => {
                    // Skip page break items
                    if (items[questionIndex]?.pageBreakItem) {
                        questionIndex++;
                    }

                    levelGroup.questions.forEach((q) => {
                        const item = items[questionIndex];
                        if (item && item.questionItem) {
                            const choices = item.questionItem.question.choiceQuestion.options;
                            const correctIndex = choices.findIndex(opt => 
                                opt.value.charAt(0) === q.correct || 
                                opt.value === q.options[q.correct]
                            );

                            if (correctIndex >= 0) {
                                answerRequests.push({
                                    updateItem: {
                                        item: {
                                            itemId: item.itemId,
                                            questionItem: {
                                                question: {
                                                    choiceQuestion: {
                                                        type: 'RADIO',
                                                        options: choices,
                                                        shuffle: false
                                                    },
                                                    grading: {
                                                        pointValue: 1,
                                                        correctAnswers: {
                                                            answers: [{
                                                                value: choices[correctIndex].value
                                                            }]
                                                        }
                                                    }
                                                }
                                            }
                                        },
                                        updateMask: 'questionItem.question.choiceQuestion,questionItem.question.grading',
                                        location: { index: questionIndex }
                                    }
                                });
                            }
                        }
                        questionIndex++;
                    });
                });

                // Batch update with correct answers
                if (answerRequests.length > 0) {
                    await fetch(`${GOOGLE_FORMS_API}/${formId}:batchUpdate`, {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${googleAccessToken}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ requests: answerRequests })
                    });
                }
            } catch (error) {
                console.error('Error setting correct answers:', error);
                // Non-critical error, form will still be created
            }
        }

        // Main function to create Google Form
        async function createGoogleForm() {
            if (questions.length === 0) {
                alert('Please generate questions first');
                return;
            }

            // Show info about API setup
            document.getElementById('googleFormsInfo').style.display = 'block';

            // Check if Google API is loaded
            if (typeof google === 'undefined' || !google.accounts) {
                alert('Google API libraries are loading. Please wait a moment and try again.');
                return;
            }

            // Check if already authenticated
            if (!googleAccessToken) {
                await authenticateAndCreateForm();
            } else {
                await createFormWithAPI();
            }
        }

        // Get selected questions
        function getSelectedQuestions() {
            const selected = [];
            const checkboxes = document.querySelectorAll('.question-checkbox:checked');
            
            checkboxes.forEach(checkbox => {
                const card = checkbox.closest('.question-card');
                const level = parseInt(card.dataset.level);
                const questionIndex = parseInt(card.dataset.questionIndex);
                
                // Find the question in our questions array
                const levelGroup = questions.find(q => q.level === level);
                if (levelGroup && levelGroup.questions[questionIndex]) {
                    selected.push({
                        levelGroup: levelGroup,
                        question: levelGroup.questions[questionIndex],
                        level: level
                    });
                }
            });
            
            return selected;
        }

        // Update selection count
        function updateSelectionCount() {
            const selected = document.querySelectorAll('.question-checkbox:checked').length;
            const total = document.querySelectorAll('.question-checkbox').length;
            document.getElementById('selectedCount').textContent = `${selected} of ${total} selected`;
            document.getElementById('selectedForForm').textContent = selected;
        }

        // Select all questions
        function selectAllQuestions() {
            document.querySelectorAll('.question-checkbox').forEach(cb => {
                cb.checked = true;
                cb.closest('.question-card').classList.add('selected');
            });
            updateSelectionCount();
        }

        // Deselect all questions
        function deselectAllQuestions() {
            document.querySelectorAll('.question-checkbox').forEach(cb => {
                cb.checked = false;
                cb.closest('.question-card').classList.remove('selected');
            });
            updateSelectionCount();
        }

        // Edit a question
        function editQuestion(level, questionIndex) {
            const levelGroup = questions.find(q => q.level === level);
            if (!levelGroup || !levelGroup.questions[questionIndex]) {
                alert('Question not found');
                return;
            }

            const question = levelGroup.questions[questionIndex];
            const contentDiv = document.getElementById(`question-content-${level}-${questionIndex}`);
            
            // Create editable form
            const editHtml = `
                <div class="edit-question-form">
                    <div class="mb-3">
                        <label class="form-label"><strong>Question:</strong></label>
                        <textarea class="form-control edit-question-text" rows="3">${question.question}</textarea>
                    </div>
                    <div class="mb-3">
                        <label class="form-label"><strong>Options:</strong></label>
                        <div class="input-group mb-2">
                            <span class="input-group-text">A.</span>
                            <input type="text" class="form-control edit-option-A" value="${question.options.A || ''}">
                        </div>
                        <div class="input-group mb-2">
                            <span class="input-group-text">B.</span>
                            <input type="text" class="form-control edit-option-B" value="${question.options.B || ''}">
                        </div>
                        <div class="input-group mb-2">
                            <span class="input-group-text">C.</span>
                            <input type="text" class="form-control edit-option-C" value="${question.options.C || ''}">
                        </div>
                    </div>
                    <div class="mb-3">
                        <label class="form-label"><strong>Correct Answer:</strong></label>
                        <select class="form-select edit-correct-answer">
                            <option value="A" ${question.correct === 'A' ? 'selected' : ''}>A</option>
                            <option value="B" ${question.correct === 'B' ? 'selected' : ''}>B</option>
                            <option value="C" ${question.correct === 'C' ? 'selected' : ''}>C</option>
                        </select>
                    </div>
                    <div class="d-flex gap-2">
                        <button class="btn btn-sm btn-success" onclick="saveQuestion(${level}, ${questionIndex})">
                            <i class="fas fa-save me-1"></i>Save
                        </button>
                        <button class="btn btn-sm btn-secondary" onclick="cancelEdit(${level}, ${questionIndex})">
                            <i class="fas fa-times me-1"></i>Cancel
                        </button>
                    </div>
                </div>
            `;
            
            contentDiv.innerHTML = editHtml;
        }

        // Save edited question
        function saveQuestion(level, questionIndex) {
            const levelGroup = questions.find(q => q.level === level);
            if (!levelGroup || !levelGroup.questions[questionIndex]) {
                alert('Question not found');
                return;
            }

            const contentDiv = document.getElementById(`question-content-${level}-${questionIndex}`);
            const questionText = contentDiv.querySelector('.edit-question-text').value.trim();
            const optionA = contentDiv.querySelector('.edit-option-A').value.trim();
            const optionB = contentDiv.querySelector('.edit-option-B').value.trim();
            const optionC = contentDiv.querySelector('.edit-option-C').value.trim();
            const correctAnswer = contentDiv.querySelector('.edit-correct-answer').value;

            // Validate
            if (!questionText) {
                alert('Question text cannot be empty');
                return;
            }
            if (!optionA || !optionB || !optionC) {
                alert('All three options must be filled');
                return;
            }

            // Update question in array
            levelGroup.questions[questionIndex] = {
                question: questionText,
                options: {
                    A: optionA,
                    B: optionB,
                    C: optionC
                },
                correct: correctAnswer
            };

            // Re-display the question
            displayQuestions();
            
            // Show success message
            const alertDiv = document.createElement('div');
            alertDiv.className = 'alert alert-success alert-dismissible fade show';
            alertDiv.innerHTML = `
                <i class="fas fa-check-circle me-2"></i>Question saved successfully!
                <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
            `;
            document.getElementById('questionsContainer').insertBefore(alertDiv, document.getElementById('questionsContainer').firstChild);
            
            // Auto-dismiss after 3 seconds
            setTimeout(() => {
                alertDiv.remove();
            }, 3000);
        }

        // Cancel editing
        function cancelEdit(level, questionIndex) {
            // Just re-display questions to restore original view
            displayQuestions();
        }

        // Extract questions from text when JSON parsing fails
        function extractQuestionsFromText(text) {
            const extracted = [];
            const lines = text.split('\n');
            let currentQuestion = null;
            let optionCount = 0;

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;

                // Look for question patterns
                if (line.match(/^\d+[\.\)]\s*[A-Z]/) || line.match(/^[Qq]uestion\s*\d+[\.:]/) || 
                    (line.length > 20 && !line.match(/^[A-C][\.\)]/))) {
                    if (currentQuestion && currentQuestion.question && optionCount >= 2) {
                        extracted.push(currentQuestion);
                    }
                    currentQuestion = {
                        question: line.replace(/^\d+[\.\)]\s*/, '').replace(/^[Qq]uestion\s*\d+[\.:]\s*/, ''),
                        options: {},
                        correct: 'A'
                    };
                    optionCount = 0;
                }
                // Look for option patterns
                else if (line.match(/^[A-C][\.\)]\s*/) && currentQuestion) {
                    const option = line.charAt(0);
                    const optionText = line.substring(line.indexOf(')') + 1).trim();
                    if (optionText) {
                        currentQuestion.options[option] = optionText;
                        optionCount++;
                    }
                }
                // Look for correct answer
                else if (line.match(/[Cc]orrect\s*[Aa]nswer/i) && currentQuestion) {
                    const match = line.match(/[A-C]/);
                    if (match) {
                        currentQuestion.correct = match[0];
                    }
                }
            }

            // Add last question
            if (currentQuestion && currentQuestion.question && optionCount >= 2) {
                extracted.push(currentQuestion);
            }

            return extracted;
        }

        // Initialize Google Sign-In on page load
        window.addEventListener('load', () => {
            if (typeof google !== 'undefined' && google.accounts) {
                initializeGoogleSignIn();
            }
            updateSelectionCount();
        });
    </script>
</body>
</html>

