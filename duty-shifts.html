<!DOCTYPE html>
<html lang="el">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="format-detection" content="telephone=no">
    <title>Διαχείριση Υπηρεσιών v1.17 - Tool Tracking</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <link rel="stylesheet" href="css/common.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/exceljs/4.4.0/exceljs.min.js"></script>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            background: #f5f5f5;
            width: 100%;
            height: 100%;
            overflow-x: hidden;
        }

        .full-width-title-bar {
            width: 100vw !important;
            margin-left: calc(50% - 50vw) !important;
            margin-right: calc(50% - 50vw) !important;
            margin-top: 0 !important;
            position: sticky;
            top: 0;
            z-index: 1000;
        }

        .container-fluid {
            padding: 1rem;
            width: 100%;
            max-width: 100%;
            margin: 0;
            box-sizing: border-box;
        }

        .group-card {
            background: white;
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        .group-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 0.75rem;
            border-bottom: 2px solid #e0e0e0;
        }

        .group-title {
            font-size: 1.5rem;
            font-weight: bold;
            color: #333;
        }

        .list-header {
            cursor: pointer;
            user-select: none;
            transition: background-color 0.2s;
            padding: 0.5rem;
            border-radius: 4px;
        }
        
        .list-header:hover {
            background-color: #f8f9fa;
        }
        
        .list-header i.fa-chevron-down,
        .list-header i.fa-chevron-up {
            transition: transform 0.3s;
        }
        
        .person-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem;
            margin: 0.5rem 0;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
            cursor: move;
            transition: background-color 0.2s;
        }

        .person-item:hover {
            background: #e9ecef;
        }

        .person-item.dragging {
            opacity: 0.5;
        }

        .person-item.drag-over {
            border-top: 3px dashed #007bff !important;
            background-color: #e7f3ff !important;
            margin-top: 0.5rem;
            padding-top: 0.5rem;
        }

        .drop-indicator {
            height: 3px;
            background-color: #007bff;
            margin: 0.25rem 0;
            border-radius: 2px;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .drop-indicator.show {
            opacity: 1;
        }

        /* 3D Interactive Priority Number */
        .priority-badge-3d {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 28px;
            height: 28px;
            font-size: 0.85rem;
            font-weight: bold;
            color: white;
            background: #4a4a4a;
            border-radius: 4px;
            box-shadow: 
                0 4px 8px rgba(0, 0, 0, 0.3),
                0 2px 4px rgba(0, 0, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.1),
                inset 0 -1px 0 rgba(0, 0, 0, 0.3);
            transform: perspective(500px) rotateX(5deg) translateZ(0);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: pointer;
            position: relative;
            margin-right: 0.5rem;
            user-select: none;
        }

        .priority-badge-3d::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: 4px;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, transparent 50%);
            pointer-events: none;
        }

        .priority-badge-3d:hover {
            transform: perspective(500px) rotateX(0deg) translateZ(8px) scale(1.1);
            box-shadow: 
                0 6px 12px rgba(0, 0, 0, 0.4),
                0 3px 6px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.15),
                inset 0 -1px 0 rgba(0, 0, 0, 0.3);
            background: #5a5a5a;
        }

        .priority-badge-3d:active {
            transform: perspective(500px) rotateX(-5deg) translateZ(4px) scale(0.95);
            box-shadow: 
                0 2px 4px rgba(0, 0, 0, 0.3),
                0 1px 2px rgba(0, 0, 0, 0.2),
                inset 0 2px 4px rgba(0, 0, 0, 0.4);
        }

        /* All priority badges use the same dark grey style */
        .priority-badge-3d.priority-high,
        .priority-badge-3d.priority-medium,
        .priority-badge-3d.priority-low {
            background: #4a4a4a;
            box-shadow: 
                0 4px 8px rgba(0, 0, 0, 0.3),
                0 2px 4px rgba(0, 0, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.1),
                inset 0 -1px 0 rgba(0, 0, 0, 0.3);
        }

        .priority-badge-3d.priority-high:hover,
        .priority-badge-3d.priority-medium:hover,
        .priority-badge-3d.priority-low:hover {
            background: #5a5a5a;
            box-shadow: 
                0 6px 12px rgba(0, 0, 0, 0.4),
                0 3px 6px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.15),
                inset 0 -1px 0 rgba(0, 0, 0, 0.3);
        }

        .person-name {
            flex: 1;
            font-size: 1rem;
        }

        .person-name-card {
            flex: 1;
            padding: 0.5rem;
            cursor: pointer;
            border-radius: 4px;
            transition: background-color 0.2s;
            margin-right: 0.5rem;
        }

        .person-name-card:hover {
            background-color: #e9ecef;
        }

        .person-actions {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .transfer-dropdown {
            position: relative;
            display: inline-block;
        }

        .transfer-dropdown-content {
            display: none;
            position: absolute;
            right: 0;
            background-color: white;
            min-width: 150px;
            box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
            z-index: 1000;
            border-radius: 8px;
            padding: 0.5rem 0;
            margin-top: 0.25rem;
        }

        .transfer-dropdown-content.show {
            display: block;
        }

        .transfer-dropdown-content button {
            width: 100%;
            text-align: left;
            padding: 0.5rem 1rem;
            border: none;
            background: none;
            cursor: pointer;
            font-size: 0.9rem;
        }

        .transfer-dropdown-content button:hover {
            background-color: #f1f1f1;
        }

        .btn-add-person {
            width: 100%;
            margin-top: 0.5rem;
        }

        .calendar-section {
            background: white;
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            width: 100%;
            box-sizing: border-box;
        }

        .calendar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .calendar-nav {
            display: flex;
            gap: 1rem;
            align-items: center;
        }

        .calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 0.5rem;
            width: 100%;
            box-sizing: border-box;
        }

        .calendar-day-header {
            text-align: center;
            font-weight: bold;
            padding: 0.5rem;
            color: #666;
            font-size: 0.9rem;
        }

        .calendar-day {
            aspect-ratio: 1;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            padding: 0.5rem;
            cursor: pointer;
            transition: all 0.2s;
            background: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .calendar-day:hover {
            border-color: #FF9800;
            transform: scale(1.05);
        }

        .calendar-day.today {
            border-color: #FF9800;
            background: #FFF3E0;
            font-weight: bold;
        }

        .calendar-day.normal-day {
            background: #E8F5E9;
        }

        .calendar-day.semi-normal-day {
            background: #FFF9C4;
        }

        .calendar-day.weekend-holiday {
            background: #FFE0B2;
        }

        .calendar-day.special-holiday {
            background: #E1BEE7 !important;
            border-color: #9C27B0 !important;
            font-weight: bold;
        }
        
        /* Ensure special holidays always have purple color, even if they have other day type classes */
        .calendar-day.special-holiday.weekend-holiday,
        .calendar-day.special-holiday.normal-day,
        .calendar-day.special-holiday.semi-normal-day {
            background: #E1BEE7 !important;
            border-color: #9C27B0 !important;
        }
        
        /* Force purple background for special holidays via data attribute */
        .calendar-day[data-special-holiday="true"] {
            background: #E1BEE7 !important;
            border-color: #9C27B0 !important;
        }

        /* Removed .holiday class - regular holidays now use weekend-holiday styling */

        .day-number {
            font-size: 1rem;
            font-weight: bold;
        }

        .day-type {
            font-size: 0.7rem;
            margin-top: 0.25rem;
            text-align: center;
        }

        .orthodox-holiday-name {
            font-size: 0.7rem;
            margin-top: 0.2rem;
            color: #7B1FA2;
            font-weight: bold;
            text-align: center;
            word-break: break-word;
            line-height: 1.1;
        }

        .duty-person-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            margin-top: 0.25rem;
            pointer-events: none; /* Allow clicks to pass through to parent */
        }

        .duty-person {
            font-size: 0.75rem;
            margin-top: 0.25rem;
            color: #FF9800;
            font-weight: bold;
            text-align: center;
            word-break: break-word;
            pointer-events: none; /* Allow clicks to pass through */
        }

        .duty-person-critical {
            font-size: 0.75rem;
            margin-top: 0.25rem;
            color: #DC3545;
            font-weight: bold;
            text-align: center;
            word-break: break-word;
            pointer-events: none; /* Allow clicks to pass through */
        }

        .holiday-list {
            background: white;
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            width: 100%;
            box-sizing: border-box;
        }

        .holiday-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem;
            margin: 0.5rem 0;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .stats-card {
            background: linear-gradient(135deg, #FF9800 0%, #F57C00 100%);
            color: white;
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            box-shadow: 0 4px 12px rgba(255, 152, 0, 0.3);
            width: 100%;
            box-sizing: border-box;
        }

        .stats-grid {
            display: flex;
            gap: 2rem;
            flex-wrap: wrap;
            margin-top: 1rem;
        }

        .stat-item {
            text-align: center;
            flex: 1;
            min-width: 200px;
        }

        .stat-value {
            font-size: 2rem;
            font-weight: bold;
        }

        .stat-label {
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .modal-day-details {
            max-height: 60vh;
            overflow-y: auto;
        }

        .duty-assignment {
            padding: 0.75rem;
            margin: 0.5rem 0;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #FF9800;
        }

        .group-badge {
            display: inline-block;
            padding: 0.25rem 0.75rem;
            border-radius: 12px;
            font-size: 0.85rem;
            font-weight: bold;
            margin-right: 0.5rem;
        }

        .group-1 { background: #E3F2FD; color: #1976D2; }
        .group-2 { background: #F3E5F5; color: #7B1FA2; }
        .group-3 { background: #E8F5E9; color: #388E3C; }
        .group-4 { background: #FFF3E0; color: #F57C00; }

        /* Responsive Design */
        @media (min-width: 1200px) {
            .container-fluid {
                padding: 1.5rem 2rem;
            }
            
            .group-card {
                min-height: 400px;
            }
        }
        
        @media (max-width: 1199px) and (min-width: 992px) {
            .container-fluid {
                padding: 1.25rem 1.5rem;
            }
        }
        
        @media (max-width: 991px) and (min-width: 768px) {
            .container-fluid {
                padding: 1rem;
            }
            
            .group-card {
                min-height: 350px;
            }
        }
        
        @media (max-width: 767px) {
            .container-fluid {
                padding: 0.75rem;
            }
            
            .calendar-grid {
                gap: 0.25rem;
            }
            
            .calendar-day {
                padding: 0.25rem;
                font-size: 0.85rem;
            }
            
            .day-number {
                font-size: 0.9rem;
            }
            
            .day-type, .duty-person, .duty-person-critical, .orthodox-holiday-name {
                font-size: 0.65rem;
            }
            
            .group-card {
                margin-bottom: 1rem;
            }
            
            .stats-card {
                padding: 1rem;
            }
            
            .stats-grid {
                flex-direction: column;
                gap: 1rem;
            }
            
            .group-title {
                font-size: 1.2rem;
            }
        }
        
        @media (max-width: 576px) {
            .container-fluid {
                padding: 0.5rem;
            }
            
            .group-card {
                padding: 1rem;
            }
            
            .calendar-section {
                padding: 1rem;
            }
        }
        
        /* Ensure full width for all sections */
        .row {
            margin-left: 0;
            margin-right: 0;
            width: 100%;
            max-width: 100%;
        }
        
        .row > [class*="col-"] {
            padding-left: 0.75rem;
            padding-right: 0.75rem;
        }
        
        /* Override Bootstrap container max-width */
        .container-fluid {
            max-width: 100% !important;
        }
        
        /* Ensure body and html take full viewport */
        html {
            width: 100%;
            height: 100%;
            overflow-x: hidden;
        }
        
        body {
            width: 100%;
            min-height: 100vh;
            overflow-x: hidden;
        }
        
    </style>
</head>
<body>
    <!-- Title Bar -->
    <div class="full-width-title-bar">
        <div class="d-flex justify-content-between align-items-center p-3" style="background: linear-gradient(135deg, #FF9800 0%, #F57C00 100%); color: white;">
            <div class="d-flex align-items-center">
                <a href="main-menu.html" class="text-white me-3" style="text-decoration: none;">
                    <i class="fas fa-arrow-left fa-lg"></i>
                </a>
                <h4 class="mb-0">Διαχείριση Υπηρεσιών <span style="font-size: 0.7em; opacity: 0.8;">v1.17</span></h4>
            </div>
        </div>
    </div>

    <div class="container-fluid">
        <!-- Statistics Card -->
        <div class="stats-card">
            <h5 class="mb-0"><i class="fas fa-chart-bar me-2"></i>Στατιστικά Εναλλαγής</h5>
            <div class="stats-grid">
                <div class="stat-item">
                    <div class="stat-value" id="totalPeople">0</div>
                    <div class="stat-label">Συνολικό Προσωπικό</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="avgRotation">0</div>
                    <div class="stat-label">Μέσες Ημέρες Εναλλαγής</div>
                </div>
            </div>
        </div>

        <!-- Groups Section -->
        <div class="row">
            <div class="col-12 col-md-6 col-lg-3 mb-3" id="group1Container">
                <div class="group-card">
                    <div class="group-header">
                        <div class="group-title">
                            <span class="group-badge group-1">ΕΠΙΚΕΦΑΛΗΣ-ΑΥΜ</span>
                        </div>
                        <button class="btn btn-sm btn-outline-primary" onclick="addPerson(1)">
                            <i class="fas fa-plus"></i>
                        </button>
                    </div>
                    <div id="group1People"></div>
                    <div class="mt-2">
                        <small class="text-muted">Εναλλαγή: <span id="group1Rotation">-</span> ημέρες</small>
                    </div>
                </div>
            </div>

            <div class="col-12 col-md-6 col-lg-3 mb-3" id="group2Container">
                <div class="group-card">
                    <div class="group-header">
                        <div class="group-title">
                            <span class="group-badge group-2">ΜΗΧΑΝΙΚΟΣ-ΟΠΛΟΥΡΓΟΣ-ΟΔΗΓΟΣ</span>
                        </div>
                        <button class="btn btn-sm btn-outline-primary" onclick="addPerson(2)">
                            <i class="fas fa-plus"></i>
                        </button>
                    </div>
                    <div id="group2People"></div>
                    <div class="mt-2">
                        <small class="text-muted">Εναλλαγή: <span id="group2Rotation">-</span> ημέρες</small>
                    </div>
                </div>
            </div>

            <div class="col-12 col-md-6 col-lg-3 mb-3" id="group3Container">
                <div class="group-card">
                    <div class="group-header">
                        <div class="group-title">
                            <span class="group-badge group-3">ΤΕΧΝΙΚΟΣ Ε/Π AW139</span>
                        </div>
                        <button class="btn btn-sm btn-outline-primary" onclick="addPerson(3)">
                            <i class="fas fa-plus"></i>
                        </button>
                    </div>
                    <div id="group3People"></div>
                    <div class="mt-2">
                        <small class="text-muted">Εναλλαγή: <span id="group3Rotation">-</span> ημέρες</small>
                    </div>
                </div>
            </div>

            <div class="col-12 col-md-6 col-lg-3 mb-3" id="group4Container">
                <div class="group-card">
                    <div class="group-header">
                        <div class="group-title">
                            <span class="group-badge group-4">ΤΕΧΝΙΚΟΣ ΕΠΙΓΕΙΩΝ ΜΕΣΩΝ</span>
                        </div>
                        <button class="btn btn-sm btn-outline-primary" onclick="addPerson(4)">
                            <i class="fas fa-plus"></i>
                        </button>
                    </div>
                    <div id="group4People"></div>
                    <div class="mt-2">
                        <small class="text-muted">Εναλλαγή: <span id="group4Rotation">-</span> ημέρες</small>
                    </div>
                </div>
            </div>
        </div>

        <!-- Special Holidays Configuration -->
        <div class="holiday-list">
            <div class="list-header d-flex justify-content-between align-items-center mb-2" onclick="toggleListCollapse('specialHolidaysContent', 'specialHolidaysChevron')">
                <h5 class="mb-0"><i class="fas fa-star me-2"></i>Ειδικές Αργίες</h5>
                <i id="specialHolidaysChevron" class="fas fa-chevron-down"></i>
            </div>
            <div id="specialHolidaysContent" class="collapse">
                <div class="d-flex justify-content-end mb-3">
                    <button class="btn btn-warning btn-sm" onclick="event.stopPropagation(); addRecurringHoliday()">
                        <i class="fas fa-plus me-1"></i>Προσθήκη Ειδικής Αργίας
                    </button>
                </div>
                <div class="alert alert-info">
                    <i class="fas fa-info-circle me-2"></i>
                    <small>Ορίστε αργίες που επαναλαμβάνονται κάθε χρόνο (π.χ., 25 Δεκεμβρίου, 1 Ιανουαρίου) ή σχετίζονται με το Πάσχα (π.χ., Μεγάλο Σάββατο). Οι ειδικές αργίες έχουν την υψηλότερη προτεραιότητα και χρησιμοποιούν τη σειρά ειδικών αργιών κάθε ομάδας.</small>
                </div>
                <div id="recurringHolidaysList"></div>
            </div>
        </div>

        <!-- Regular Holidays Section -->
        <div class="holiday-list">
            <div class="list-header d-flex justify-content-between align-items-center mb-2" onclick="toggleListCollapse('regularHolidaysContent', 'regularHolidaysChevron')">
                <h5 class="mb-0"><i class="fas fa-calendar-times me-2"></i>Κανονικές Αργίες</h5>
                <i id="regularHolidaysChevron" class="fas fa-chevron-down"></i>
            </div>
            <div id="regularHolidaysContent" class="collapse">
                <div class="d-flex justify-content-end mb-3">
                    <button class="btn btn-primary btn-sm" onclick="event.stopPropagation(); addHoliday()">
                        <i class="fas fa-plus me-1"></i>Προσθήκη Αργίας
                    </button>
                </div>
                <div id="holidaysList"></div>
            </div>
        </div>

        <!-- Calendar Section -->
        <div class="calendar-section">
            <div class="calendar-header">
                <h5><i class="fas fa-calendar-alt me-2"></i>Ημερολόγιο Υπηρεσιών</h5>
                <div class="calendar-nav">
                    <button class="btn btn-sm btn-outline-secondary" onclick="previousMonth()">
                        <i class="fas fa-chevron-left"></i>
                    </button>
                    <h5 class="mb-0 mx-3" id="currentMonthYear"></h5>
                    <button class="btn btn-sm btn-outline-secondary" onclick="nextMonth()">
                        <i class="fas fa-chevron-right"></i>
                    </button>
                    <button class="btn btn-sm btn-success ms-2" onclick="openAssignDutyModalForDate()">
                        <i class="fas fa-user-plus me-1"></i>Χειροκίνητη Ανάθεση
                    </button>
                    <button class="btn btn-sm btn-primary ms-2" onclick="openCalculateDutiesModal()">
                        <i class="fas fa-calculator me-1"></i>Υπολογισμός Υπηρεσιών
                    </button>
                    <button class="btn btn-sm btn-success ms-2" onclick="showExcelPreview()">
                        <i class="fas fa-file-excel me-1"></i>Δημιουργία Excel
                    </button>
                    <button class="btn btn-sm btn-warning ms-2" onclick="migrateAssignmentsByDayType()">
                        <i class="fas fa-exchange-alt me-1"></i>Μεταφορά Ανά Τύπο Ημέρας
                    </button>
                    <button class="btn btn-sm btn-warning ms-2" onclick="analyzeRotationViolations()">
                        <i class="fas fa-exclamation-triangle me-1"></i>Έλεγχος Αναθέσεων Υπηρεσιών
                    </button>
                </div>
            </div>
            <div class="calendar-grid" id="calendarGrid"></div>
        </div>
    </div>

    <!-- Add Person Modal -->
    <div class="modal fade" id="addPersonModal" tabindex="-1">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title"><span id="modalTitle">Προσθήκη Ατόμου στην Ομάδα <span id="modalGroupNumber"></span></span></h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <div class="mb-3">
                        <label for="personName" class="form-label">Όνομα</label>
                        <input type="text" class="form-control" id="personName" placeholder="Εισάγετε το όνομά του ατόμου">
                    </div>
                    <div class="alert alert-info">
                        <small><i class="fas fa-info-circle me-1"></i>Εισάγετε την τελευταία ημερομηνία υπηρεσίας για κάθε τύπο ημέρας (προαιρετικό)</small>
                    </div>
                    <div class="row">
                        <div class="col-md-6 mb-3">
                            <label for="lastSpecialDuty" class="form-label">Τελευταία Ειδική Αργία</label>
                            <input type="date" class="form-control" id="lastSpecialDuty">
                        </div>
                        <div class="col-md-6 mb-3">
                            <label for="lastWeekendDuty" class="form-label">Τελευταία Σαββατοκύριακο/Αργία</label>
                            <input type="date" class="form-control" id="lastWeekendDuty">
                        </div>
                        <div class="col-md-6 mb-3">
                            <label for="lastSemiDuty" class="form-label">Τελευταία Ημιαργία</label>
                            <input type="date" class="form-control" id="lastSemiDuty">
                        </div>
                        <div class="col-md-6 mb-3">
                            <label for="lastNormalDuty" class="form-label">Τελευταία Καθημερινή</label>
                            <input type="date" class="form-control" id="lastNormalDuty">
                        </div>
                    </div>
                    <div class="alert alert-warning mt-3">
                        <small><i class="fas fa-sort-numeric-up me-1"></i>Προτεραιότητα Σειράς Εναλλαγής (μικρότερος αριθμός = πρώτος στη σειρά)</small>
                    </div>
                    <div class="row">
                        <div class="col-md-6 mb-3">
                            <label for="prioritySpecial" class="form-label">Προτεραιότητα Ειδικών Αργιών</label>
                            <input type="number" class="form-control" id="prioritySpecial" min="1" placeholder="1">
                        </div>
                        <div class="col-md-6 mb-3">
                            <label for="priorityWeekend" class="form-label">Προτεραιότητα Σαββατοκύριακων/Αργιών</label>
                            <input type="number" class="form-control" id="priorityWeekend" min="1" placeholder="1">
                        </div>
                        <div class="col-md-6 mb-3">
                            <label for="prioritySemi" class="form-label">Προτεραιότητα Ημιαργιών</label>
                            <input type="number" class="form-control" id="prioritySemi" min="1" placeholder="1">
                        </div>
                        <div class="col-md-6 mb-3">
                            <label for="priorityNormal" class="form-label">Προτεραιότητα Καθημερινών</label>
                            <input type="number" class="form-control" id="priorityNormal" min="1" placeholder="1">
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Ακύρωση</button>
                    <button type="button" class="btn btn-primary" onclick="savePerson()" id="savePersonButton">Προσθήκη Ατόμου</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Add Special Holiday Modal -->
    <div class="modal fade" id="addSpecialHolidayModal" tabindex="-1">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header bg-warning">
                    <h5 class="modal-title"><i class="fas fa-star me-2"></i>Προσθήκη Ειδικής Αργίας</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <div class="alert alert-info">
                        <i class="fas fa-info-circle me-2"></i>
                        <small>Οι ειδικές αργίες έχουν την υψηλότερη προτεραιότητα και χρησιμοποιούν τη σειρά ειδικών αργιών κάθε ομάδας.</small>
                    </div>
                    <div class="mb-3">
                        <label for="specialHolidayDate" class="form-label">Ημερομηνία</label>
                        <input type="date" class="form-control" id="specialHolidayDate" required>
                    </div>
                    <div class="mb-3">
                        <label for="specialHolidayName" class="form-label">Όνομα Ειδικής Αργίας (Προαιρετικό)</label>
                        <input type="text" class="form-control" id="specialHolidayName" placeholder="π.χ., Χριστούγεννα, Πάσχα, Πρωτοχρονιά">
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Ακύρωση</button>
                    <button type="button" class="btn btn-warning" onclick="saveSpecialHoliday()">Προσθήκη Ειδικής Αργίας</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Add Recurring Holiday Modal -->
    <div class="modal fade" id="addRecurringHolidayModal" tabindex="-1">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header bg-info">
                    <h5 class="modal-title"><i class="fas fa-repeat me-2"></i>Προσθήκη Επαναλαμβανόμενης Αργίας</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <div class="mb-3">
                        <label for="recurringHolidayType" class="form-label">Τύπος</label>
                        <select class="form-control" id="recurringHolidayType" onchange="toggleRecurringHolidayFields()">
                            <option value="fixed">Σταθερή Ημερομηνία (π.χ., 25 Δεκεμβρίου)</option>
                            <option value="easter-relative">Σχετική με Πάσχα (π.χ., Μεγάλο Σάββατο)</option>
                        </select>
                    </div>
                    <div class="mb-3" id="fixedDateFields">
                        <label for="recurringHolidayMonth" class="form-label">Μήνας</label>
                        <select class="form-control" id="recurringHolidayMonth">
                            <option value="">Επιλέξτε...</option>
                            <option value="1">Ιανουάριος</option>
                            <option value="2">Φεβρουάριος</option>
                            <option value="3">Μάρτιος</option>
                            <option value="4">Απρίλιος</option>
                            <option value="5">Μάιος</option>
                            <option value="6">Ιούνιος</option>
                            <option value="7">Ιούλιος</option>
                            <option value="8">Αύγουστος</option>
                            <option value="9">Σεπτέμβριος</option>
                            <option value="10">Οκτώβριος</option>
                            <option value="11">Νοέμβριος</option>
                            <option value="12">Δεκέμβριος</option>
                        </select>
                    </div>
                    <div class="mb-3" id="fixedDayFields">
                        <label for="recurringHolidayDay" class="form-label">Ημέρα</label>
                        <input type="number" class="form-control" id="recurringHolidayDay" min="1" max="31">
                    </div>
                    <div class="mb-3" id="easterOffsetFields" style="display: none;">
                        <label for="recurringHolidayEasterOffset" class="form-label">Ημέρες από το Πάσχα</label>
                        <input type="number" class="form-control" id="recurringHolidayEasterOffset" value="0">
                        <small class="text-muted">0 = Πάσχα, -1 = 1 ημέρα πριν, 1 = 1 ημέρα μετά, κτλ.</small>
                    </div>
                    <div class="mb-3">
                        <label for="recurringHolidayName" class="form-label">Όνομα Αργίας</label>
                        <input type="text" class="form-control" id="recurringHolidayName" placeholder="π.χ., Χριστούγεννα, Μεγάλο Σάββατο">
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Ακύρωση</button>
                    <button type="button" class="btn btn-info" onclick="saveRecurringHoliday()">Αποθήκευση</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Calculate Duties Modal -->
    <div class="modal fade" id="calculateDutiesModal" tabindex="-1">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header bg-primary">
                    <h5 class="modal-title"><i class="fas fa-calculator me-2"></i>Υπολογισμός Υπηρεσιών</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <div class="alert alert-info">
                        <i class="fas fa-info-circle me-2"></i>
                        <small>Επιλέξτε τον μήνα ή τους μήνες για τους οποίους θέλετε να υπολογιστούν οι υπηρεσίες. Οι υπηρεσίες προηγούμενων μηνών δεν θα επηρεαστούν.</small>
                    </div>
                    <div class="mb-3">
                        <label for="calculateStartMonth" class="form-label">Από Μήνα</label>
                        <input type="month" class="form-control" id="calculateStartMonth" required>
                    </div>
                    <div class="mb-3">
                        <label for="calculateEndMonth" class="form-label">Έως Μήνα (Προαιρετικό)</label>
                        <input type="month" class="form-control" id="calculateEndMonth">
                        <small class="text-muted">Αφήστε κενό για υπολογισμό μόνο του επιλεγμένου μήνα</small>
                    </div>
                    <div class="form-check mb-3">
                        <input class="form-check-input" type="checkbox" id="preserveExistingAssignments" checked>
                        <label class="form-check-label" for="preserveExistingAssignments">
                            Διατήρηση υπαρχουσών αναθέσεων (μη αντικατάσταση)
                        </label>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Ακύρωση</button>
                    <button type="button" class="btn btn-primary" id="calculateDutiesButton" onclick="calculateDutiesForSelectedMonths()">
                        <i class="fas fa-calculator me-1"></i>Υπολογισμός
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Step-by-Step Calculation Modal -->
    <div class="modal fade" id="stepByStepCalculationModal" tabindex="-1">
        <div class="modal-dialog modal-xl">
            <div class="modal-content">
                <div class="modal-header bg-primary text-white">
                    <h5 class="modal-title">
                        <i class="fas fa-calculator me-2"></i>Υπολογισμός Υπηρεσιών - Βήμα <span id="currentStepNumber">1</span>
                    </h5>
                    <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body" id="stepContent" style="max-height: 70vh; overflow-y: auto;">
                    <!-- Step content will be loaded here -->
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" id="backButton" onclick="goToPreviousStep()" style="display: none;">
                        <i class="fas fa-arrow-left me-1"></i>Πίσω
                    </button>
                    <button type="button" class="btn btn-secondary" onclick="cancelStepByStepCalculation()">Ακύρωση</button>
                    <button type="button" class="btn btn-primary" id="nextButton" onclick="goToNextStep()">
                        <i class="fas fa-arrow-right me-1"></i>Επόμενο
                    </button>
                    <button type="button" class="btn btn-success" id="calculateButton" onclick="executeCalculation()" style="display: none;">
                        <i class="fas fa-check me-1"></i>Υπολογισμός
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Add Holiday Modal -->
    <div class="modal fade" id="addHolidayModal" tabindex="-1">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Προσθήκη Αργίας</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <div class="mb-3">
                        <label for="holidayDate" class="form-label">Ημερομηνία</label>
                        <input type="date" class="form-control" id="holidayDate">
                    </div>
                    <div class="mb-3">
                        <label for="holidayName" class="form-label">Όνομα Αργίας (Προαιρετικό)</label>
                        <input type="text" class="form-control" id="holidayName" placeholder="π.χ., Χριστούγεννα, Πρωτοχρονιά">
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Ακύρωση</button>
                    <button type="button" class="btn btn-primary" onclick="saveHoliday()">Προσθήκη Αργίας</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Missing Period Modal -->
    <div class="modal fade" id="missingPeriodModal" tabindex="-1">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header bg-warning">
                    <h5 class="modal-title"><i class="fas fa-calendar-times me-2"></i>Διαχείριση Περιόδων Απουσίας</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <div class="mb-3">
                        <strong>Άτομο:</strong> <span id="missingPeriodPersonName"></span>
                    </div>
                    <div class="alert alert-info">
                        <i class="fas fa-info-circle me-2"></i>
                        <small>Κατά την περίοδο απουσίας, το άτομο θα παραλείπεται από τις αναθέσεις υπηρεσιών, αλλά η εναλλαγή θα συνεχίζει να υπολογίζεται κανονικά.</small>
                    </div>
                    <div class="mb-3">
                        <h6>Προσθήκη Νέας Περιόδου Απουσίας</h6>
                        <div class="row">
                            <div class="col-md-6 mb-3">
                                <label for="missingPeriodStart" class="form-label">Ημερομηνία Έναρξης</label>
                                <input type="date" class="form-control" id="missingPeriodStart" required>
                            </div>
                            <div class="col-md-6 mb-3">
                                <label for="missingPeriodEnd" class="form-label">Ημερομηνία Λήξης</label>
                                <input type="date" class="form-control" id="missingPeriodEnd" required>
                            </div>
                        </div>
                        <button type="button" class="btn btn-primary" onclick="addMissingPeriod()">
                            <i class="fas fa-plus me-1"></i>Προσθήκη Περιόδου
                        </button>
                    </div>
                    <hr>
                    <div class="mb-3">
                        <h6>Υπάρχουσες Περίοδοι Απουσίας</h6>
                        <div id="missingPeriodsList"></div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Κλείσιμο</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Transfer Person Position Modal -->
    <div class="modal fade" id="transferPositionModal" tabindex="-1">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header bg-primary">
                    <h5 class="modal-title"><i class="fas fa-exchange-alt me-2"></i>Τοποθέτηση Ατόμου σε Νέα Ομάδα</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <div class="alert alert-info">
                        <i class="fas fa-info-circle me-2"></i>
                        <small>Βρείτε άτομα από την νέα ομάδα που είχαν υπηρεσία την ίδια ημέρα με το άτομο που μεταφέρεται και τοποθετήστε το πάνω ή κάτω από αυτά σε κάθε λίστα.</small>
                    </div>
                    <div class="mb-3">
                        <strong>Άτομο που μεταφέρεται:</strong> <span id="transferPersonName"></span><br>
                        <strong>Από Ομάδα:</strong> <span id="transferFromGroup"></span> → <strong>Σε Ομάδα:</strong> <span id="transferToGroup"></span>
                    </div>
                    <div id="transferPositionLists"></div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Ακύρωση</button>
                    <button type="button" class="btn btn-primary" onclick="completeTransfer()">
                        <i class="fas fa-check me-1"></i>Ολοκλήρωση Μεταφοράς
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Person Actions Modal -->
    <div class="modal fade" id="personActionsModal" tabindex="-1">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header bg-primary">
                    <h5 class="modal-title"><i class="fas fa-user me-2"></i>Ενέργειες Ατόμου</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <div class="mb-3">
                        <h6><strong>Άτομο:</strong> <span id="personActionsName"></span></h6>
                        <p class="text-muted"><strong>Ομάδα:</strong> <span id="personActionsGroup"></span></p>
                    </div>
                    <div class="d-grid gap-2">
                        <button type="button" class="btn btn-outline-info" onclick="openEditPersonFromActions()">
                            <i class="fas fa-edit me-2"></i>Επεξεργασία Στοιχείων
                        </button>
                        <button type="button" class="btn btn-outline-warning" onclick="openMissingPeriodFromActions()">
                            <i class="fas fa-calendar-times me-2"></i>Διαχείριση Περιόδων Απουσίας
                        </button>
                        <button type="button" class="btn btn-outline-primary" onclick="openTransferFromActions()">
                            <i class="fas fa-exchange-alt me-2"></i>Αλλαγή Ομάδας
                        </button>
                        <button type="button" class="btn btn-outline-danger" onclick="deletePersonFromActions()">
                            <i class="fas fa-trash me-2"></i>Διαγραφή Ατόμου
                        </button>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Κλείσιμο</button>
                </div>
            </div>
        </div>
    </div>


    <!-- Day Details Modal -->
    <div class="modal fade" id="dayDetailsModal" tabindex="-1">
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="dayDetailsTitle"></h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body modal-day-details" id="dayDetailsContent"></div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-primary" onclick="saveDayAssignments()">
                        <i class="fas fa-save me-1"></i>Αποθήκευση Αλλαγών
                    </button>
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Κλείσιμο</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Assign Duty Modal -->
    <div class="modal fade" id="assignDutyModal" tabindex="-1">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Ανάθεση Υπηρεσίας</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <div class="mb-3">
                        <label for="assignDutyDate" class="form-label">Ημερομηνία</label>
                        <input type="date" class="form-control" id="assignDutyDate" required>
                    </div>
                    <div class="mb-3">
                        <label for="assignDutyGroup" class="form-label">Ομάδα</label>
                        <select class="form-control" id="assignDutyGroup" required>
                            <option value="">Επιλέξτε Ομάδα</option>
                            <option value="1">ΕΠΙΚΕΦΑΛΗΣ-ΑΥΜ</option>
                            <option value="2">ΜΗΧΑΝΙΚΟΣ-ΟΠΛΟΥΡΓΟΣ-ΟΔΗΓΟΣ</option>
                            <option value="3">ΤΕΧΝΙΚΟΣ Ε/Π AW139</option>
                            <option value="4">ΤΕΧΝΙΚΟΣ ΕΠΙΓΕΙΩΝ ΜΕΣΩΝ</option>
                        </select>
                    </div>
                    <div class="mb-3">
                        <label for="assignDutyPerson" class="form-label">Άτομο</label>
                        <select class="form-control" id="assignDutyPerson" required>
                            <option value="">Επιλέξτε Άτομο</option>
                        </select>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Ακύρωση</button>
                    <button type="button" class="btn btn-primary" onclick="saveManualDuty()">Αποθήκευση</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Rotation Violations Modal -->
    <div class="modal fade" id="rotationViolationsModal" tabindex="-1">
        <div class="modal-dialog modal-xl">
            <div class="modal-content">
                <div class="modal-header bg-warning">
                    <h5 class="modal-title"><i class="fas fa-exclamation-triangle me-2"></i>Παραβιάσεις Αναθέσεων Υπηρεσιών</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <div class="alert alert-info">
                        <i class="fas fa-info-circle me-2"></i>
                        <small>Αυτή η λίστα εμφανίζει όλες τις αναθέσεις του τρέχοντος μήνα που δεν ακολούθησαν την αυστηρή N-ημέρες περιστροφή, μαζί με τον λόγο για τον οποίο το άτομο μετακινήθηκε.</small>
                    </div>
                    <div id="rotationViolationsList" class="table-responsive">
                        <table class="table table-striped table-hover">
                            <thead>
                                <tr>
                                    <th>Ημερομηνία</th>
                                    <th>Ομάδα</th>
                                    <th>Άτομο που Ανέθεται</th>
                                    <th>Άτομο που Έπρεπε να Ανέθεται</th>
                                    <th>Λόγος</th>
                                </tr>
                            </thead>
                            <tbody id="rotationViolationsTableBody">
                                <!-- Violations will be inserted here -->
                            </tbody>
                        </table>
                    </div>
                    <div id="noViolationsMessage" class="alert alert-success" style="display: none;">
                        <i class="fas fa-check-circle me-2"></i>Δεν βρέθηκαν παραβιάσεις! Όλες οι αναθέσεις ακολουθούν την αυστηρή N-ημέρες περιστροφή.
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Κλείσιμο</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Excel Preview Modal -->
    <div class="modal fade" id="excelPreviewModal" tabindex="-1">
        <div class="modal-dialog modal-fullscreen">
            <div class="modal-content">
                <div class="modal-header bg-success text-white">
                    <h5 class="modal-title"><i class="fas fa-file-excel me-2"></i>Προεπισκόπηση Excel Αρχείων</h5>
                    <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body" style="max-height: calc(100vh - 200px); overflow-y: auto;">
                    <div class="alert alert-info">
                        <i class="fas fa-info-circle me-2"></i>
                        <small>Παρακάτω εμφανίζεται η προεπισκόπηση των Excel αρχείων που θα δημιουργηθούν. Κάθε ομάδα θα έχει το δικό της αρχείο.</small>
                    </div>
                    <div id="excelPreviewContent">
                        <!-- Preview content will be inserted here -->
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Ακύρωση</button>
                    <button type="button" class="btn btn-success" id="generateExcelBtn" onclick="generateExcelFilesForCurrentMonth(true)">
                        <i class="fas fa-download me-1"></i>Δημιουργία Excel Αρχείων
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Firebase SDK - must load before common.js -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-storage-compat.js"></script>
    
    <!-- Common Firebase configuration and utilities -->
    <script src="js/common.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // Data storage - each group has four order lists: special, weekend, semi, normal
        // Each person also has last duty dates for each type, missing periods, and priorities
        let groups = {
            1: { special: [], weekend: [], semi: [], normal: [], lastDuties: {}, missingPeriods: {}, priorities: {} },
            2: { special: [], weekend: [], semi: [], normal: [], lastDuties: {}, missingPeriods: {}, priorities: {} },
            3: { special: [], weekend: [], semi: [], normal: [], lastDuties: {}, missingPeriods: {}, priorities: {} },
            4: { special: [], weekend: [], semi: [], normal: [], lastDuties: {}, missingPeriods: {}, priorities: {} }
        };
        let holidays = [];
        let specialHolidays = []; // User-defined special holidays
        // Separate assignments by day type
        let normalDayAssignments = {};
        let semiNormalAssignments = {};
        let weekendAssignments = {};
        let specialHolidayAssignments = {};
        // Legacy: Keep dutyAssignments for backward compatibility during migration
        let dutyAssignments = {};
        // Track critical assignments from last duties - these must NEVER be deleted
        // Format: { "2025-12-25": ["Person Name (Ομάδα 1)", ...], ... }
        let criticalAssignments = {};
        
        // Helper functions to get/set assignments based on day type
        function getAssignmentsForDayType(dayTypeCategory) {
            if (dayTypeCategory === 'special') {
                return specialHolidayAssignments;
            } else if (dayTypeCategory === 'weekend') {
                return weekendAssignments;
            } else if (dayTypeCategory === 'semi') {
                return semiNormalAssignments;
            } else { // normal
                return normalDayAssignments;
            }
        }
        
        // Get assignment for a specific date (checks correct document based on day type)
        function getAssignmentForDate(dateKey) {
            try {
                const date = new Date(dateKey + 'T00:00:00');
                if (isNaN(date.getTime())) return null;
                
                const dayType = getDayType(date);
                if (dayType === 'special-holiday') {
                    return specialHolidayAssignments[dateKey] || null;
                } else if (dayType === 'weekend-holiday') {
                    return weekendAssignments[dateKey] || null;
                } else if (dayType === 'semi-normal-day') {
                    return semiNormalAssignments[dateKey] || null;
                } else if (dayType === 'normal-day') {
                    return normalDayAssignments[dateKey] || null;
                }
            } catch (error) {
                console.error(`Error getting assignment for ${dateKey}:`, error);
            }
            // Fallback to legacy dutyAssignments
            return dutyAssignments[dateKey] || null;
        }
        
        // Set assignment for a specific date (saves to correct document based on day type)
        function setAssignmentForDate(dateKey, assignmentValue) {
            try {
                const date = new Date(dateKey + 'T00:00:00');
                if (isNaN(date.getTime())) {
                    console.error(`Invalid date key: ${dateKey}`);
                    return;
                }
                
                const dayType = getDayType(date);
                if (dayType === 'special-holiday') {
                    specialHolidayAssignments[dateKey] = assignmentValue;
                } else if (dayType === 'weekend-holiday') {
                    weekendAssignments[dateKey] = assignmentValue;
                } else if (dayType === 'semi-normal-day') {
                    semiNormalAssignments[dateKey] = assignmentValue;
                } else if (dayType === 'normal-day') {
                    normalDayAssignments[dateKey] = assignmentValue;
                }
                
                // Also update legacy dutyAssignments for backward compatibility
                dutyAssignments[dateKey] = assignmentValue;
            } catch (error) {
                console.error(`Error setting assignment for ${dateKey}:`, error);
            }
        }
        
        // Delete assignment for a specific date
        function deleteAssignmentForDate(dateKey) {
            try {
                const date = new Date(dateKey + 'T00:00:00');
                if (isNaN(date.getTime())) return;
                
                const dayType = getDayType(date);
                if (dayType === 'special-holiday') {
                    delete specialHolidayAssignments[dateKey];
                } else if (dayType === 'weekend-holiday') {
                    delete weekendAssignments[dateKey];
                } else if (dayType === 'semi-normal-day') {
                    delete semiNormalAssignments[dateKey];
                } else if (dayType === 'normal-day') {
                    delete normalDayAssignments[dateKey];
                }
                
                // Also delete from legacy dutyAssignments
                delete dutyAssignments[dateKey];
            } catch (error) {
                console.error(`Error deleting assignment for ${dateKey}:`, error);
            }
        }
        
        // Get all assignments (merged from all day types) - for backward compatibility
        function getAllAssignments() {
            const all = {};
            // Merge all day type assignments
            Object.assign(all, normalDayAssignments);
            Object.assign(all, semiNormalAssignments);
            Object.assign(all, weekendAssignments);
            Object.assign(all, specialHolidayAssignments);
            return all;
        }
        // Track intended assignments - when a person should be assigned but was skipped due to conflicts
        // Format: { "2026-02-05": { "1": "Person A", "2": "Person B", ... }, ... }
        // This ensures N-day rotation counts from the intended day, not the actual assignment day
        let intendedAssignments = {};
        let currentDate = new Date();
        let currentGroup = null;
        let selectedDateForDuty = null;
        
        // Step-by-step calculation state
        let calculationSteps = {
            currentStep: 1,
            totalSteps: 4,
            startDate: null,
            endDate: null,
            preserveExisting: true,
            dayTypeLists: null
        };
        
        // Configuration for recurring special holidays
        // Format: { month: 1-12, day: 1-31, name: string, type: 'fixed' | 'easter-relative', offset?: number }
        let recurringSpecialHolidays = [
            { month: 12, day: 24, name: 'Παραμονή Χριστουγέννων', type: 'fixed' },
            { month: 12, day: 25, name: 'Χριστούγεννα', type: 'fixed' },
            { month: 12, day: 31, name: 'Παραμονή Πρωτοχρονιάς', type: 'fixed' },
            { month: 1, day: 1, name: 'Πρωτοχρονιά', type: 'fixed' },
            { name: 'Μεγάλο Σάββατο', type: 'easter-relative', offset: -1 }, // 1 day before Easter
            { name: 'Πάσχα', type: 'easter-relative', offset: 0 } // Easter Sunday
        ];

        // Track data loading to prevent duplicate loads
        let dataLastLoaded = null;
        let isLoadingData = false;
        const DATA_CACHE_DURATION = 5 * 60 * 1000; // 5 minutes cache duration
        
        // Initialize
        document.addEventListener('DOMContentLoaded', async function() {
            // Wait for Firebase to be ready
            if (window.auth && window.db) {
                // Check authentication
                let authListenerUnsubscribed = false;
                const unsubscribe = window.auth.onAuthStateChanged(async function(user) {
                    // Prevent duplicate processing if listener fires multiple times
                    if (authListenerUnsubscribed) return;
                    
                    if (user && user.emailVerified) {
                        // Check if data was recently loaded to prevent duplicate reads
                        const now = Date.now();
                        if (dataLastLoaded && (now - dataLastLoaded) < DATA_CACHE_DURATION && !isLoadingData) {
                            console.log('[DUTY-SHIFTS] Data recently loaded, skipping reload');
                            // Still render with existing data
                            renderGroups();
                            renderHolidays();
                            renderRecurringHolidays();
                            renderCalendar();
                            updateStatistics();
                            return;
                        }
                        
                        isLoadingData = true;
                        await loadData();
                        dataLastLoaded = Date.now();
                        isLoadingData = false;
                        
                        renderGroups();
                        renderHolidays();
                        renderRecurringHolidays();
                        renderCalendar();
                        updateStatistics();
                    } else {
                        // Not authenticated, use localStorage
                        loadDataFromLocalStorage();
                        renderGroups();
                        renderHolidays();
                        renderRecurringHolidays();
                        renderCalendar();
                        updateStatistics();
                    }
                });
                
                // Clean up listener when page is hidden/unloaded to prevent background reads
                document.addEventListener('visibilitychange', function() {
                    if (document.hidden) {
                        // Page is hidden, unsubscribe to prevent background reads
                        if (unsubscribe && typeof unsubscribe === 'function') {
                            unsubscribe();
                            authListenerUnsubscribed = true;
                        }
                    }
                });
                
                window.addEventListener('beforeunload', function() {
                    // Page is unloading, unsubscribe to prevent reads
                    if (unsubscribe && typeof unsubscribe === 'function') {
                        unsubscribe();
                        authListenerUnsubscribed = true;
                    }
                });
            } else {
                // Firebase not loaded yet, wait a bit and try again
                setTimeout(() => {
                    document.dispatchEvent(new Event('DOMContentLoaded'));
                }, 500);
            }
        });

        // Load data from Firebase Firestore
        async function loadData() {
            try {
                // Wait for Firebase to be ready
                if (!window.db) {
                    console.log('Waiting for Firebase to initialize...');
                    setTimeout(loadData, 100);
                    return;
                }
                
                const db = window.db || firebase.firestore();
                const user = window.auth?.currentUser;
                
                if (!user) {
                    console.log('User not authenticated, using localStorage as fallback');
                    loadDataFromLocalStorage();
                    return;
                }
                
                // Load groups
                const groupsDoc = await db.collection('dutyShifts').doc('groups').get();
                if (groupsDoc.exists) {
                    const data = groupsDoc.data();
                    // Remove metadata fields
                    delete data.lastUpdated;
                    delete data.updatedBy;
                    // Migrate old format to new format if needed
                    groups = migrateGroupsFormat(data) || { 1: { regular: [], special: [] }, 2: { regular: [], special: [] }, 3: { regular: [], special: [] }, 4: { regular: [], special: [] } };
                    
                    // CRITICAL: Always ensure priorities object exists and is properly initialized
                    for (let i = 1; i <= 4; i++) {
                        if (!groups[i]) {
                            groups[i] = { special: [], weekend: [], semi: [], normal: [], lastDuties: {}, missingPeriods: {}, priorities: {} };
                        }
                        if (!groups[i].priorities) {
                            groups[i].priorities = {};
                        }
                        
                        // Ensure all people in lists have priority entries (only if they don't already exist)
                        const listTypes = ['special', 'weekend', 'semi', 'normal'];
                        listTypes.forEach(listType => {
                            const list = groups[i][listType] || [];
                            list.forEach(person => {
                                if (!groups[i].priorities[person]) {
                                    groups[i].priorities[person] = {};
                                }
                                // Only set default if priority doesn't exist (preserve existing priorities)
                                if (groups[i].priorities[person][listType] === undefined) {
                                    groups[i].priorities[person][listType] = 999; // Default priority
                                }
                            });
                        });
                    }
                    
                    // Save immediately to ensure priorities are persisted
                    saveData();
                    
                    // Debug: Log lastDuties and priorities to verify they're loaded
                    console.log('Loaded groups from Firestore');
                    for (let g = 1; g <= 4; g++) {
                        if (groups[g] && groups[g].lastDuties) {
                            const lastDutiesCount = Object.keys(groups[g].lastDuties).length;
                            if (lastDutiesCount > 0) {
                                console.log(`Group ${g} has ${lastDutiesCount} people with lastDuties:`, Object.keys(groups[g].lastDuties));
                                // Log sample lastDuties
                                const samplePerson = Object.keys(groups[g].lastDuties)[0];
                                console.log(`Sample lastDuties for ${samplePerson}:`, groups[g].lastDuties[samplePerson]);
                            }
                        }
                        if (groups[g] && groups[g].priorities) {
                            const prioritiesCount = Object.keys(groups[g].priorities).length;
                            if (prioritiesCount > 0) {
                                console.log(`Group ${g} has ${prioritiesCount} people with priorities:`, Object.keys(groups[g].priorities));
                            }
                        }
                    }
                }
                
                // Load holidays
                const holidaysDoc = await db.collection('dutyShifts').doc('holidays').get();
                if (holidaysDoc.exists) {
                    const data = holidaysDoc.data();
                    holidays = data.list || [];
                }
                
                // Load special holidays
                const specialHolidaysDoc = await db.collection('dutyShifts').doc('specialHolidays').get();
                if (specialHolidaysDoc.exists) {
                    const data = specialHolidaysDoc.data();
                    specialHolidays = data.list || [];
                }
                
                // Load recurring holidays configuration
                await loadRecurringHolidaysConfig();
                
                // Initialize default special holidays if they don't exist
                initializeDefaultSpecialHolidays();
                
                // Load assignments from separate documents by day type
                const normalDayDoc = await db.collection('dutyShifts').doc('normalDayAssignments').get();
                if (normalDayDoc.exists) {
                    const data = normalDayDoc.data();
                    delete data.lastUpdated;
                    delete data.updatedBy;
                    delete data._migratedFrom;
                    delete data._migrationDate;
                    normalDayAssignments = data || {};
                }
                
                const semiNormalDoc = await db.collection('dutyShifts').doc('semiNormalAssignments').get();
                if (semiNormalDoc.exists) {
                    const data = semiNormalDoc.data();
                    delete data.lastUpdated;
                    delete data.updatedBy;
                    delete data._migratedFrom;
                    delete data._migrationDate;
                    semiNormalAssignments = data || {};
                }
                
                const weekendDoc = await db.collection('dutyShifts').doc('weekendAssignments').get();
                if (weekendDoc.exists) {
                    const data = weekendDoc.data();
                    delete data.lastUpdated;
                    delete data.updatedBy;
                    delete data._migratedFrom;
                    delete data._migrationDate;
                    weekendAssignments = data || {};
                }
                
                const specialHolidayDoc = await db.collection('dutyShifts').doc('specialHolidayAssignments').get();
                if (specialHolidayDoc.exists) {
                    const data = specialHolidayDoc.data();
                    delete data.lastUpdated;
                    delete data.updatedBy;
                    delete data._migratedFrom;
                    delete data._migrationDate;
                    specialHolidayAssignments = data || {};
                }
                
                // Also load legacy assignments document for backward compatibility
                const assignmentsDoc = await db.collection('dutyShifts').doc('assignments').get();
                if (assignmentsDoc.exists) {
                    const data = assignmentsDoc.data();
                    delete data.lastUpdated;
                    delete data.updatedBy;
                    dutyAssignments = data || {};
                    // Merge legacy assignments into day-type-specific documents if they don't exist
                    for (const dateKey in dutyAssignments) {
                        if (dateKey === 'lastUpdated' || dateKey === 'updatedBy') continue;
                        try {
                            const date = new Date(dateKey + 'T00:00:00');
                            if (isNaN(date.getTime())) continue;
                            const dayType = getDayType(date);
                            const assignmentValue = dutyAssignments[dateKey];
                            
                            if (dayType === 'special-holiday' && !specialHolidayAssignments[dateKey]) {
                                specialHolidayAssignments[dateKey] = assignmentValue;
                            } else if (dayType === 'weekend-holiday' && !weekendAssignments[dateKey]) {
                                weekendAssignments[dateKey] = assignmentValue;
                            } else if (dayType === 'semi-normal-day' && !semiNormalAssignments[dateKey]) {
                                semiNormalAssignments[dateKey] = assignmentValue;
                            } else if (dayType === 'normal-day' && !normalDayAssignments[dateKey]) {
                                normalDayAssignments[dateKey] = assignmentValue;
                            }
                        } catch (error) {
                            console.error(`Error processing legacy assignment ${dateKey}:`, error);
                        }
                    }
                }
                
                // Load critical assignments
                const criticalAssignmentsDoc = await db.collection('dutyShifts').doc('criticalAssignments').get();
                if (criticalAssignmentsDoc.exists) {
                    const data = criticalAssignmentsDoc.data();
                    // Remove metadata fields
                    delete data.lastUpdated;
                    delete data.updatedBy;
                    criticalAssignments = data || {};
                    
                    console.log('Loaded criticalAssignments from Firestore:', Object.keys(criticalAssignments).length, 'dates');
                    console.log('Sample criticalAssignments:', Object.entries(criticalAssignments).slice(0, 3));
                    
                    // Restore critical assignments to dutyAssignments if they're missing
                    Object.keys(criticalAssignments).forEach(dateKey => {
                        const criticalPeople = criticalAssignments[dateKey];
                        // Handle both array format and string format (for backward compatibility)
                        let peopleArray = [];
                        if (Array.isArray(criticalPeople)) {
                            peopleArray = criticalPeople;
                        } else if (typeof criticalPeople === 'string') {
                            peopleArray = [criticalPeople];
                        }
                        
                        if (peopleArray.length > 0) {
                            // Ensure critical assignments are in day-type-specific documents
                            const existingAssignment = getAssignmentForDate(dateKey);
                            if (!existingAssignment) {
                                setAssignmentForDate(dateKey, peopleArray.join(', '));
                                console.log(`Restored critical assignment for ${dateKey}: ${peopleArray.join(', ')}`);
                            } else {
                                // Merge critical assignments with existing ones
                                const existing = existingAssignment.split(', ');
                                peopleArray.forEach(person => {
                                    if (!existing.includes(person)) {
                                        existing.push(person);
                                    }
                                });
                                setAssignmentForDate(dateKey, existing.join(', '));
                                console.log(`Merged critical assignment for ${dateKey}: ${existing.join(', ')}`);
                            }
                        }
                    });
                } else {
                    console.log('No criticalAssignments document found in Firestore');
                }
                
                // After loading all data, rebuild criticalAssignments from lastDuties if they're missing
                // This ensures manually entered dates are always protected
                rebuildCriticalAssignmentsFromLastDuties();
                
                console.log('Data loaded from Firebase');
            } catch (error) {
                console.error('Error loading data from Firebase:', error);
                // Fallback to localStorage
                loadDataFromLocalStorage();
            }
        }

        // Rebuild criticalAssignments from lastDuties
        // This ensures manually entered dates are always protected, even if criticalAssignments wasn't saved
        // IMPORTANT: This function only updates in-memory data. It does NOT save to Firebase.
        // Saving should only happen when actual changes are made by the user.
        function rebuildCriticalAssignmentsFromLastDuties() {
            let rebuiltCount = 0;
            let updatedCount = 0;
            
            for (let groupNum = 1; groupNum <= 4; groupNum++) {
                const groupData = groups[groupNum];
                if (!groupData || !groupData.lastDuties) continue;
                
                Object.keys(groupData.lastDuties).forEach(personName => {
                    const lastDuties = groupData.lastDuties[personName];
                    const personGroupStr = `${personName} (Ομάδα ${groupNum})`;
                    
                    // Process each last duty date
                    const dutyTypes = ['special', 'weekend', 'semi', 'normal'];
                    dutyTypes.forEach(type => {
                        const dateStr = lastDuties[type];
                        if (dateStr) {
                            try {
                                // Parse date string - handle both YYYY-MM-DD and DD/MM/YYYY formats
                                let dateObj;
                                if (dateStr.includes('/')) {
                                    // DD/MM/YYYY format
                                    const parts = dateStr.split('/');
                                    if (parts.length === 3) {
                                        let year = parseInt(parts[2]);
                                        if (year < 100) {
                                            year = year < 50 ? 2000 + year : 1900 + year;
                                        }
                                        dateObj = new Date(year, parseInt(parts[1]) - 1, parseInt(parts[0]));
                                    }
                                } else {
                                    // YYYY-MM-DD format
                                    const [year, month, day] = dateStr.split('-').map(Number);
                                    dateObj = new Date(year, month - 1, day);
                                }
                                
                                if (dateObj && !isNaN(dateObj.getTime())) {
                                    const dateKey = formatDateKey(dateObj);
                                    
                                    // Add to criticalAssignments (only if not already there)
                                    if (!criticalAssignments[dateKey]) {
                                        criticalAssignments[dateKey] = [];
                                    }
                                    if (!criticalAssignments[dateKey].includes(personGroupStr)) {
                                        criticalAssignments[dateKey].push(personGroupStr);
                                        rebuiltCount++;
                                    }
                                    
                                    // Also ensure it's in day-type-specific assignments (only if not already there)
                                    const existingAssignment = getAssignmentForDate(dateKey);
                                    if (!existingAssignment) {
                                        setAssignmentForDate(dateKey, personGroupStr);
                                        updatedCount++;
                                    } else if (!existingAssignment.includes(personGroupStr)) {
                                        setAssignmentForDate(dateKey, existingAssignment + `, ${personGroupStr}`);
                                        updatedCount++;
                                    }
                                }
                            } catch (error) {
                                console.error(`Error rebuilding critical assignment for ${dateStr}:`, error);
                            }
                        }
                    });
                });
            }
            
            // Only log if there were actual changes
            if (rebuiltCount > 0 || updatedCount > 0) {
                console.log(`Rebuilt ${rebuiltCount} critical assignments and updated ${updatedCount} duty assignments from lastDuties (in-memory only, not saved)`);
            }
        }

        // Fallback: Load data from localStorage
        function loadDataFromLocalStorage() {
            const savedGroups = localStorage.getItem('dutyShiftsGroups');
            const savedHolidays = localStorage.getItem('dutyShiftsHolidays');
            
            if (savedGroups) {
                const parsed = JSON.parse(savedGroups);
                groups = migrateGroupsFormat(parsed) || { 1: { regular: [], special: [] }, 2: { regular: [], special: [] }, 3: { regular: [], special: [] }, 4: { regular: [], special: [] } };
                
                // Initialize priorities if they don't exist (backward compatibility)
                for (let i = 1; i <= 4; i++) {
                    if (!groups[i]) continue;
                    if (!groups[i].priorities) groups[i].priorities = {};
                    
                    // Ensure all people in lists have priority entries
                    const listTypes = ['special', 'weekend', 'semi', 'normal'];
                    listTypes.forEach(listType => {
                        const list = groups[i][listType] || [];
                        list.forEach(person => {
                            if (!groups[i].priorities[person]) {
                                groups[i].priorities[person] = {};
                            }
                            if (groups[i].priorities[person][listType] === undefined) {
                                groups[i].priorities[person][listType] = 999; // Default priority
                            }
                        });
                    });
                }
            }
            if (savedHolidays) {
                holidays = JSON.parse(savedHolidays);
            }
            
            const savedSpecialHolidays = localStorage.getItem('dutyShiftsSpecialHolidays');
            if (savedSpecialHolidays) {
                specialHolidays = JSON.parse(savedSpecialHolidays);
            }
            
            // Load recurring holidays configuration
            loadRecurringHolidaysConfig();
            
            // Initialize default special holidays if they don't exist
            initializeDefaultSpecialHolidays();
            
            // Load separate day-type assignments
            const savedNormalDayAssignments = localStorage.getItem('dutyShiftsNormalDayAssignments');
            if (savedNormalDayAssignments) {
                normalDayAssignments = JSON.parse(savedNormalDayAssignments);
            }
            
            const savedSemiNormalAssignments = localStorage.getItem('dutyShiftsSemiNormalAssignments');
            if (savedSemiNormalAssignments) {
                semiNormalAssignments = JSON.parse(savedSemiNormalAssignments);
            }
            
            const savedWeekendAssignments = localStorage.getItem('dutyShiftsWeekendAssignments');
            if (savedWeekendAssignments) {
                weekendAssignments = JSON.parse(savedWeekendAssignments);
            }
            
            const savedSpecialHolidayAssignments = localStorage.getItem('dutyShiftsSpecialHolidayAssignments');
            if (savedSpecialHolidayAssignments) {
                specialHolidayAssignments = JSON.parse(savedSpecialHolidayAssignments);
            }
            
            // Also load legacy assignments for backward compatibility
            const savedAssignments = localStorage.getItem('dutyShiftsAssignments');
            if (savedAssignments) {
                dutyAssignments = JSON.parse(savedAssignments);
                // Merge legacy assignments into day-type-specific documents if they don't exist
                for (const dateKey in dutyAssignments) {
                    if (dateKey === 'lastUpdated' || dateKey === 'updatedBy') continue;
                    try {
                        const date = new Date(dateKey + 'T00:00:00');
                        if (isNaN(date.getTime())) continue;
                        const dayType = getDayType(date);
                        const assignmentValue = dutyAssignments[dateKey];
                        
                        if (dayType === 'special-holiday' && !specialHolidayAssignments[dateKey]) {
                            specialHolidayAssignments[dateKey] = assignmentValue;
                        } else if (dayType === 'weekend-holiday' && !weekendAssignments[dateKey]) {
                            weekendAssignments[dateKey] = assignmentValue;
                        } else if (dayType === 'semi-normal-day' && !semiNormalAssignments[dateKey]) {
                            semiNormalAssignments[dateKey] = assignmentValue;
                        } else if (dayType === 'normal-day' && !normalDayAssignments[dateKey]) {
                            normalDayAssignments[dateKey] = assignmentValue;
                        }
                    } catch (error) {
                        console.error(`Error processing legacy assignment ${dateKey}:`, error);
                    }
                }
            }
            
            // Load critical assignments
            const savedCriticalAssignments = localStorage.getItem('dutyShiftsCriticalAssignments');
            if (savedCriticalAssignments) {
                criticalAssignments = JSON.parse(savedCriticalAssignments);
                
                // Restore critical assignments to day-type-specific documents if they're missing
                Object.keys(criticalAssignments).forEach(dateKey => {
                    const criticalPeople = criticalAssignments[dateKey];
                    if (Array.isArray(criticalPeople) && criticalPeople.length > 0) {
                        const existingAssignment = getAssignmentForDate(dateKey);
                        if (!existingAssignment) {
                            setAssignmentForDate(dateKey, criticalPeople.join(', '));
                        } else {
                            // Merge critical assignments with existing ones
                            const existing = existingAssignment.split(', ');
                            criticalPeople.forEach(person => {
                                if (!existing.includes(person)) {
                                    existing.push(person);
                                }
                            });
                            setAssignmentForDate(dateKey, existing.join(', '));
                        }
                    }
                });
            }
            
            // After loading from localStorage, rebuild criticalAssignments from lastDuties
            rebuildCriticalAssignmentsFromLastDuties();
        }

        // Save data to Firebase Firestore
        async function saveData() {
            try {
                // Wait for Firebase to be ready
                if (!window.db) {
                    console.log('Firebase not ready, saving to localStorage');
                    saveDataToLocalStorage();
                    return;
                }
                
                const db = window.db || firebase.firestore();
                const user = window.auth?.currentUser;
                
                if (!user) {
                    console.log('User not authenticated, saving to localStorage');
                    saveDataToLocalStorage();
                    return;
                }
                
                // Save groups
                await db.collection('dutyShifts').doc('groups').set({
                    ...groups,
                    lastUpdated: firebase.firestore.FieldValue.serverTimestamp(),
                    updatedBy: user.uid
                });
                
                // Save holidays
                await db.collection('dutyShifts').doc('holidays').set({
                    list: holidays,
                    lastUpdated: firebase.firestore.FieldValue.serverTimestamp(),
                    updatedBy: user.uid
                });
                
                // Save special holidays
                await db.collection('dutyShifts').doc('specialHolidays').set({
                    list: specialHolidays,
                    lastUpdated: firebase.firestore.FieldValue.serverTimestamp(),
                    updatedBy: user.uid
                });
                
                // Save assignments to separate documents by day type
                await db.collection('dutyShifts').doc('normalDayAssignments').set({
                    ...normalDayAssignments,
                    lastUpdated: firebase.firestore.FieldValue.serverTimestamp(),
                    updatedBy: user.uid
                });
                
                await db.collection('dutyShifts').doc('semiNormalAssignments').set({
                    ...semiNormalAssignments,
                    lastUpdated: firebase.firestore.FieldValue.serverTimestamp(),
                    updatedBy: user.uid
                });
                
                await db.collection('dutyShifts').doc('weekendAssignments').set({
                    ...weekendAssignments,
                    lastUpdated: firebase.firestore.FieldValue.serverTimestamp(),
                    updatedBy: user.uid
                });
                
                await db.collection('dutyShifts').doc('specialHolidayAssignments').set({
                    ...specialHolidayAssignments,
                    lastUpdated: firebase.firestore.FieldValue.serverTimestamp(),
                    updatedBy: user.uid
                });
                
                // Save critical assignments separately
                console.log('Saving criticalAssignments to Firestore:', Object.keys(criticalAssignments).length, 'dates');
                if (Object.keys(criticalAssignments).length > 0) {
                    console.log('Sample criticalAssignments being saved:', Object.entries(criticalAssignments).slice(0, 3));
                }
                await db.collection('dutyShifts').doc('criticalAssignments').set({
                    ...criticalAssignments,
                    lastUpdated: firebase.firestore.FieldValue.serverTimestamp(),
                    updatedBy: user.uid
                });
                
                console.log('Data saved to Firebase');
                
                // Also save to localStorage as backup
                saveDataToLocalStorage();
            } catch (error) {
                console.error('Error saving data to Firebase:', error);
                // Fallback to localStorage
                saveDataToLocalStorage();
            }
        }

        // Migration function: Split assignments by day type
        async function migrateAssignmentsByDayType() {
            try {
                if (!window.db) {
                    alert('Firebase not ready');
                    return;
                }
                
                const db = window.db || firebase.firestore();
                const user = window.auth?.currentUser;
                
                if (!user) {
                    alert('User not authenticated');
                    return;
                }
                
                // Confirm migration
                if (!confirm('Αυτή η λειτουργία θα διαχωρίσει τις υπηρεσίες σε 4 ξεχωριστά έγγραφα ανά τύπο ημέρας.\n\nΣυνέχεια;')) {
                    return;
                }
                
                console.log('Starting migration: Splitting assignments by day type...');
                
                // Load current assignments
                const assignmentsDoc = await db.collection('dutyShifts').doc('assignments').get();
                if (!assignmentsDoc.exists) {
                    alert('Δεν βρέθηκε έγγραφο assignments');
                    return;
                }
                
                const data = assignmentsDoc.data();
                // Remove metadata fields
                const assignments = { ...data };
                delete assignments.lastUpdated;
                delete assignments.updatedBy;
                
                // Initialize separate assignment objects
                const normalDayAssignments = {};
                const semiNormalAssignments = {};
                const weekendAssignments = {};
                const specialHolidayAssignments = {};
                
                let processedCount = 0;
                let errorCount = 0;
                
                // Process each date
                for (const dateKey in assignments) {
                    if (dateKey === 'lastUpdated' || dateKey === 'updatedBy') continue;
                    
                    try {
                        // Parse date key (format: YYYY-MM-DD)
                        const date = new Date(dateKey + 'T00:00:00');
                        if (isNaN(date.getTime())) {
                            console.warn(`Invalid date key: ${dateKey}`);
                            errorCount++;
                            continue;
                        }
                        
                        // Determine day type
                        const dayType = getDayType(date);
                        const assignmentValue = assignments[dateKey];
                        
                        // Split based on day type
                        if (dayType === 'special-holiday') {
                            specialHolidayAssignments[dateKey] = assignmentValue;
                        } else if (dayType === 'weekend-holiday') {
                            weekendAssignments[dateKey] = assignmentValue;
                        } else if (dayType === 'semi-normal-day') {
                            semiNormalAssignments[dateKey] = assignmentValue;
                        } else if (dayType === 'normal-day') {
                            normalDayAssignments[dateKey] = assignmentValue;
                        } else {
                            console.warn(`Unknown day type for ${dateKey}: ${dayType}`);
                            errorCount++;
                            continue;
                        }
                        
                        processedCount++;
                    } catch (error) {
                        console.error(`Error processing ${dateKey}:`, error);
                        errorCount++;
                    }
                }
                
                // Save to separate documents
                console.log('Saving split assignments...');
                
                await db.collection('dutyShifts').doc('normalDayAssignments').set({
                    ...normalDayAssignments,
                    lastUpdated: firebase.firestore.FieldValue.serverTimestamp(),
                    updatedBy: user.uid,
                    _migratedFrom: 'assignments',
                    _migrationDate: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                await db.collection('dutyShifts').doc('semiNormalAssignments').set({
                    ...semiNormalAssignments,
                    lastUpdated: firebase.firestore.FieldValue.serverTimestamp(),
                    updatedBy: user.uid,
                    _migratedFrom: 'assignments',
                    _migrationDate: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                await db.collection('dutyShifts').doc('weekendAssignments').set({
                    ...weekendAssignments,
                    lastUpdated: firebase.firestore.FieldValue.serverTimestamp(),
                    updatedBy: user.uid,
                    _migratedFrom: 'assignments',
                    _migrationDate: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                await db.collection('dutyShifts').doc('specialHolidayAssignments').set({
                    ...specialHolidayAssignments,
                    lastUpdated: firebase.firestore.FieldValue.serverTimestamp(),
                    updatedBy: user.uid,
                    _migratedFrom: 'assignments',
                    _migrationDate: firebase.firestore.FieldValue.serverTimestamp()
                });
                
                console.log('Migration completed!');
                console.log(`Processed: ${processedCount} dates`);
                console.log(`Errors: ${errorCount}`);
                console.log(`Normal days: ${Object.keys(normalDayAssignments).length}`);
                console.log(`Semi-normal days: ${Object.keys(semiNormalAssignments).length}`);
                console.log(`Weekend/Holiday days: ${Object.keys(weekendAssignments).length}`);
                console.log(`Special holidays: ${Object.keys(specialHolidayAssignments).length}`);
                
                alert(`Μεταφορά ολοκληρώθηκε!\n\nΕπεξεργάστηκε: ${processedCount} ημερομηνίες\nΣφάλματα: ${errorCount}\n\nΚαθημερινές: ${Object.keys(normalDayAssignments).length}\nΗμιαργίες: ${Object.keys(semiNormalAssignments).length}\nΣαββατοκύριακα/Αργίες: ${Object.keys(weekendAssignments).length}\nΕιδικές Αργίες: ${Object.keys(specialHolidayAssignments).length}`);
                
            } catch (error) {
                console.error('Error during migration:', error);
                alert('Σφάλμα κατά τη μεταφορά: ' + error.message);
            }
        }

        // Fallback: Save data to localStorage
        function saveDataToLocalStorage() {
            localStorage.setItem('dutyShiftsGroups', JSON.stringify(groups));
            localStorage.setItem('dutyShiftsHolidays', JSON.stringify(holidays));
            localStorage.setItem('dutyShiftsSpecialHolidays', JSON.stringify(specialHolidays));
            // Save separate day-type assignments
            localStorage.setItem('dutyShiftsNormalDayAssignments', JSON.stringify(normalDayAssignments));
            localStorage.setItem('dutyShiftsSemiNormalAssignments', JSON.stringify(semiNormalAssignments));
            localStorage.setItem('dutyShiftsWeekendAssignments', JSON.stringify(weekendAssignments));
            localStorage.setItem('dutyShiftsSpecialHolidayAssignments', JSON.stringify(specialHolidayAssignments));
            // Also save legacy dutyAssignments for backward compatibility
            localStorage.setItem('dutyShiftsAssignments', JSON.stringify(dutyAssignments));
            localStorage.setItem('dutyShiftsCriticalAssignments', JSON.stringify(criticalAssignments));
        }

        // Get group name by number
        function getGroupName(groupNum) {
            const groupNames = {
                1: 'ΕΠΙΚΕΦΑΛΗΣ-ΑΥΜ',
                2: 'ΜΗΧΑΝΙΚΟΣ-ΟΠΛΟΥΡΓΟΣ-ΟΔΗΓΟΣ',
                3: 'ΤΕΧΝΙΚΟΣ Ε/Π AW139',
                4: 'ΤΕΧΝΙΚΟΣ ΕΠΙΓΕΙΩΝ ΜΕΣΩΝ'
            };
            return groupNames[groupNum] || `Ομάδα ${groupNum}`;
        }

        // Migrate old groups format to new format
        function migrateGroupsFormat(data) {
            if (!data) return null;
            
            const migrated = {
                1: { special: [], weekend: [], semi: [], normal: [], lastDuties: {}, missingPeriods: {}, priorities: {} },
                2: { special: [], weekend: [], semi: [], normal: [], lastDuties: {}, missingPeriods: {}, priorities: {} },
                3: { special: [], weekend: [], semi: [], normal: [], lastDuties: {}, missingPeriods: {}, priorities: {} },
                4: { special: [], weekend: [], semi: [], normal: [], lastDuties: {}, missingPeriods: {}, priorities: {} }
            };
            
            for (let i = 1; i <= 4; i++) {
                if (Array.isArray(data[i])) {
                    // Old format - array of names, copy to all lists
                    const people = [...data[i]];
                    migrated[i].special = [...people];
                    migrated[i].weekend = [...people];
                    migrated[i].semi = [...people];
                    migrated[i].normal = [...people];
                    // Preserve lastDuties, missingPeriods, and priorities if they exist (shouldn't in old format, but just in case)
                    if (data[i].lastDuties) migrated[i].lastDuties = data[i].lastDuties;
                    if (data[i].missingPeriods) migrated[i].missingPeriods = data[i].missingPeriods;
                    if (data[i].priorities) migrated[i].priorities = data[i].priorities;
                } else if (data[i] && typeof data[i] === 'object') {
                    // ALWAYS preserve lastDuties, missingPeriods, and priorities if they exist
                    if (data[i].lastDuties) migrated[i].lastDuties = data[i].lastDuties;
                    if (data[i].missingPeriods) migrated[i].missingPeriods = data[i].missingPeriods;
                    if (data[i].priorities) migrated[i].priorities = data[i].priorities;
                    
                    // Check if old format (regular/special) or new format
                    if (data[i].regular || data[i].special) {
                        // Old format with regular/special
                        const allPeople = [...new Set([...(data[i].regular || []), ...(data[i].special || [])])];
                        migrated[i].special = [...allPeople];
                        migrated[i].weekend = [...allPeople];
                        migrated[i].semi = [...allPeople];
                        migrated[i].normal = [...allPeople];
                    } else if (data[i].special || data[i].weekend || data[i].semi || data[i].normal) {
                        // New format - copy as is
                        migrated[i].special = data[i].special || [];
                        migrated[i].weekend = data[i].weekend || [];
                        migrated[i].semi = data[i].semi || [];
                        migrated[i].normal = data[i].normal || [];
                    } else {
                        // Fallback
                        const people = data[i].people || [];
                        migrated[i].special = [...people];
                        migrated[i].weekend = [...people];
                        migrated[i].semi = [...people];
                        migrated[i].normal = [...people];
                    }
                    // Preserve lastDuties, missingPeriods, and priorities if they exist (for all cases)
                    if (data[i].lastDuties) migrated[i].lastDuties = data[i].lastDuties;
                    if (data[i].missingPeriods) migrated[i].missingPeriods = data[i].missingPeriods;
                    if (data[i].priorities) migrated[i].priorities = data[i].priorities;
                }
            }
            
            return migrated;
        }

        // Helper function to track which lists are currently open
        function getOpenLists() {
            const openLists = [];
            for (let i = 1; i <= 4; i++) {
                const listTypes = ['special', 'weekend', 'semi', 'normal'];
                listTypes.forEach(lt => {
                    const listId = `${lt}List_${i}`;
                    const listElement = document.getElementById(listId);
                    if (listElement && listElement.classList.contains('show')) {
                        openLists.push(listId);
                    }
                });
            }
            return openLists;
        }

        // Helper function to restore open lists after renderGroups
        function restoreOpenLists(openLists) {
            if (!openLists || openLists.length === 0) return;
            
            setTimeout(() => {
                openLists.forEach(listId => {
                    const listElement = document.getElementById(listId);
                    if (listElement) {
                        const bsCollapse = new bootstrap.Collapse(listElement, {
                            toggle: false
                        });
                        bsCollapse.show();
                        // Update chevron
                        const chevronId = listId.replace('List_', 'Chevron_');
                        const chevronElement = document.getElementById(chevronId);
                        if (chevronElement) {
                            chevronElement.classList.remove('fa-chevron-down');
                            chevronElement.classList.add('fa-chevron-up');
                        }
                    }
                });
            }, 50);
        }

        // Render groups - shows 4 separate order lists per group
        // preserveOpenLists: if true, preserves currently open lists
        // forceOpenLists: array of list IDs that should be opened after render
        function renderGroups(preserveOpenLists = true, forceOpenLists = []) {
            // Track open lists before rendering if preserveOpenLists is true
            const openLists = preserveOpenLists ? getOpenLists() : [];
            
            // Add any forced open lists to the list
            if (forceOpenLists && forceOpenLists.length > 0) {
                forceOpenLists.forEach(listId => {
                    if (!openLists.includes(listId)) {
                        openLists.push(listId);
                    }
                });
            }
            for (let i = 1; i <= 4; i++) {
                const container = document.getElementById(`group${i}People`);
                container.innerHTML = '';
                
                const groupData = groups[i] || { special: [], weekend: [], semi: [], normal: [], lastDuties: {}, priorities: {} };
                
                // Ensure priorities exist
                if (!groupData.priorities) groupData.priorities = {};
                
                // Sort each list by priority before rendering
                const listTypes = ['special', 'weekend', 'semi', 'normal'];
                listTypes.forEach(listType => {
                    if (groupData[listType]) {
                        groupData[listType].sort((a, b) => {
                            // Get priorities (default to 999 if not set)
                            const priorityA = groupData.priorities[a]?.[listType] ?? 999;
                            const priorityB = groupData.priorities[b]?.[listType] ?? 999;
                            
                            // First sort by priority (lower number = higher priority)
                            if (priorityA !== priorityB) {
                                return priorityA - priorityB;
                            }
                            
                            // If priorities are equal, sort by last duty date (most recent first, no date last)
                            const dateA = groupData.lastDuties?.[a]?.[listType];
                            const dateB = groupData.lastDuties?.[b]?.[listType];
                            
                            if (!dateA && !dateB) return 0; // Both have no date, maintain order
                            if (!dateA) return 1; // A has no date, put it last
                            if (!dateB) return -1; // B has no date, put it last
                            
                            // Both have dates, sort by date (most recent first)
                            return new Date(dateB) - new Date(dateA);
                        });
                    }
                });
                
                const specialList = groupData.special || [];
                const weekendList = groupData.weekend || [];
                const semiList = groupData.semi || [];
                const normalList = groupData.normal || [];
                
                const allPeople = new Set([...specialList, ...weekendList, ...semiList, ...normalList]);
                
                if (allPeople.size === 0) {
                    container.innerHTML = '<p class="text-muted text-center">Δεν έχουν προστεθεί άτομα ακόμα</p>';
                } else {
                    // Special holidays order
                    const specialDiv = document.createElement('div');
                    specialDiv.className = 'mb-3 border rounded p-2';
                    specialDiv.innerHTML = `
                        <div class="list-header d-flex justify-content-between align-items-center mb-2" onclick="toggleListCollapse('specialList_${i}', 'specialChevron_${i}')">
                            <strong class="text-warning"><i class="fas fa-star me-1"></i>Σειρά Ειδικών Αργιών:</strong>
                            <i id="specialChevron_${i}" class="fas fa-chevron-down"></i>
                        </div>
                        <div id="specialList_${i}" class="collapse"></div>
                    `;
                    container.appendChild(specialDiv);
                    
                    // Weekend/Holiday order
                    const weekendDiv = document.createElement('div');
                    weekendDiv.className = 'mb-3 border rounded p-2';
                    weekendDiv.innerHTML = `
                        <div class="list-header d-flex justify-content-between align-items-center mb-2" onclick="toggleListCollapse('weekendList_${i}', 'weekendChevron_${i}')">
                            <strong class="text-info"><i class="fas fa-calendar-week me-1"></i>Σειρά Σαββατοκύριακων/Αργιών:</strong>
                            <i id="weekendChevron_${i}" class="fas fa-chevron-down"></i>
                        </div>
                        <div id="weekendList_${i}" class="collapse"></div>
                    `;
                    container.appendChild(weekendDiv);
                    
                    // Ημιαργία order
                    const semiDiv = document.createElement('div');
                    semiDiv.className = 'mb-3 border rounded p-2';
                    semiDiv.innerHTML = `
                        <div class="list-header d-flex justify-content-between align-items-center mb-2" onclick="toggleListCollapse('semiList_${i}', 'semiChevron_${i}')">
                            <strong class="text-warning"><i class="fas fa-calendar-alt me-1"></i>Σειρά Ημιαργιών:</strong>
                            <i id="semiChevron_${i}" class="fas fa-chevron-down"></i>
                        </div>
                        <div id="semiList_${i}" class="collapse"></div>
                    `;
                    container.appendChild(semiDiv);
                    
                    // Καθημερινή order
                    const normalDiv = document.createElement('div');
                    normalDiv.className = 'mb-3 border rounded p-2';
                    normalDiv.innerHTML = `
                        <div class="list-header d-flex justify-content-between align-items-center mb-2" onclick="toggleListCollapse('normalList_${i}', 'normalChevron_${i}')">
                            <strong class="text-primary"><i class="fas fa-calendar-day me-1"></i>Σειρά Καθημερινών:</strong>
                            <i id="normalChevron_${i}" class="fas fa-chevron-down"></i>
                        </div>
                        <div id="normalList_${i}" class="collapse"></div>
                    `;
                    container.appendChild(normalDiv);
                    
                    // Render each list
                    const lists = [
                        { type: 'special', list: specialList, containerId: `specialList_${i}` },
                        { type: 'weekend', list: weekendList, containerId: `weekendList_${i}` },
                        { type: 'semi', list: semiList, containerId: `semiList_${i}` },
                        { type: 'normal', list: normalList, containerId: `normalList_${i}` }
                    ];
                    
                    lists.forEach(({ type, list, containerId }) => {
                        const listContainer = document.getElementById(containerId);
                        if (list.length === 0) {
                            listContainer.innerHTML = '<p class="text-muted text-center small">Δεν υπάρχουν άτομα</p>';
                        } else {
                            list.forEach((person, index) => {
                                const personDiv = createPersonItem(i, person, index, type, list);
                                listContainer.appendChild(personDiv);
                            });
                        }
                    });
                }
                
                const rotationSpan = document.getElementById(`group${i}Rotation`);
                rotationSpan.textContent = allPeople.size > 0 ? allPeople.size : '-';
            }
            
            // Restore open lists if preserveOpenLists is true
            if (preserveOpenLists && openLists.length > 0) {
                restoreOpenLists(openLists);
            }
        }

        // Helper function to get last duty date and calculate next duty date based on rotation order
        function getLastAndNextDutyDates(person, groupNum, listType, listArrayLength) {
            const groupData = groups[groupNum] || { special: [], weekend: [], semi: [], normal: [], lastDuties: {} };
            const lastDuties = groupData.lastDuties?.[person] || {};
            const lastDutyDateStr = lastDuties[listType];
            
            let lastDutyDate = null;
            let lastDutyFormatted = 'Δεν έχει';
            
            // First check manually entered last duty date
            if (lastDutyDateStr) {
                // Parse the date string - handle both YYYY-MM-DD and DD/MM/YYYY formats
                let parsedDate = null;
                if (lastDutyDateStr.includes('/')) {
                    // DD/MM/YYYY or DD/MM/YY format
                    const parts = lastDutyDateStr.split('/');
                    if (parts.length === 3) {
                        let year = parseInt(parts[2]);
                        const month = parseInt(parts[1]);
                        const day = parseInt(parts[0]);
                        // Handle 2-digit years: if year < 50, assume 20XX, else assume 19XX
                        if (year < 100) {
                            year = year < 50 ? 2000 + year : 1900 + year;
                        }
                        // Validate the date components
                        if (!isNaN(year) && !isNaN(month) && !isNaN(day) && month >= 1 && month <= 12 && day >= 1 && day <= 31) {
                            parsedDate = new Date(year, month - 1, day);
                        }
                    }
                } else {
                    // YYYY-MM-DD format
                    parsedDate = new Date(lastDutyDateStr + 'T00:00:00');
                }
                if (parsedDate && !isNaN(parsedDate.getTime())) {
                    // Create a fresh Date object to avoid any reference issues
                    lastDutyDate = new Date(parsedDate.getTime());
                    lastDutyDate.setHours(0, 0, 0, 0);
                    lastDutyFormatted = lastDutyDate.toLocaleDateString('el-GR', { day: '2-digit', month: '2-digit', year: 'numeric' });
                }
            }
            
            // If no manually entered date, check actual assignments to find most recent duty of THIS SPECIFIC TYPE
            if (!lastDutyDate) {
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                
                // Look through assignments to find most recent duty of this SPECIFIC type
                const sortedDateKeys = Object.keys(dutyAssignments).sort().reverse();
                
                for (const dateKey of sortedDateKeys) {
                    const assignment = dutyAssignments[dateKey];
                    if (!assignment) continue;
                    
                    // Use extractAllPersonNames to properly parse the assignment string
                    const assignedPersons = extractAllPersonNames(assignment);
                    
                    // Check if this person is assigned on this date
                    const isPersonAssigned = assignedPersons.some(p => 
                        p.name === person && p.group === groupNum
                    );
                    
                    if (!isPersonAssigned) continue;
                    
                    const assignmentDate = new Date(dateKey + 'T00:00:00');
                    if (isNaN(assignmentDate.getTime())) continue; // Skip invalid dates
                    assignmentDate.setHours(0, 0, 0, 0);
                    if (assignmentDate > today) continue; // Skip future dates
                    
                    // Check for special holidays FIRST using isSpecialHoliday() directly
                    let dayTypeCategory = 'normal';
                    const isSpecial = isSpecialHoliday(assignmentDate);
                    if (isSpecial) {
                        dayTypeCategory = 'special';
                    } else {
                        // For non-special holidays, use getDayType()
                        const dayType = getDayType(assignmentDate);
                        if (dayType === 'semi-normal-day') {
                            dayTypeCategory = 'semi';
                        } else if (dayType === 'weekend-holiday') {
                            dayTypeCategory = 'weekend';
                        }
                        // else remains 'normal'
                    }
                    
                    // Only consider assignments that match the EXACT listType we're looking for
                    if (dayTypeCategory === listType) {
                        // Create a fresh Date object to avoid any reference issues
                        lastDutyDate = new Date(assignmentDate.getTime());
                        lastDutyDate.setHours(0, 0, 0, 0);
                        lastDutyFormatted = lastDutyDate.toLocaleDateString('el-GR', { day: '2-digit', month: '2-digit', year: 'numeric' });
                        break; // Found the most recent one, stop searching
                    }
                }
            }
            
            // Calculate next duty date based on rotation order (not person's last duty)
            let nextDutyFormatted = 'Δεν έχει';
            
            if (listArrayLength > 0) {
                // Get the person's index in the list (their rotation position)
                const list = groups[groupNum]?.[listType] || [];
                const personIndex = list.indexOf(person);
                
                if (personIndex === -1) {
                    return { lastDuty: lastDutyFormatted, nextDuty: 'Δεν έχει' };
                }
                
                // Find all upcoming days of this type starting from today
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                
                const upcomingDays = [];
                const checkDate = new Date(today);
                const maxDaysAhead = 3650; // 10 years limit
                let daysChecked = 0;
                
                // Collect all upcoming days of the matching type
                while (daysChecked < maxDaysAhead && upcomingDays.length < listArrayLength * 3) {
                    // Check for special holidays FIRST using isSpecialHoliday() directly
                    let dayTypeCategory = 'normal';
                    const isSpecial = isSpecialHoliday(checkDate);
                    if (isSpecial) {
                        dayTypeCategory = 'special';
                    } else {
                        // For non-special holidays, use getDayType()
                        const dayType = getDayType(checkDate);
                        if (dayType === 'semi-normal-day') {
                            dayTypeCategory = 'semi';
                        } else if (dayType === 'weekend-holiday') {
                            dayTypeCategory = 'weekend';
                        }
                        // else remains 'normal'
                    }
                    
                    // If this day matches the list type, add it
                    if (dayTypeCategory === listType) {
                        upcomingDays.push(new Date(checkDate));
                    }
                    
                    // Move to next day
                    checkDate.setDate(checkDate.getDate() + 1);
                    daysChecked++;
                }
                
                // Find the next day that matches this person's rotation position
                // Person at index 0 gets days: 0, listLength, 2*listLength, ...
                // Person at index 1 gets days: 1, listLength+1, 2*listLength+1, ...
                // Person at index 2 gets days: 2, listLength+2, 2*listLength+2, ...
                for (let i = 0; i < upcomingDays.length; i++) {
                    if (i % listArrayLength === personIndex) {
                        nextDutyFormatted = upcomingDays[i].toLocaleDateString('el-GR', { day: '2-digit', month: '2-digit', year: 'numeric' });
                        break;
                    }
                }
                
                if (nextDutyFormatted === 'Δεν έχει' && upcomingDays.length > 0) {
                    nextDutyFormatted = 'Δεν βρέθηκε';
                }
            }
            
            return { lastDuty: lastDutyFormatted, nextDuty: nextDutyFormatted };
        }

        // Create person item with reorder controls
        function createPersonItem(groupNum, person, index, listType, listArray) {
            const personDiv = document.createElement('div');
            personDiv.className = 'person-item';
            personDiv.draggable = true;
            personDiv.dataset.groupNum = groupNum;
            personDiv.dataset.index = index;
            personDiv.dataset.listType = listType;
            
            // Check if person is currently missing
            const groupData = groups[groupNum] || { special: [], weekend: [], semi: [], normal: [], lastDuties: {}, missingPeriods: {} };
            const missingPeriods = groupData.missingPeriods?.[person] || [];
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            const isCurrentlyMissing = missingPeriods.some(period => {
                const start = new Date(period.start + 'T00:00:00');
                const end = new Date(period.end + 'T00:00:00');
                return today >= start && today <= end;
            });
            const missingBadge = isCurrentlyMissing ? '<span class="badge bg-warning ms-2"><i class="fas fa-user-slash me-1"></i>Απουσία</span>' : '';
            
            // Get last duty date and calculate next duty date
            const dutyDates = getLastAndNextDutyDates(person, groupNum, listType, listArray.length);
            
            // Get priority number for this person in this list type
            const priority = groupData.priorities?.[person]?.[listType] ?? 999;
            
            // Determine priority class based on value (1-3 = high, 4-6 = medium, 7+ = low)
            let priorityClass = 'priority-low';
            if (priority <= 3) {
                priorityClass = 'priority-high';
            } else if (priority <= 6) {
                priorityClass = 'priority-medium';
            }
            
            // Create 3D priority badge
            const priorityBadge = priority < 999 ? 
                `<div class="priority-badge-3d ${priorityClass}" onclick="event.stopPropagation(); editPerson(${groupNum}, '${person.replace(/'/g, "\\'")}')" title="Προτεραιότητα: ${priority} - Κάντε κλικ για επεξεργασία">
                    ${priority}
                </div>` : 
                `<div class="priority-badge-3d priority-low" onclick="event.stopPropagation(); editPerson(${groupNum}, '${person.replace(/'/g, "\\'")}')" title="Δεν έχει οριστεί προτεραιότητα - Κάντε κλικ για επεξεργασία" style="opacity: 0.6;">
                    ?
                </div>`;
            
            personDiv.innerHTML = `
                <div class="person-name-card" onclick="openPersonActionsModal(${groupNum}, '${person.replace(/'/g, "\\'")}', ${index}, '${listType}')">
                    <div style="display: flex; flex-direction: column;">
                        <div style="display: flex; align-items: center;">
                            <i class="fas fa-grip-vertical text-muted me-2" style="cursor: move;"></i>
                            ${priorityBadge}
                            <span>${person}${missingBadge}</span>
                        </div>
                        <div style="font-size: 0.75rem; color: #666; margin-top: 0.25rem; margin-left: 1.5rem;">
                            <div><strong>Τελευταία:</strong> ${dutyDates.lastDuty}</div>
                            <div><strong>Επόμενη:</strong> ${dutyDates.nextDuty}</div>
                        </div>
                    </div>
                </div>
                <div class="person-actions">
                    <div class="btn-group btn-group-sm" role="group">
                        <button class="btn btn-outline-secondary" onclick="event.stopPropagation(); movePersonInList(${groupNum}, ${index}, '${listType}', 'up')" ${index === 0 ? 'disabled' : ''} title="Μετακίνηση προς τα πάνω">
                            <i class="fas fa-arrow-up"></i>
                        </button>
                        <button class="btn btn-outline-secondary" onclick="event.stopPropagation(); movePersonInList(${groupNum}, ${index}, '${listType}', 'down')" ${index === listArray.length - 1 ? 'disabled' : ''} title="Μετακίνηση προς τα κάτω">
                            <i class="fas fa-arrow-down"></i>
                        </button>
                    </div>
                </div>
            `;
            
            // Add drag and drop handlers
            personDiv.addEventListener('dragstart', handleDragStart);
            personDiv.addEventListener('dragenter', handleDragEnter);
            personDiv.addEventListener('dragleave', handleDragLeave);
            personDiv.addEventListener('dragover', handleDragOver);
            personDiv.addEventListener('drop', handleDrop);
            personDiv.addEventListener('dragend', handleDragEnd);
            
            return personDiv;
        }

        // Drag and drop handlers
        let draggedElement = null;
        let dragOverElement = null;
        
        function handleDragStart(e) {
            draggedElement = this;
            this.style.opacity = '0.5';
            this.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
        }
        
        function handleDragEnter(e) {
            if (e.preventDefault) {
                e.preventDefault();
            }
            if (draggedElement && draggedElement !== this) {
                this.classList.add('drag-over');
                dragOverElement = this;
            }
        }
        
        function handleDragLeave(e) {
            this.classList.remove('drag-over');
            if (dragOverElement === this) {
                dragOverElement = null;
            }
        }
        
        function handleDragOver(e) {
            if (e.preventDefault) {
                e.preventDefault();
            }
            e.dataTransfer.dropEffect = 'move';
            
            // Show drop indicator
            if (draggedElement && draggedElement !== this) {
                if (!this.classList.contains('drag-over')) {
                    this.classList.add('drag-over');
                }
                dragOverElement = this;
                
                // Auto-scroll when dragging near edges
                const rect = this.getBoundingClientRect();
                const scrollContainer = this.closest('.collapse.show') || this.closest('[id*="List_"]');
                
                if (scrollContainer) {
                    const containerRect = scrollContainer.getBoundingClientRect();
                    const scrollThreshold = 50; // pixels from edge
                    const scrollSpeed = 10; // pixels per scroll
                    
                    // Check if near top edge
                    if (rect.top < containerRect.top + scrollThreshold) {
                        scrollContainer.scrollTop = Math.max(0, scrollContainer.scrollTop - scrollSpeed);
                    }
                    // Check if near bottom edge
                    else if (rect.bottom > containerRect.bottom - scrollThreshold) {
                        scrollContainer.scrollTop = Math.min(
                            scrollContainer.scrollHeight - scrollContainer.clientHeight,
                            scrollContainer.scrollTop + scrollSpeed
                        );
                    }
                }
            }
            
            return false;
        }
        
        function handleDrop(e) {
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            
            // Remove all drag-over classes
            document.querySelectorAll('.person-item.drag-over').forEach(el => {
                el.classList.remove('drag-over');
            });
            
            if (draggedElement !== this) {
                const groupNum = parseInt(this.dataset.groupNum);
                const listType = this.dataset.listType;
                const fromIndex = parseInt(draggedElement.dataset.index);
                const toIndex = parseInt(this.dataset.index);
                
                const list = groups[groupNum][listType];
                const person = list[fromIndex];
                list.splice(fromIndex, 1);
                list.splice(toIndex, 0, person);
                
                // Update priorities to reflect the new order (priority = index + 1)
                if (!groups[groupNum].priorities) groups[groupNum].priorities = {};
                list.forEach((personName, index) => {
                    if (!groups[groupNum].priorities[personName]) {
                        groups[groupNum].priorities[personName] = {};
                    }
                    groups[groupNum].priorities[personName][listType] = index + 1;
                });
                
                saveData();
                
                // Ensure the list we just modified is open
                const modifiedListId = `${listType}List_${groupNum}`;
                renderGroups(true, [modifiedListId]);
            }
            
            dragOverElement = null;
            return false;
        }
        
        function handleDragEnd(e) {
            this.style.opacity = '1';
            this.classList.remove('dragging');
            
            // Remove all drag-over classes
            document.querySelectorAll('.person-item.drag-over').forEach(el => {
                el.classList.remove('drag-over');
            });
            
            draggedElement = null;
            dragOverElement = null;
        }

        // Global variable to track if we're editing
        let isEditingPerson = false;
        let editingPersonName = null;
        
        // Global variables for person actions modal
        let currentPersonActionsGroup = null;
        let currentPersonActionsName = null;
        let currentPersonActionsIndex = null;
        let currentPersonActionsListType = null;

        // Add person
        function addPerson(groupNumber) {
            isEditingPerson = false;
            editingPersonName = null;
            currentGroup = groupNumber;
            
            document.getElementById('modalTitle').innerHTML = `Προσθήκη Ατόμου στην <span id="modalGroupNumber">${getGroupName(groupNumber)}</span>`;
            document.getElementById('personName').value = '';
            document.getElementById('personName').readOnly = false;
            document.getElementById('lastSpecialDuty').value = '';
            document.getElementById('lastWeekendDuty').value = '';
            document.getElementById('lastSemiDuty').value = '';
            document.getElementById('lastNormalDuty').value = '';
            document.getElementById('prioritySpecial').value = '';
            document.getElementById('priorityWeekend').value = '';
            document.getElementById('prioritySemi').value = '';
            document.getElementById('priorityNormal').value = '';
            document.getElementById('savePersonButton').textContent = 'Προσθήκη Ατόμου';
            
            const modal = new bootstrap.Modal(document.getElementById('addPersonModal'));
            modal.show();
        }

        // Edit person
        function editPerson(groupNumber, personName) {
            isEditingPerson = true;
            editingPersonName = personName;
            currentGroup = groupNumber;
            
            const groupData = groups[groupNumber] || { special: [], weekend: [], semi: [], normal: [], lastDuties: {}, missingPeriods: {}, priorities: {} };
            const lastDuties = groupData.lastDuties?.[personName] || {};
            const priorities = groupData.priorities?.[personName] || {};
            
            // Debug: Log what we're loading
            console.log(`Edit person: ${personName} in group ${groupNumber}`);
            console.log(`Group data lastDuties:`, groupData.lastDuties);
            console.log(`Person lastDuties:`, lastDuties);
            console.log(`Special: ${lastDuties.special}, Weekend: ${lastDuties.weekend}, Semi: ${lastDuties.semi}, Normal: ${lastDuties.normal}`);
            
            document.getElementById('modalTitle').innerHTML = `Επεξεργασία Στοιχείων: ${personName}`;
            document.getElementById('personName').value = personName;
            document.getElementById('personName').readOnly = false;
            document.getElementById('lastSpecialDuty').value = lastDuties.special || '';
            document.getElementById('lastWeekendDuty').value = lastDuties.weekend || '';
            document.getElementById('lastSemiDuty').value = lastDuties.semi || '';
            document.getElementById('lastNormalDuty').value = lastDuties.normal || '';
            document.getElementById('prioritySpecial').value = priorities.special || '';
            document.getElementById('priorityWeekend').value = priorities.weekend || '';
            document.getElementById('prioritySemi').value = priorities.semi || '';
            document.getElementById('priorityNormal').value = priorities.normal || '';
            document.getElementById('savePersonButton').textContent = 'Αποθήκευση Αλλαγών';
            
            // Debug: Verify values were set
            console.log(`Form values set - Special: ${document.getElementById('lastSpecialDuty').value}, Weekend: ${document.getElementById('lastWeekendDuty').value}, Semi: ${document.getElementById('lastSemiDuty').value}, Normal: ${document.getElementById('lastNormalDuty').value}`);
            
            const modal = new bootstrap.Modal(document.getElementById('addPersonModal'));
            modal.show();
        }

        // Save person - adds to all 4 lists and stores last duty dates
        function savePerson() {
            const name = document.getElementById('personName').value.trim();
            if (!name) {
                alert('Παρακαλώ εισάγετε όνομα');
                return;
            }
            
            if (!groups[currentGroup]) {
                groups[currentGroup] = { special: [], weekend: [], semi: [], normal: [], lastDuties: {}, priorities: {} };
            }
            
            // Initialize lists if needed
            if (!groups[currentGroup].special) groups[currentGroup].special = [];
            if (!groups[currentGroup].weekend) groups[currentGroup].weekend = [];
            if (!groups[currentGroup].semi) groups[currentGroup].semi = [];
            if (!groups[currentGroup].normal) groups[currentGroup].normal = [];
            if (!groups[currentGroup].lastDuties) groups[currentGroup].lastDuties = {};
            if (!groups[currentGroup].priorities) groups[currentGroup].priorities = {};
            
            // Get last duty dates
            const lastSpecialDuty = document.getElementById('lastSpecialDuty').value;
            const lastWeekendDuty = document.getElementById('lastWeekendDuty').value;
            const lastSemiDuty = document.getElementById('lastSemiDuty').value;
            const lastNormalDuty = document.getElementById('lastNormalDuty').value;
            
            // Get priority values
            const prioritySpecial = document.getElementById('prioritySpecial').value.trim();
            const priorityWeekend = document.getElementById('priorityWeekend').value.trim();
            const prioritySemi = document.getElementById('prioritySemi').value.trim();
            const priorityNormal = document.getElementById('priorityNormal').value.trim();
            
            // Check if name changed when editing
            const nameChanged = isEditingPerson && name !== editingPersonName;
            const oldName = isEditingPerson ? editingPersonName : null;
            
            // Store last duties - use new name (name) for the key
            const personKey = name;
            
            // IMPORTANT: Read old lastDuties BEFORE updating, so we can compare and remove old assignments
            const oldLastDuties = isEditingPerson ? (groups[currentGroup].lastDuties[oldName] || {}) : {};
            
            // If name changed, we need to update all references
            if (nameChanged) {
                console.log(`[EDIT] Name changed from "${oldName}" to "${name}"`);
                
                // Update name in all 4 lists
                const listTypes = ['special', 'weekend', 'semi', 'normal'];
                listTypes.forEach(listType => {
                    const index = groups[currentGroup][listType].indexOf(oldName);
                    if (index !== -1) {
                        groups[currentGroup][listType][index] = name;
                        console.log(`[EDIT] Updated name in ${listType} list`);
                    }
                });
                
                // Rename key in lastDuties
                if (groups[currentGroup].lastDuties[oldName]) {
                    groups[currentGroup].lastDuties[name] = groups[currentGroup].lastDuties[oldName];
                    delete groups[currentGroup].lastDuties[oldName];
                    console.log(`[EDIT] Renamed lastDuties key from "${oldName}" to "${name}"`);
                }
                
                // Rename key in missingPeriods
                if (groups[currentGroup].missingPeriods && groups[currentGroup].missingPeriods[oldName]) {
                    if (!groups[currentGroup].missingPeriods[name]) {
                        groups[currentGroup].missingPeriods[name] = groups[currentGroup].missingPeriods[oldName];
                    }
                    delete groups[currentGroup].missingPeriods[oldName];
                    console.log(`[EDIT] Renamed missingPeriods key from "${oldName}" to "${name}"`);
                }
                
                // Rename key in priorities
                if (groups[currentGroup].priorities && groups[currentGroup].priorities[oldName]) {
                    if (!groups[currentGroup].priorities[name]) {
                        groups[currentGroup].priorities[name] = groups[currentGroup].priorities[oldName];
                    }
                    delete groups[currentGroup].priorities[oldName];
                    console.log(`[EDIT] Renamed priorities key from "${oldName}" to "${name}"`);
                }
                
                // Update all occurrences in dutyAssignments
                const oldPersonGroupStr = `${oldName} (Ομάδα ${currentGroup})`;
                const newPersonGroupStr = `${name} (Ομάδα ${currentGroup})`;
                
                Object.keys(dutyAssignments).forEach(dateKey => {
                    if (dutyAssignments[dateKey] && dutyAssignments[dateKey].includes(oldPersonGroupStr)) {
                        dutyAssignments[dateKey] = dutyAssignments[dateKey].replace(oldPersonGroupStr, newPersonGroupStr);
                        console.log(`[EDIT] Updated dutyAssignments[${dateKey}]`);
                    }
                });
                
                // Update all occurrences in criticalAssignments
                Object.keys(criticalAssignments).forEach(dateKey => {
                    if (criticalAssignments[dateKey]) {
                        const index = criticalAssignments[dateKey].indexOf(oldPersonGroupStr);
                        if (index !== -1) {
                            criticalAssignments[dateKey][index] = newPersonGroupStr;
                            console.log(`[EDIT] Updated criticalAssignments[${dateKey}]`);
                        }
                    }
                });
            }
            
            // Now update lastDuties with new values (using new name as key)
            groups[currentGroup].lastDuties[personKey] = {
                special: lastSpecialDuty || null,
                weekend: lastWeekendDuty || null,
                semi: lastSemiDuty || null,
                normal: lastNormalDuty || null
            };
            
            // Store priorities (using new name as key)
            // If priority is not provided, use a default value (999 for sorting - puts them at the end)
            groups[currentGroup].priorities[personKey] = {
                special: prioritySpecial ? parseInt(prioritySpecial) : 999,
                weekend: priorityWeekend ? parseInt(priorityWeekend) : 999,
                semi: prioritySemi ? parseInt(prioritySemi) : 999,
                normal: priorityNormal ? parseInt(priorityNormal) : 999
            };
            
            // Add last duty dates as critical assignments in the calendar (protected from recalculation)
            const lastDutyDates = [
                { date: lastSpecialDuty, type: 'special' },
                { date: lastWeekendDuty, type: 'weekend' },
                { date: lastSemiDuty, type: 'semi' },
                { date: lastNormalDuty, type: 'normal' }
            ];
            
            const addedAssignments = [];
            lastDutyDates.forEach(({ date, type }) => {
                if (date && date.trim()) {
                    try {
                        // Parse date string (YYYY-MM-DD) and create date in local timezone
                        const [year, month, day] = date.split('-').map(Number);
                        const dateObj = new Date(year, month - 1, day);
                        if (isNaN(dateObj.getTime())) {
                            console.error(`Invalid date: ${date}`);
                            return;
                        }
                        const dateKey = formatDateKey(dateObj);
                        const dayType = getDayType(dateObj);
                        
                        // Always add as critical assignment - these are manually entered baseline dates
                        // personKey is already defined above, use it here
                        const mode = isEditingPerson ? 'EDIT' : 'NEW';
                        console.log(`[${mode}] Adding critical assignment for ${personKey} on ${dateKey} (type: ${type}, dayType: ${dayType})`);
                        
                        // Always ensure this person's assignment is present for this date
                        // This is a critical baseline assignment that must be preserved
                        const existingAssignment = getAssignmentForDate(dateKey);
                        const personGroupStr = `${personKey} (Ομάδα ${currentGroup})`;
                        
                        // Mark this as a critical assignment (from last duty) - NEVER delete these
                        if (!criticalAssignments[dateKey]) {
                            criticalAssignments[dateKey] = [];
                        }
                        if (!criticalAssignments[dateKey].includes(personGroupStr)) {
                            criticalAssignments[dateKey].push(personGroupStr);
                            console.log(`[${mode}] ✓ Added to criticalAssignments[${dateKey}]:`, criticalAssignments[dateKey]);
                        } else {
                            console.log(`[${mode}] ✓ Already in criticalAssignments[${dateKey}]:`, criticalAssignments[dateKey]);
                        }
                        
                        // Verify criticalAssignments was updated
                        if (!criticalAssignments[dateKey] || !criticalAssignments[dateKey].includes(personGroupStr)) {
                            console.error(`[${mode}] ERROR: Failed to add to criticalAssignments for ${dateKey}!`);
                        }
                        
                        // ALWAYS update assignments - even if editing, we want the new dates
                        if (existingAssignment) {
                            // Check if this person is already assigned
                            if (!existingAssignment.includes(personGroupStr)) {
                                // Add this person to existing assignments
                                setAssignmentForDate(dateKey, existingAssignment + `, ${personGroupStr}`);
                                console.log(`[${mode}] Added to existing assignment for ${dateKey}: ${existingAssignment + ', ' + personGroupStr}`);
                            } else {
                                console.log(`[${mode}] Person already in assignment for ${dateKey}`);
                            }
                        } else {
                            // Create new assignment
                            setAssignmentForDate(dateKey, personGroupStr);
                            console.log(`[${mode}] Created new assignment for ${dateKey}: ${personGroupStr}`);
                        }
                        
                        // Verify it was added correctly
                        if (!dutyAssignments[dateKey] || !dutyAssignments[dateKey].includes(personGroupStr)) {
                            console.error(`[${mode}] ERROR: Failed to add assignment for ${dateKey}! Expected: ${personGroupStr}, Got: ${dutyAssignments[dateKey]}`);
                        } else {
                            console.log(`[${mode}] ✓ Verified assignment for ${dateKey}: ${dutyAssignments[dateKey]}`);
                        }
                        
                        addedAssignments.push(dateKey);
                    } catch (error) {
                        console.error(`Error processing date ${date}:`, error);
                    }
                }
            });
            
            if (addedAssignments.length > 0) {
                console.log(`✓ Added ${addedAssignments.length} critical baseline assignments for ${personKey}`);
                // Verify criticalAssignments contains these dates
                addedAssignments.forEach(dateKey => {
                    if (criticalAssignments[dateKey] && criticalAssignments[dateKey].length > 0) {
                        console.log(`✓ Verified criticalAssignments[${dateKey}] =`, criticalAssignments[dateKey]);
                    } else {
                        console.error(`ERROR: criticalAssignments[${dateKey}] is missing or empty!`);
                    }
                });
                console.log(`Total criticalAssignments keys:`, Object.keys(criticalAssignments).length);
            }
            
            // Note: New assignments are added in the lastDutyDates.forEach loop above
            // This applies to both new and edit modes
            // The loop runs FIRST, adding new assignments, then we remove old ones if editing
            
            if (isEditingPerson) {
                console.log(`[EDIT] Editing mode: Removing old assignments for ${editingPersonName}`);
                console.log(`[EDIT] Old lastDuties:`, oldLastDuties);
                console.log(`[EDIT] New lastDuties:`, groups[currentGroup].lastDuties[personKey]);
                
                // Get the NEW dates that will be set, organized by type
                const newDatesByType = {
                    special: lastSpecialDuty || null,
                    weekend: lastWeekendDuty || null,
                    semi: lastSemiDuty || null,
                    normal: lastNormalDuty || null
                };
                
                // Convert new dates to dateKeys for comparison
                const newDateKeysByType = {};
                Object.keys(newDatesByType).forEach(type => {
                    const dateStr = newDatesByType[type];
                    if (dateStr && dateStr.trim()) {
                        const [year, month, day] = dateStr.split('-').map(Number);
                        newDateKeysByType[type] = formatDateKey(new Date(year, month - 1, day));
                    }
                });
                
                // Remove old assignments - compare by TYPE
                // If the old date for a type is different from the new date for that type, remove the old one
                const oldDates = [
                    { date: oldLastDuties.special, type: 'special' },
                    { date: oldLastDuties.weekend, type: 'weekend' },
                    { date: oldLastDuties.semi, type: 'semi' },
                    { date: oldLastDuties.normal, type: 'normal' }
                ];
                
                oldDates.forEach(({ date, type }) => {
                    if (date) {
                        // Parse date string (YYYY-MM-DD) and create date in local timezone
                        const [year, month, day] = date.split('-').map(Number);
                        const dateObj = new Date(year, month - 1, day);
                        const oldDateKey = formatDateKey(dateObj);
                        const newDateKey = newDateKeysByType[type];
                        
                        // Remove if:
                        // 1. The old date is different from the new date for this type, OR
                        // 2. There's no new date for this type (user cleared it)
                        const shouldRemove = (newDateKey && oldDateKey !== newDateKey) || (!newDateKey && oldDateKey);
                        
                        if (shouldRemove) {
                            // Use current name (may have been changed) for removal
                            // If name changed, all references were already updated to use new name
                            const personGroupStr = `${name} (Ομάδα ${currentGroup})`;
                            const existingAssignment = dutyAssignments[oldDateKey];
                            
                            // Remove from critical assignments
                            if (criticalAssignments[oldDateKey]) {
                                criticalAssignments[oldDateKey] = criticalAssignments[oldDateKey].filter(a => a !== personGroupStr);
                                if (criticalAssignments[oldDateKey].length === 0) {
                                    delete criticalAssignments[oldDateKey];
                                }
                                console.log(`[EDIT] Removed old critical assignment for ${oldDateKey} (${type} changed from ${oldDateKey} to ${newDateKey || 'empty'})`);
                            }
                            
                            // Remove from regular assignments
                            if (existingAssignment && existingAssignment.includes(personGroupStr)) {
                                const assignments = existingAssignment.split(', ').filter(a => a !== personGroupStr);
                                if (assignments.length > 0) {
                                    dutyAssignments[oldDateKey] = assignments.join(', ');
                                } else {
                                    delete dutyAssignments[oldDateKey];
                                }
                                console.log(`[EDIT] Removed old assignment for ${oldDateKey} (${type} changed)`);
                            }
                        }
                    }
                });
            } else {
                // Adding new person - add to all lists if not already present
                const listTypes = ['special', 'weekend', 'semi', 'normal'];
                listTypes.forEach(listType => {
                    if (!groups[currentGroup][listType].includes(name)) {
                        groups[currentGroup][listType].push(name);
                    }
                });
            }
            
            // Sort each list by priority (lower number = higher priority), then by last duty date
            const listTypes = ['special', 'weekend', 'semi', 'normal'];
            listTypes.forEach(listType => {
                groups[currentGroup][listType].sort((a, b) => {
                    // Get priorities (default to 999 if not set)
                    const priorityA = groups[currentGroup].priorities?.[a]?.[listType] ?? 999;
                    const priorityB = groups[currentGroup].priorities?.[b]?.[listType] ?? 999;
                    
                    // First sort by priority (lower number = higher priority)
                    if (priorityA !== priorityB) {
                        return priorityA - priorityB;
                    }
                    
                    // If priorities are equal, sort by last duty date (most recent first, no date last)
                    const dateA = groups[currentGroup].lastDuties[a]?.[listType];
                    const dateB = groups[currentGroup].lastDuties[b]?.[listType];
                    
                    if (!dateA && !dateB) return 0; // Both have no date, maintain order
                    if (!dateA) return 1; // A has no date, put it last
                    if (!dateB) return -1; // B has no date, put it last
                    
                    // Both have dates, sort by date (most recent first)
                    return new Date(dateB) - new Date(dateA);
                });
                
                // After sorting, reassign priorities sequentially (1, 2, 3, ...) to prevent duplicates
                const list = groups[currentGroup][listType];
                list.forEach((person, index) => {
                    if (!groups[currentGroup].priorities[person]) {
                        groups[currentGroup].priorities[person] = {};
                    }
                    // Only update if the person had a valid priority (not 999)
                    const currentPriority = groups[currentGroup].priorities[person][listType];
                    if (currentPriority !== undefined && currentPriority < 999) {
                        groups[currentGroup].priorities[person][listType] = index + 1;
                    }
                });
            });
            
            // Clear form
            document.getElementById('personName').value = '';
            document.getElementById('personName').readOnly = false;
            document.getElementById('lastSpecialDuty').value = '';
            document.getElementById('lastWeekendDuty').value = '';
            document.getElementById('lastSemiDuty').value = '';
            document.getElementById('lastNormalDuty').value = '';
            document.getElementById('prioritySpecial').value = '';
            document.getElementById('priorityWeekend').value = '';
            document.getElementById('prioritySemi').value = '';
            document.getElementById('priorityNormal').value = '';
            
            isEditingPerson = false;
            editingPersonName = null;
            
            // Verify assignments are in the object before saving/rendering
            console.log('Before save - dutyAssignments for added dates:', 
                addedAssignments.map(key => ({ key, assignment: dutyAssignments[key] }))
            );
            
            // Verify assignments and criticalAssignments before saving
            console.log('Before saveData:');
            console.log('  - dutyAssignments keys:', Object.keys(dutyAssignments).length);
            console.log('  - criticalAssignments keys:', Object.keys(criticalAssignments).length);
            addedAssignments.forEach(key => {
                console.log(`  - dutyAssignments['${key}'] =`, dutyAssignments[key]);
                console.log(`  - criticalAssignments['${key}'] =`, criticalAssignments[key]);
            });
            
            saveData();
            renderGroups();
            
            // Double-check assignments are still there after saveData (should be, but verify)
            console.log('After saveData:');
            console.log('  - dutyAssignments keys:', Object.keys(dutyAssignments).length);
            console.log('  - criticalAssignments keys:', Object.keys(criticalAssignments).length);
            addedAssignments.forEach(key => {
                console.log(`  - dutyAssignments['${key}'] =`, dutyAssignments[key]);
                console.log(`  - criticalAssignments['${key}'] =`, criticalAssignments[key]);
            });
            
            // Force calendar refresh - ensure critical assignments are restored before rendering
            console.log('About to render calendar. Current criticalAssignments keys:', Object.keys(criticalAssignments).length);
            console.log('Current dutyAssignments keys:', Object.keys(dutyAssignments).length);
            
            renderCalendar(); // Refresh calendar to show the new critical assignments
            updateStatistics();
            
            // Verify assignments are visible after render
            setTimeout(() => {
                console.log('After calendar render - checking if assignments are visible');
                addedAssignments.forEach(key => {
                    const assignment = dutyAssignments[key];
                    console.log(`Post-render check: dutyAssignments['${key}'] =`, assignment);
                    if (!assignment) {
                        console.error(`WARNING: Assignment for ${key} is missing after render!`);
                    }
                });
            }, 100);
            
            const modal = bootstrap.Modal.getInstance(document.getElementById('addPersonModal'));
            modal.hide();
        }

        // Open person actions modal
        function openPersonActionsModal(groupNum, personName, index, listType) {
            currentPersonActionsGroup = groupNum;
            currentPersonActionsName = personName;
            currentPersonActionsIndex = index;
            currentPersonActionsListType = listType;
            
            document.getElementById('personActionsName').textContent = personName;
            document.getElementById('personActionsGroup').textContent = getGroupName(groupNum);
            
            const modal = new bootstrap.Modal(document.getElementById('personActionsModal'));
            modal.show();
        }
        
        // Open edit person from actions modal
        function openEditPersonFromActions() {
            const modal = bootstrap.Modal.getInstance(document.getElementById('personActionsModal'));
            modal.hide();
            editPerson(currentPersonActionsGroup, currentPersonActionsName);
        }
        
        // Open missing period modal from actions
        function openMissingPeriodFromActions() {
            const modal = bootstrap.Modal.getInstance(document.getElementById('personActionsModal'));
            modal.hide();
            openMissingPeriodModal(currentPersonActionsGroup, currentPersonActionsName);
        }
        
        // Open transfer modal from actions
        function openTransferFromActions() {
            const modal = bootstrap.Modal.getInstance(document.getElementById('personActionsModal'));
            modal.hide();
            // Show selection for target group
            const availableGroups = [1, 2, 3, 4].filter(g => g !== currentPersonActionsGroup);
            if (availableGroups.length === 0) {
                alert('Δεν υπάρχουν άλλες ομάδες για μεταφορά');
                return;
            }
            
            const groupOptions = availableGroups.map(g => `${g}: ${getGroupName(g)}`).join(', ');
            const targetGroupStr = prompt(`Επιλέξτε την ομάδα προορισμού (${groupOptions}):`);
            const targetGroup = parseInt(targetGroupStr);
            
            if (targetGroup && availableGroups.includes(targetGroup)) {
                transferPerson(currentPersonActionsGroup, currentPersonActionsIndex, targetGroup, currentPersonActionsListType);
            } else if (targetGroupStr !== null) {
                alert('Μη έγκυρη επιλογή ομάδας');
            }
        }
        
        // Delete person from actions modal
        function deletePersonFromActions() {
            if (confirm(`Είστε σίγουροι ότι θέλετε να διαγράψετε το άτομο "${currentPersonActionsName}" από όλες τις λίστες;`)) {
                const modal = bootstrap.Modal.getInstance(document.getElementById('personActionsModal'));
                modal.hide();
                
                // Remove from all lists in the group
                const allListTypes = ['special', 'weekend', 'semi', 'normal'];
                allListTypes.forEach(listType => {
                    const list = groups[currentPersonActionsGroup][listType] || [];
                    const index = list.indexOf(currentPersonActionsName);
                    if (index !== -1) {
                        list.splice(index, 1);
                    }
                });
                
                // Remove last duties and missing periods
                if (groups[currentPersonActionsGroup].lastDuties) {
                    delete groups[currentPersonActionsGroup].lastDuties[currentPersonActionsName];
                }
                if (groups[currentPersonActionsGroup].missingPeriods) {
                    delete groups[currentPersonActionsGroup].missingPeriods[currentPersonActionsName];
                }
                
                // Remove from critical assignments and duty assignments
                Object.keys(criticalAssignments).forEach(dateKey => {
                    if (criticalAssignments[dateKey]) {
                        criticalAssignments[dateKey] = criticalAssignments[dateKey].filter(a => 
                            !a.includes(`${currentPersonActionsName} (Ομάδα ${currentPersonActionsGroup})`)
                        );
                        if (criticalAssignments[dateKey].length === 0) {
                            delete criticalAssignments[dateKey];
                        }
                    }
                });
                
                Object.keys(dutyAssignments).forEach(dateKey => {
                    if (dutyAssignments[dateKey]) {
                        const personGroupStr = `${currentPersonActionsName} (Ομάδα ${currentPersonActionsGroup})`;
                        if (dutyAssignments[dateKey].includes(personGroupStr)) {
                            dutyAssignments[dateKey] = dutyAssignments[dateKey]
                                .split(', ')
                                .filter(a => a !== personGroupStr)
                                .join(', ');
                            if (dutyAssignments[dateKey] === '') {
                                delete dutyAssignments[dateKey];
                            }
                        }
                    }
                });
                
                saveData();
                renderGroups();
                renderCalendar();
                updateStatistics();
            }
        }

        // Remove person from specific list
        function removePerson(groupNumber, index, listType) {
            if (confirm('Είστε σίγουροι ότι θέλετε να αφαιρέσετε αυτό το άτομο από αυτή τη λίστα;')) {
                const list = groups[groupNumber][listType];
                const person = list[index];
                list.splice(index, 1);
                
                // Also remove from all other lists if it exists there
                const allListTypes = ['special', 'weekend', 'semi', 'normal'];
                allListTypes.forEach(otherListType => {
                    if (otherListType !== listType) {
                        const otherList = groups[groupNumber][otherListType] || [];
                        const otherIndex = otherList.indexOf(person);
                        if (otherIndex !== -1) {
                            otherList.splice(otherIndex, 1);
                        }
                    }
                });
                
                // Remove last duties entry if person is removed from all lists
                const stillInAnyList = allListTypes.some(lt => (groups[groupNumber][lt] || []).includes(person));
                if (!stillInAnyList && groups[groupNumber].lastDuties) {
                    delete groups[groupNumber].lastDuties[person];
                }
                
                saveData();
                renderGroups();
                updateStatistics();
            }
        }

        // Move person up or down in list
        function movePersonInList(groupNumber, index, listType, direction) {
            const list = groups[groupNumber][listType];
            if (direction === 'up' && index > 0) {
                [list[index - 1], list[index]] = [list[index], list[index - 1]];
            } else if (direction === 'down' && index < list.length - 1) {
                [list[index], list[index + 1]] = [list[index + 1], list[index]];
            }
            
            saveData();
            renderGroups();
        }

        // Toggle transfer dropdown
        function toggleTransferDropdown(groupNumber, index, listType, event) {
            event.stopPropagation();
            
            // Close all other dropdowns
            document.querySelectorAll('.transfer-dropdown-content').forEach(dropdown => {
                dropdown.classList.remove('show');
            });
            
            // Toggle current dropdown
            const dropdown = document.getElementById(`transferDropdown_${groupNumber}_${index}_${listType}`);
            dropdown.classList.toggle('show');
        }

        // Global variables for transfer
        let transferData = {
            person: null,
            fromGroup: null,
            toGroup: null,
            lastDuties: null,
            missingPeriods: null,
            positions: {} // { listType: { referencePerson: string, position: 'above'|'below'|'end' } }
        };

        // Transfer person to another group - opens positioning modal
        function transferPerson(fromGroup, index, toGroup, listType) {
            const list = groups[fromGroup][listType];
            const person = list[index];
            
            if (!person) return;
            
            // Store transfer data
            transferData.person = person;
            transferData.fromGroup = fromGroup;
            transferData.toGroup = toGroup;
            transferData.lastDuties = groups[fromGroup].lastDuties?.[person] || null;
            transferData.missingPeriods = groups[fromGroup].missingPeriods?.[person] || null;
            transferData.positions = {};
            
            // Close dropdown
            document.querySelectorAll('.transfer-dropdown-content').forEach(dropdown => {
                dropdown.classList.remove('show');
            });
            
            // Open positioning modal
            openTransferPositionModal();
        }

        // Open transfer position modal
        function openTransferPositionModal() {
            document.getElementById('transferPersonName').textContent = transferData.person;
            document.getElementById('transferFromGroup').textContent = getGroupName(transferData.fromGroup);
            document.getElementById('transferToGroup').textContent = getGroupName(transferData.toGroup);
            
            // Find people from target group who had duty on same days
            const sameDayPeople = findPeopleWithSameDutyDays(transferData.person, transferData.fromGroup, transferData.toGroup);
            
            // Render positioning options for each list type
            renderTransferPositionLists(sameDayPeople);
            
            const modal = new bootstrap.Modal(document.getElementById('transferPositionModal'));
            modal.show();
        }

        // Find people from target group who had duty on same days as the person being transferred
        function findPeopleWithSameDutyDays(person, fromGroup, toGroup) {
            const sameDayPeople = {
                special: [],
                weekend: [],
                semi: [],
                normal: []
            };
            
            // Get all days where person had duty
            const personDutyDays = [];
            for (const [dayKey, assignment] of Object.entries(dutyAssignments)) {
                if (assignment.includes(`${person} (Ομάδα ${fromGroup})`)) {
                    personDutyDays.push(dayKey);
                }
            }
            
            if (personDutyDays.length === 0) {
                return sameDayPeople; // No duty days found
            }
            
            // For each day type, find people from target group who had duty on same days
            const targetGroupData = groups[toGroup] || { special: [], weekend: [], semi: [], normal: [] };
            
            personDutyDays.forEach(dayKey => {
                const dayDate = new Date(dayKey + 'T00:00:00');
                const dayType = getDayType(dayDate);
                let dayTypeCategory = 'normal';
                
                if (dayType === 'special-holiday') {
                    dayTypeCategory = 'special';
                } else if (dayType === 'semi-normal-day') {
                    dayTypeCategory = 'semi';
                } else if (dayType === 'weekend-holiday') {
                    dayTypeCategory = 'weekend';
                }
                
                // Check if anyone from target group had duty on this day
                const assignment = dutyAssignments[dayKey];
                if (assignment) {
                    const targetGroupPeople = targetGroupData[dayTypeCategory] || [];
                    targetGroupPeople.forEach(targetPerson => {
                        if (assignment.includes(`${targetPerson} (Ομάδα ${toGroup})`)) {
                            if (!sameDayPeople[dayTypeCategory].includes(targetPerson)) {
                                sameDayPeople[dayTypeCategory].push(targetPerson);
                            }
                        }
                    });
                }
            });
            
            return sameDayPeople;
        }

        // Render positioning lists for transfer
        function renderTransferPositionLists(sameDayPeople) {
            const container = document.getElementById('transferPositionLists');
            const listTypes = [
                { type: 'special', label: 'Ειδικές Αργίες', icon: 'fa-star' },
                { type: 'weekend', label: 'Σαββατοκύριακα/Αργίες', icon: 'fa-calendar-week' },
                { type: 'semi', label: 'Ημιαργίες', icon: 'fa-calendar-alt' },
                { type: 'normal', label: 'Καθημερινές', icon: 'fa-calendar-day' }
            ];
            
            const targetGroupData = groups[transferData.toGroup] || { special: [], weekend: [], semi: [], normal: [] };
            
            container.innerHTML = listTypes.map(({ type, label, icon }) => {
                const list = targetGroupData[type] || [];
                const sameDayPeopleList = sameDayPeople[type] || [];
                
                let optionsHtml = '';
                
                if (sameDayPeopleList.length > 0) {
                    // Show people who had duty on same days
                    optionsHtml = `
                        <div class="mb-2">
                            <small class="text-muted">Άτομα με υπηρεσία την ίδια ημέρα:</small>
                            <div class="btn-group-vertical w-100" role="group">
                                ${sameDayPeopleList.map(refPerson => {
                                    return `
                                        <div class="btn-group mb-1" role="group">
                                            <button type="button" class="btn btn-outline-primary btn-sm" onclick="setTransferPosition('${type}', '${refPerson.replace(/'/g, "\\'")}', 'above')">
                                                <i class="fas fa-arrow-up me-1"></i>Πάνω από ${refPerson}
                                            </button>
                                            <button type="button" class="btn btn-outline-primary btn-sm" onclick="setTransferPosition('${type}', '${refPerson.replace(/'/g, "\\'")}', 'below')">
                                                <i class="fas fa-arrow-down me-1"></i>Κάτω από ${refPerson}
                                            </button>
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        </div>
                    `;
                }
                
                // Show option to add at end
                optionsHtml += `
                    <div class="mb-2">
                        <button type="button" class="btn btn-outline-secondary btn-sm w-100" onclick="setTransferPosition('${type}', null, 'end')">
                            <i class="fas fa-plus me-1"></i>Προσθήκη στο τέλος
                        </button>
                    </div>
                `;
                
                // Show current selection
                const currentPosition = transferData.positions[type];
                let positionDisplay = '<small class="text-muted">Δεν έχει επιλεγεί</small>';
                if (currentPosition) {
                    if (currentPosition.position === 'end') {
                        positionDisplay = '<small class="text-success"><i class="fas fa-check me-1"></i>Θα προστεθεί στο τέλος</small>';
                    } else {
                        const positionText = currentPosition.position === 'above' ? 'πάνω' : 'κάτω';
                        positionDisplay = `<small class="text-success"><i class="fas fa-check me-1"></i>Θα τοποθετηθεί ${positionText} από ${currentPosition.referencePerson}</small>`;
                    }
                }
                
                return `
                    <div class="card mb-3">
                        <div class="card-header">
                            <i class="fas ${icon} me-2"></i><strong>${label}</strong>
                        </div>
                        <div class="card-body">
                            ${optionsHtml}
                            <div class="mt-2">
                                ${positionDisplay}
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        // Set transfer position for a list type
        function setTransferPosition(listType, referencePerson, position) {
            transferData.positions[listType] = {
                referencePerson: referencePerson,
                position: position
            };
            
            // Re-render to show updated selection
            const sameDayPeople = findPeopleWithSameDutyDays(transferData.person, transferData.fromGroup, transferData.toGroup);
            renderTransferPositionLists(sameDayPeople);
        }

        // Complete the transfer with selected positions
        function completeTransfer() {
            // Remove from current group's all lists
            const allListTypes = ['special', 'weekend', 'semi', 'normal'];
            allListTypes.forEach(lt => {
                const currentList = groups[transferData.fromGroup][lt] || [];
                const currentIndex = currentList.indexOf(transferData.person);
                if (currentIndex !== -1) {
                    currentList.splice(currentIndex, 1);
                }
            });
            
            // Initialize target group if needed
            if (!groups[transferData.toGroup]) {
                groups[transferData.toGroup] = { special: [], weekend: [], semi: [], normal: [], lastDuties: {}, missingPeriods: {} };
            }
            
            // Add to target group with positioning
            allListTypes.forEach(listType => {
                if (!groups[transferData.toGroup][listType]) groups[transferData.toGroup][listType] = [];
                
                const list = groups[transferData.toGroup][listType];
                
                // Remove person if already exists
                const existingIndex = list.indexOf(transferData.person);
                if (existingIndex !== -1) {
                    list.splice(existingIndex, 1);
                }
                
                // Position person according to selection
                const position = transferData.positions[listType];
                if (position) {
                    if (position.position === 'end') {
                        // Add at end
                        list.push(transferData.person);
                    } else if (position.referencePerson) {
                        // Find reference person index
                        const refIndex = list.indexOf(position.referencePerson);
                        if (refIndex !== -1) {
                            if (position.position === 'above') {
                                list.splice(refIndex, 0, transferData.person);
                            } else { // below
                                list.splice(refIndex + 1, 0, transferData.person);
                            }
                        } else {
                            // Reference person not found, add at end
                            list.push(transferData.person);
                        }
                    } else {
                        // No valid position, add at end
                        list.push(transferData.person);
                    }
                } else {
                    // No position selected, add at end
                    list.push(transferData.person);
                }
            });
            
            // Transfer last duties
            if (!groups[transferData.toGroup].lastDuties) groups[transferData.toGroup].lastDuties = {};
            if (transferData.lastDuties) {
                groups[transferData.toGroup].lastDuties[transferData.person] = transferData.lastDuties;
            }
            
            // Transfer missing periods
            if (!groups[transferData.toGroup].missingPeriods) groups[transferData.toGroup].missingPeriods = {};
            if (transferData.missingPeriods) {
                groups[transferData.toGroup].missingPeriods[transferData.person] = transferData.missingPeriods;
            }
            
            // Remove last duties and missing periods from source group if person is completely removed
            const stillInSourceGroup = allListTypes.some(lt => (groups[transferData.fromGroup][lt] || []).includes(transferData.person));
            if (!stillInSourceGroup) {
                if (groups[transferData.fromGroup].lastDuties) {
                    delete groups[transferData.fromGroup].lastDuties[transferData.person];
                }
                if (groups[transferData.fromGroup].missingPeriods) {
                    delete groups[transferData.fromGroup].missingPeriods[transferData.person];
                }
            }
            
            // Close modal
            const modal = bootstrap.Modal.getInstance(document.getElementById('transferPositionModal'));
            modal.hide();
            
            saveData();
            renderGroups();
            updateStatistics();
            
            // Reset transfer data
            transferData = {
                person: null,
                fromGroup: null,
                toGroup: null,
                lastDuties: null,
                missingPeriods: null,
                positions: {}
            };
        }

        // Close dropdowns when clicking outside
        document.addEventListener('click', function(event) {
            if (!event.target.closest('.transfer-dropdown')) {
                document.querySelectorAll('.transfer-dropdown-content').forEach(dropdown => {
                    dropdown.classList.remove('show');
                });
            }
        });

        // Add holiday
        function addHoliday() {
            document.getElementById('holidayDate').value = '';
            document.getElementById('holidayName').value = '';
            const modal = new bootstrap.Modal(document.getElementById('addHolidayModal'));
            modal.show();
        }

        // Save holiday
        function saveHoliday() {
            const date = document.getElementById('holidayDate').value;
            const name = document.getElementById('holidayName').value.trim();
            
            if (!date) {
                alert('Παρακαλώ επιλέξτε ημερομηνία');
                return;
            }
            
            const holidayDate = new Date(date + 'T00:00:00');
            const holidayKey = formatDateKey(holidayDate);
            
            // Check if already exists
            if (holidays.find(h => h.date === holidayKey)) {
                alert('Αυτή η ημερομηνία είναι ήδη σημειωμένη ως αργία');
                return;
            }
            
            holidays.push({
                date: holidayKey,
                name: name || 'Holiday'
            });
            
            saveData();
            renderHolidays();
            renderCalendar();
            
            const modal = bootstrap.Modal.getInstance(document.getElementById('addHolidayModal'));
            modal.hide();
        }

        // Remove holiday
        function removeHoliday(index) {
            if (confirm('Είστε σίγουροι ότι θέλετε να αφαιρέσετε αυτή την αργία;')) {
                holidays.splice(index, 1);
                saveData();
                renderHolidays();
                renderCalendar();
            }
        }

        // Render holidays
        function renderHolidays() {
            const container = document.getElementById('holidaysList');
            if (!container) return;
            
            container.innerHTML = '';
            
            if (holidays.length === 0) {
                container.innerHTML = '<p class="text-muted text-center">Δεν έχουν προστεθεί αργίες ακόμα</p>';
                return;
            }
            
            holidays.sort((a, b) => a.date.localeCompare(b.date));
            
            holidays.forEach((holiday, index) => {
                const holidayDiv = document.createElement('div');
                holidayDiv.className = 'holiday-item';
                const date = new Date(holiday.date + 'T00:00:00');
                holidayDiv.innerHTML = `
                    <div>
                        <strong>${formatDate(date)}</strong>
                        ${holiday.name ? `<span class="text-muted ms-2">- ${holiday.name}</span>` : ''}
                    </div>
                    <button class="btn btn-sm btn-outline-danger" onclick="removeHoliday(${index})">
                        <i class="fas fa-trash"></i>
                    </button>
                `;
                container.appendChild(holidayDiv);
            });
        }

        // Configuration: How many years ahead to calculate recurring special holidays
        const SPECIAL_HOLIDAYS_YEARS_AHEAD = 30; // Calculate for next 30 years

        // Initialize default special holidays based on recurring configuration
        function initializeDefaultSpecialHolidays() {
            const currentYear = new Date().getFullYear();
            const yearsToCalculate = SPECIAL_HOLIDAYS_YEARS_AHEAD;
            const expectedHolidays = new Map(); // Track which dates SHOULD be special holidays with their names
            
            // First, collect all dates that SHOULD be special holidays based on recurring config
            recurringSpecialHolidays.forEach(holidayDef => {
                if (holidayDef.type === 'fixed') {
                    // Fixed date holidays (month + day)
                    for (let year = currentYear; year <= currentYear + yearsToCalculate; year++) {
                        const date = new Date(year, holidayDef.month - 1, holidayDef.day);
                        const dateKey = formatDateKey(date);
                        expectedHolidays.set(dateKey, holidayDef.name);
                    }
                } else if (holidayDef.type === 'easter-relative') {
                    // Movable holidays based on Orthodox Easter
                    for (let year = currentYear; year <= currentYear + yearsToCalculate; year++) {
                        const orthodoxHolidays = calculateOrthodoxHolidays(year);
                        const easterDate = orthodoxHolidays.easterSunday;
                        
                        const holidayDate = new Date(easterDate);
                        holidayDate.setDate(holidayDate.getDate() + (holidayDef.offset || 0));
                        
                        const dateKey = formatDateKey(holidayDate);
                        expectedHolidays.set(dateKey, holidayDef.name);
                    }
                }
            });
            
            // Remove special holidays that are no longer in the recurring configuration
            // (but keep manually added ones if they exist - though currently all are from recurring)
            specialHolidays = specialHolidays.filter(h => {
                // Keep if it's in the expected list OR if it's a manually added one
                // For now, we'll remove all that aren't in expected list since all come from recurring
                return expectedHolidays.has(h.date);
            });
            
            // Add missing holidays from recurring configuration
            expectedHolidays.forEach((holidayName, dateKey) => {
                if (!specialHolidays.some(h => h.date === dateKey)) {
                    specialHolidays.push({
                        date: dateKey,
                        name: holidayName
                    });
                } else {
                    // Update the name if it changed
                    const existing = specialHolidays.find(h => h.date === dateKey);
                    if (existing && existing.name !== holidayName) {
                        existing.name = holidayName;
                    }
                }
            });
            
            // Sort by date
            specialHolidays.sort((a, b) => a.date.localeCompare(b.date));
            // NOTE: Do NOT call saveData() here - it will be called when user makes actual changes
            // This prevents unnecessary Firebase writes on every page load
        }
        
        // Load recurring holidays configuration
        async function loadRecurringHolidaysConfig() {
            try {
                if (window.db) {
                    const db = window.db || firebase.firestore();
                    const user = window.auth?.currentUser;
                    
                    if (user) {
                        const doc = await db.collection('dutyShifts').doc('recurringSpecialHolidays').get();
                        if (doc.exists) {
                            const data = doc.data();
                            recurringSpecialHolidays = data.list || recurringSpecialHolidays;
                        }
                    }
                }
                
                // Fallback to localStorage
                const saved = localStorage.getItem('dutyShiftsRecurringHolidays');
                if (saved) {
                    recurringSpecialHolidays = JSON.parse(saved);
                }
            } catch (error) {
                console.error('Error loading recurring holidays config:', error);
                const saved = localStorage.getItem('dutyShiftsRecurringHolidays');
                if (saved) {
                    recurringSpecialHolidays = JSON.parse(saved);
                }
            }
        }
        
        // Save recurring holidays configuration to Firebase
        async function saveRecurringHolidaysConfig() {
            try {
                if (!window.db) {
                    localStorage.setItem('dutyShiftsRecurringHolidays', JSON.stringify(recurringSpecialHolidays));
                    return;
                }
                
                const db = window.db || firebase.firestore();
                const user = window.auth?.currentUser;
                
                if (!user) {
                    localStorage.setItem('dutyShiftsRecurringHolidays', JSON.stringify(recurringSpecialHolidays));
                    return;
                }
                
                await db.collection('dutyShifts').doc('recurringSpecialHolidays').set({
                    list: recurringSpecialHolidays,
                    lastUpdated: firebase.firestore.FieldValue.serverTimestamp(),
                    updatedBy: user.uid
                });
                
                localStorage.setItem('dutyShiftsRecurringHolidays', JSON.stringify(recurringSpecialHolidays));
            } catch (error) {
                console.error('Error saving recurring holidays config:', error);
                localStorage.setItem('dutyShiftsRecurringHolidays', JSON.stringify(recurringSpecialHolidays));
            }
        }

        // Render special holidays
        function renderSpecialHolidays() {
            const container = document.getElementById('specialHolidaysList');
            if (!container) return;
            
            container.innerHTML = '';
            
            if (specialHolidays.length === 0) {
                container.innerHTML = '<p class="text-muted text-center">Δεν έχουν προστεθεί ειδικές αργίες ακόμα</p>';
                return;
            }
            
            specialHolidays.sort((a, b) => a.date.localeCompare(b.date));
            
            specialHolidays.forEach((holiday, index) => {
                const holidayDiv = document.createElement('div');
                holidayDiv.className = 'holiday-item';
                holidayDiv.style.borderLeft = '4px solid #FFC107';
                const date = new Date(holiday.date + 'T00:00:00');
                holidayDiv.innerHTML = `
                    <div>
                        <strong><i class="fas fa-star text-warning me-1"></i>${formatDate(date)}</strong>
                        ${holiday.name ? `<span class="text-muted ms-2">- ${holiday.name}</span>` : ''}
                    </div>
                    <button class="btn btn-sm btn-outline-danger" onclick="removeSpecialHoliday(${index})">
                        <i class="fas fa-trash"></i>
                    </button>
                `;
                container.appendChild(holidayDiv);
            });
        }

        // Add special holiday
        function addSpecialHoliday() {
            document.getElementById('specialHolidayDate').value = '';
            document.getElementById('specialHolidayName').value = '';
            const modal = new bootstrap.Modal(document.getElementById('addSpecialHolidayModal'));
            modal.show();
        }

        // Save special holiday
        function saveSpecialHoliday() {
            const date = document.getElementById('specialHolidayDate').value;
            const name = document.getElementById('specialHolidayName').value.trim();
            
            if (!date) {
                alert('Παρακαλώ επιλέξτε ημερομηνία');
                return;
            }
            
            const dateKey = formatDateKey(new Date(date + 'T00:00:00'));
            
            // Check if already exists
            if (specialHolidays.some(h => h.date === dateKey)) {
                alert('Αυτή η ημερομηνία είναι ήδη σημειωμένη ως ειδική αργία');
                return;
            }
            
            specialHolidays.push({
                date: dateKey,
                name: name || ''
            });
            
            // Sort by date
            specialHolidays.sort((a, b) => a.date.localeCompare(b.date));
            
            saveData();
            renderCalendar();
            
            const modal = bootstrap.Modal.getInstance(document.getElementById('addSpecialHolidayModal'));
            modal.hide();
        }

        // Remove special holiday (kept for backward compatibility, but not used in UI)
        function removeSpecialHoliday(index) {
            if (confirm('Είστε σίγουροι ότι θέλετε να αφαιρέσετε αυτή την ειδική αργία;')) {
                specialHolidays.splice(index, 1);
                saveData();
                renderCalendar();
            }
        }

        // Toggle recurring holiday fields based on type
        function toggleRecurringHolidayFields() {
            const type = document.getElementById('recurringHolidayType').value;
            const fixedFields = document.getElementById('fixedDateFields');
            const fixedDayFields = document.getElementById('fixedDayFields');
            const easterFields = document.getElementById('easterOffsetFields');
            
            if (type === 'fixed') {
                fixedFields.style.display = 'block';
                fixedDayFields.style.display = 'block';
                easterFields.style.display = 'none';
            } else {
                fixedFields.style.display = 'none';
                fixedDayFields.style.display = 'none';
                easterFields.style.display = 'block';
            }
        }

        // Render recurring holidays configuration
        function renderRecurringHolidays() {
            const container = document.getElementById('recurringHolidaysList');
            if (!container) return;
            
            container.innerHTML = '';
            
            if (recurringSpecialHolidays.length === 0) {
                container.innerHTML = '<p class="text-muted text-center">Δεν έχουν οριστεί επαναλαμβανόμενες αργίες</p>';
                return;
            }
            
            recurringSpecialHolidays.forEach((holiday, index) => {
                const holidayDiv = document.createElement('div');
                holidayDiv.className = 'holiday-item';
                holidayDiv.style.borderLeft = '4px solid #17a2b8';
                
                let displayText = '';
                if (holiday.type === 'fixed') {
                    const monthNames = ['Ιανουαρίου', 'Φεβρουαρίου', 'Μαρτίου', 'Απριλίου', 'Μαΐου', 'Ιουνίου', 
                                       'Ιουλίου', 'Αυγούστου', 'Σεπτεμβρίου', 'Οκτωβρίου', 'Νοεμβρίου', 'Δεκεμβρίου'];
                    displayText = `${holiday.day} ${monthNames[holiday.month - 1]} - ${holiday.name}`;
                } else if (holiday.type === 'easter-relative') {
                    const offsetText = holiday.offset === 0 ? 'Πάσχα' : 
                                      holiday.offset === -1 ? '1 ημέρα πριν το Πάσχα' :
                                      holiday.offset === 1 ? '1 ημέρα μετά το Πάσχα' :
                                      `${holiday.offset} ημέρες ${holiday.offset > 0 ? 'μετά' : 'πριν'} το Πάσχα`;
                    displayText = `${holiday.name} (${offsetText})`;
                }
                
                holidayDiv.innerHTML = `
                    <div>
                        <strong><i class="fas fa-repeat text-info me-1"></i>${displayText}</strong>
                    </div>
                    <button class="btn btn-sm btn-outline-danger" onclick="removeRecurringHoliday(${index})">
                        <i class="fas fa-trash"></i>
                    </button>
                `;
                container.appendChild(holidayDiv);
            });
        }

        // Add recurring holiday
        function addRecurringHoliday() {
            document.getElementById('recurringHolidayType').value = 'fixed';
            document.getElementById('recurringHolidayMonth').value = '';
            document.getElementById('recurringHolidayDay').value = '';
            document.getElementById('recurringHolidayEasterOffset').value = '0';
            document.getElementById('recurringHolidayName').value = '';
            toggleRecurringHolidayFields();
            const modal = new bootstrap.Modal(document.getElementById('addRecurringHolidayModal'));
            modal.show();
        }

        // Save recurring holiday
        function saveRecurringHoliday() {
            const type = document.getElementById('recurringHolidayType').value;
            const name = document.getElementById('recurringHolidayName').value.trim();
            
            if (!name) {
                alert('Παρακαλώ εισάγετε όνομα');
                return;
            }
            
            let holidayDef = { name: name, type: type };
            
            if (type === 'fixed') {
                const month = parseInt(document.getElementById('recurringHolidayMonth').value);
                const day = parseInt(document.getElementById('recurringHolidayDay').value);
                
                if (!month || !day) {
                    alert('Παρακαλώ επιλέξτε μήνα και ημέρα');
                    return;
                }
                
                holidayDef.month = month;
                holidayDef.day = day;
            } else if (type === 'easter-relative') {
                const offset = parseInt(document.getElementById('recurringHolidayEasterOffset').value) || 0;
                holidayDef.offset = offset;
            }
            
            recurringSpecialHolidays.push(holidayDef);
            saveRecurringHolidaysConfig();
            renderRecurringHolidays();
            
            // Regenerate special holidays for all years
            initializeDefaultSpecialHolidays();
            renderCalendar();
            
            const modal = bootstrap.Modal.getInstance(document.getElementById('addRecurringHolidayModal'));
            modal.hide();
        }

        // Remove recurring holiday
        function removeRecurringHoliday(index) {
            if (confirm('Είστε σίγουροι ότι θέλετε να αφαιρέσετε αυτή την επαναλαμβανόμενη αργία;')) {
                recurringSpecialHolidays.splice(index, 1);
                saveRecurringHolidaysConfig();
                renderRecurringHolidays();
                
                // Regenerate special holidays
                initializeDefaultSpecialHolidays();
                renderCalendar();
            }
        }

        // Calculate Orthodox Easter (returns the date of Easter Sunday)
        // Orthodox Easter is calculated using the Julian calendar
        function calculateOrthodoxEaster(year) {
            // Algorithm for calculating Orthodox Easter (Julian calendar)
            const a = year % 19;
            const b = year % 7;
            const c = year % 4;
            
            const d = (19 * a + 15) % 30;
            const e = (2 * c + 4 * b - d + 34) % 7;
            const f = d + e + 114;
            
            const month = Math.floor(f / 31);
            const day = (f % 31) + 1;
            
            // Convert to Gregorian calendar (add 13 days for 20th-21st century)
            const easterDate = new Date(year, month - 1, day);
            easterDate.setDate(easterDate.getDate() + 13);
            
            return easterDate;
        }

        // Calculate all Orthodox holidays based on Easter
        function calculateOrthodoxHolidays(year) {
            const easterSunday = calculateOrthodoxEaster(year);
            const holidays = {};
            
            // Clean Monday (48 days before Easter)
            const cleanMonday = new Date(easterSunday);
            cleanMonday.setDate(cleanMonday.getDate() - 48);
            holidays['cleanMonday'] = cleanMonday;
            
            // Palm Sunday (7 days before Easter)
            const palmSunday = new Date(easterSunday);
            palmSunday.setDate(palmSunday.getDate() - 7);
            holidays['palmSunday'] = palmSunday;
            
            // Good Friday (2 days before Easter)
            const goodFriday = new Date(easterSunday);
            goodFriday.setDate(goodFriday.getDate() - 2);
            holidays['goodFriday'] = goodFriday;
            
            // Great Saturday (1 day before Easter)
            const greatSaturday = new Date(easterSunday);
            greatSaturday.setDate(greatSaturday.getDate() - 1);
            holidays['greatSaturday'] = greatSaturday;
            
            // Easter Sunday (Great Sunday)
            holidays['easterSunday'] = easterSunday;
            
            // Easter Monday (1 day after Easter)
            const easterMonday = new Date(easterSunday);
            easterMonday.setDate(easterMonday.getDate() + 1);
            holidays['easterMonday'] = easterMonday;
            
            // Ascension Day (39 days after Easter)
            const ascensionDay = new Date(easterSunday);
            ascensionDay.setDate(ascensionDay.getDate() + 39);
            holidays['ascensionDay'] = ascensionDay;
            
            // Pentecost (49 days after Easter)
            const pentecost = new Date(easterSunday);
            pentecost.setDate(pentecost.getDate() + 49);
            holidays['pentecost'] = pentecost;
            
            // Whit Monday (50 days after Easter)
            const whitMonday = new Date(easterSunday);
            whitMonday.setDate(whitMonday.getDate() + 50);
            holidays['whitMonday'] = whitMonday;
            
            return holidays;
        }

        // Check if date is a special holiday (checks both specialHolidays array and recurring configuration)
        function isSpecialHoliday(date) {
            const key = formatDateKey(date);
            
            // First check the specialHolidays array (for current/future years)
            if (specialHolidays.some(h => h.date === key)) {
                return true;
            }
            
            // Also check against recurring configuration (works for ANY year, including past years)
            const year = date.getFullYear();
            const month = date.getMonth() + 1; // 1-12
            const day = date.getDate();
            
            for (const holidayDef of recurringSpecialHolidays) {
                if (holidayDef.type === 'fixed') {
                    // Fixed date holidays (month + day)
                    if (holidayDef.month === month && holidayDef.day === day) {
                        return true;
                    }
                } else if (holidayDef.type === 'easter-relative') {
                    // Movable holidays based on Orthodox Easter
                    const orthodoxHolidays = calculateOrthodoxHolidays(year);
                    const easterDate = orthodoxHolidays.easterSunday;
                    const holidayDate = new Date(easterDate);
                    holidayDate.setDate(holidayDate.getDate() + (holidayDef.offset || 0));
                    
                    // Check if the date matches
                    if (formatDateKey(holidayDate) === key) {
                        return true;
                    }
                }
            }
            
            return false;
        }

        // Check if date is holiday (including automatically detected Orthodox/Cyprus holidays)
        function isHoliday(date) {
            const key = formatDateKey(date);
            // Check user-defined holidays
            if (holidays.some(h => h.date === key)) {
                return true;
            }
            // Check automatically detected Orthodox/Cyprus holidays
            return isOrthodoxOrCyprusHoliday(date);
        }

        // Check if date is an Orthodox or Cyprus Greek holiday (automatic detection)
        function isOrthodoxOrCyprusHoliday(date) {
            const month = date.getMonth() + 1; // 1-12
            const day = date.getDate();
            const year = date.getFullYear();
            const dateKey = formatDateKey(date);
            
            // Fixed Orthodox/Cyprus holidays
            if (month === 1 && day === 1) return true;  // New Year's Day
            if (month === 1 && day === 6) return true;  // Epiphany/Theophany
            if (month === 3 && day === 25) return true; // Annunciation / Greek Independence Day
            if (month === 4 && day === 1) return true;  // EOKA Liberation Struggle Day
            if (month === 5 && day === 1) return true;  // Labor Day
            if (month === 8 && day === 15) return true; // Dormition of the Theotokos
            if (month === 10 && day === 1) return true; // Cyprus Independence Day
            if (month === 10 && day === 28) return true; // Ochi Day
            // December 24 is a special holiday, not a normal holiday
            if (month === 12 && day === 25) return true; // Christmas (Nativity of Christ)
            if (month === 12 && day === 26) return true; // Synaxis of the Theotokos
            if (month === 12 && day === 31) return true; // New Year's Eve
            
            // Orthodox holidays based on Easter (excluding Ascension and Pentecost)
            const orthodoxHolidays = calculateOrthodoxHolidays(year);
            const excludedHolidays = ['ascensionDay', 'pentecost']; // Holidays to exclude
            for (const key in orthodoxHolidays) {
                if (!excludedHolidays.includes(key) && dateKey === formatDateKey(orthodoxHolidays[key])) {
                    return true;
                }
            }
            
            return false;
        }

        // Get Orthodox/Cyprus holiday name for a date (automatic detection)
        function getOrthodoxHolidayNameAuto(date) {
            if (!isOrthodoxOrCyprusHoliday(date)) return null;
            
            const month = date.getMonth() + 1;
            const day = date.getDate();
            const year = date.getFullYear();
            const dateKey = formatDateKey(date);
            
            // Fixed Orthodox holidays
            if (month === 1 && day === 1) return 'Πρωτοχρονιά';
            if (month === 1 && day === 6) return 'Θεοφάνια';
            if (month === 3 && day === 25) return 'Ευαγγελισμός';
            if (month === 4 && day === 1) return 'ΕΟΚΑ';
            if (month === 5 && day === 1) return 'Πρωτομαγιά';
            if (month === 8 && day === 15) return 'Κοίμηση';
            if (month === 10 && day === 1) return 'Ανεξαρτησία';
            if (month === 10 && day === 28) return 'Όχι';
            // December 24 is a special holiday, name comes from special holidays list
            if (month === 12 && day === 25) return 'Χριστούγεννα';
            if (month === 12 && day === 26) return 'Σύναξης';
            if (month === 12 && day === 31) return 'Παραμονή';
            
            // Orthodox holidays based on Easter (excluding Ascension and Pentecost)
            const orthodoxHolidays = calculateOrthodoxHolidays(year);
            
            if (dateKey === formatDateKey(orthodoxHolidays.cleanMonday)) return 'Καθαρά Δευτέρα';
            if (dateKey === formatDateKey(orthodoxHolidays.palmSunday)) return 'Κυριακή Βαΐων';
            if (dateKey === formatDateKey(orthodoxHolidays.goodFriday)) return 'Μ. Παρασκευή';
            if (dateKey === formatDateKey(orthodoxHolidays.greatSaturday)) return 'Μ. Σάββατο';
            if (dateKey === formatDateKey(orthodoxHolidays.easterSunday)) return 'Πάσχα';
            if (dateKey === formatDateKey(orthodoxHolidays.easterMonday)) return 'Δευτέρα Πάσχα';
            if (dateKey === formatDateKey(orthodoxHolidays.whitMonday)) return 'Αγίου Πνεύματος';
            
            return null;
        }

        // Check if date is weekend
        function isWeekend(date) {
            const day = date.getDay();
            return day === 0 || day === 6; // Sunday or Saturday
        }

        // Get day type
        function getDayType(date) {
            // Special holidays have highest priority
            if (isSpecialHoliday(date)) {
                return 'special-holiday';
            }
            
            if (isHoliday(date)) {
                return 'weekend-holiday';
            }
            
            if (isWeekend(date)) {
                return 'weekend-holiday';
            }
            
            // Special case: December 30th should be normal day (unless it's Friday or weekend)
            // Don't classify it as semi-normal just because next day (Dec 31) is a special holiday
            const isDecember30 = date.getMonth() === 11 && date.getDate() === 30;
            
            // For December 30th, check if it's Friday (semi-normal) or return normal
            if (isDecember30) {
                if (date.getDay() === 5) {
                    return 'semi-normal-day'; // Friday
                }
                // December 30th is normal day (unless it's Friday or weekend, which is already checked above)
                return 'normal-day';
            }
            
            // For all other days, check if next day is weekend, holiday, or special holiday
            const nextDay = new Date(date);
            nextDay.setDate(nextDay.getDate() + 1);
            
            if (isWeekend(nextDay) || isHoliday(nextDay) || isSpecialHoliday(nextDay)) {
                return 'semi-normal-day';
            }
            
            // Check if it's Friday
            if (date.getDay() === 5) {
                return 'semi-normal-day';
            }
            
            return 'normal-day';
        }

        // Format date key
        function formatDateKey(date) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        // Format date for display
        function formatDate(date) {
            return date.toLocaleDateString('el-GR', { 
                year: 'numeric', 
                month: 'long', 
                day: 'numeric',
                weekday: 'long'
            });
        }

        // Get Greek day name (short)
        function getGreekDayName(date) {
            const days = ['Κυριακή', 'Δευτέρα', 'Τρίτη', 'Τετάρτη', 'Πέμπτη', 'Παρασκευή', 'Σάββατο'];
            return days[date.getDay()];
        }
        
        // Get Greek day name in uppercase for Excel
        function getGreekDayNameUppercase(date) {
            const days = ['ΚΥΡΙΑΚΗ', 'ΔΕΥΤΕΡΑ', 'ΤΡΙΤΗ', 'ΤΕΤΑΡΤΗ', 'ΠΕΜΠΤΗ', 'ΠΑΡΑΣΚΕΥΗ', 'ΣΑΒΒΑΤΟ'];
            return days[date.getDay()];
        }

        // Get Greek month name
        function getGreekMonthName(date) {
            const months = ['Ιανουαρίου', 'Φεβρουαρίου', 'Μαρτίου', 'Απριλίου', 'Μαΐου', 'Ιουνίου',
                          'Ιουλίου', 'Αυγούστου', 'Σεπτεμβρίου', 'Οκτωβρίου', 'Νοεμβρίου', 'Δεκεμβρίου'];
            return months[date.getMonth()];
        }

        // Get day type background color for PDF
        function getDayTypeColor(dayType) {
            const colors = {
                'normal-day': [232, 245, 233],      // #E8F5E9 - light green
                'semi-normal-day': [255, 249, 196], // #FFF9C4 - light yellow
                'weekend-holiday': [255, 224, 178],  // #FFE0B2 - light orange
                'special-holiday': [225, 190, 231]   // #E1BEE7 - light purple
            };
            return colors[dayType] || [255, 255, 255]; // Default white
        }

        // Show Excel preview before generating files
        function showExcelPreview() {
            const year = currentDate.getFullYear();
            const month = currentDate.getMonth();
            const monthName = getGreekMonthName(currentDate);
            
            // Get all days of the month
            const firstDay = new Date(year, month, 1);
            const lastDay = new Date(year, month + 1, 0);
            const daysInMonth = lastDay.getDate();
            
            const previewContent = document.getElementById('excelPreviewContent');
            previewContent.innerHTML = '';
            
            let hasAnyGroup = false;
            
            // Generate preview for each group
            for (let groupNum = 1; groupNum <= 4; groupNum++) {
                const groupName = getGroupName(groupNum);
                const groupData = groups[groupNum];
                
                // Skip if group has no people
                if (!groupData || (!groupData.special?.length && !groupData.weekend?.length && !groupData.semi?.length && !groupData.normal?.length)) {
                    continue;
                }
                
                hasAnyGroup = true;
                
                // Create preview table for this group
                const groupPreview = document.createElement('div');
                groupPreview.className = 'mb-4';
                groupPreview.innerHTML = `
                    <h5 class="mb-3" style="color: #428BCA;">
                        <i class="fas fa-users me-2"></i>${groupName} - ${monthName} ${year}
                    </h5>
                    <div class="table-responsive">
                        <table class="table table-bordered" style="font-size: 12px;">
                            <thead>
                                <tr style="background-color: #428BCA; color: white;">
                                    <th style="width: 12%; text-align: center; padding: 8px;">ΗΜΕΡ.</th>
                                    <th style="width: 15%; text-align: center; padding: 8px;">ΗΜΕΡΑ</th>
                                    <th style="width: 30%; text-align: center; padding: 8px;">ΟΝΟΜΑΤΕΠΩΝΥΜΟ</th>
                                </tr>
                            </thead>
                            <tbody id="previewGroup${groupNum}">
                                <!-- Rows will be inserted here -->
                            </tbody>
                        </table>
                    </div>
                `;
                previewContent.appendChild(groupPreview);
                
                const tbody = document.getElementById(`previewGroup${groupNum}`);
                
                // Add data rows
                for (let day = 1; day <= daysInMonth; day++) {
                    const date = new Date(year, month, day);
                    const dayKey = formatDateKey(date);
                    const dayType = getDayType(date);
                    const dayName = getGreekDayNameUppercase(date);
                    
                    // Get assignment for this group
                    const assignment = dutyAssignments[dayKey] || '';
                    let personName = '';
                    
                    if (assignment) {
                        // Extract person name for this group
                        const parts = assignment.split(',').map(p => p.trim()).filter(p => p);
                        for (const part of parts) {
                            const match = part.match(/^(.+?)\s*\(Ομάδα\s*(\d+)\)\s*$/);
                            if (match && parseInt(match[2]) === groupNum) {
                                personName = match[1].trim().replace(/^,+\s*/, '').replace(/\s*,+$/, '');
                                break;
                            }
                        }
                    }
                    
                    // Format date as DD/MM/YYYY
                    const dateStr = `${String(day).padStart(2, '0')}/${String(month + 1).padStart(2, '0')}/${year}`;
                    
                    // Get color for this day type
                    const color = getDayTypeColor(dayType);
                    const rgbColor = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                    
                    const row = document.createElement('tr');
                    row.style.height = '22px';
                    row.innerHTML = `
                        <td style="padding: 4px; border: 1px solid #ddd; background-color: ${rgbColor} !important;">${dateStr}</td>
                        <td style="padding: 4px; border: 1px solid #ddd; background-color: ${rgbColor} !important;">${dayName}</td>
                        <td style="padding: 4px; border: 1px solid #ddd; background-color: ${rgbColor} !important;">${personName || ''}</td>
                    `;
                    tbody.appendChild(row);
                }
            }
            
            // Show message if no groups have data
            const generateBtn = document.getElementById('generateExcelBtn');
            if (!hasAnyGroup) {
                previewContent.innerHTML = `
                    <div class="alert alert-warning">
                        <i class="fas fa-exclamation-triangle me-2"></i>
                        Δεν υπάρχουν ομάδες με άτομα για να δημιουργηθούν Excel αρχεία.
                    </div>
                `;
                if (generateBtn) {
                    generateBtn.disabled = true;
                }
            } else {
                if (generateBtn) {
                    generateBtn.disabled = false;
                }
            }
            
            // Show modal
            const modal = new bootstrap.Modal(document.getElementById('excelPreviewModal'));
            modal.show();
        }

        // Generate Excel files for current month for all groups
        async function generateExcelFilesForCurrentMonth(skipPreview = false) {
            try {
                const year = currentDate.getFullYear();
                const month = currentDate.getMonth();
                const monthName = getGreekMonthName(currentDate);
                
                // Get all days of the month
                const firstDay = new Date(year, month, 1);
                const lastDay = new Date(year, month + 1, 0);
                const daysInMonth = lastDay.getDate();
                
                // Show loading message
                const loadingAlert = document.createElement('div');
                loadingAlert.className = 'alert alert-info position-fixed top-50 start-50 translate-middle';
                loadingAlert.style.zIndex = '9999';
                loadingAlert.innerHTML = '<i class="fas fa-spinner fa-spin me-2"></i>Δημιουργία Excel αρχείων...';
                document.body.appendChild(loadingAlert);
                
                // Check if ExcelJS is available, otherwise fall back to SheetJS
                const useExcelJS = typeof ExcelJS !== 'undefined';
                
                // Generate Excel file for each group
                for (let groupNum = 1; groupNum <= 4; groupNum++) {
                    const groupName = getGroupName(groupNum);
                    const groupData = groups[groupNum];
                    
                    // Skip if group has no people
                    if (!groupData || (!groupData.special?.length && !groupData.weekend?.length && !groupData.semi?.length && !groupData.normal?.length)) {
                        continue;
                    }
                    
                    if (useExcelJS) {
                        // Use ExcelJS for better styling support
                        const workbook = new ExcelJS.Workbook();
                        const worksheet = workbook.addWorksheet('Υπηρεσίες');
                        
                        // Set title - merge cells A1 through C1
                        worksheet.mergeCells('A1:C1');
                        const titleCell = worksheet.getCell('A1');
                        titleCell.value = `ΥΠΗΡΕΣΙΑ ${groupName} ΜΗΝΟΣ ${monthName.toUpperCase()} ${year}`;
                        titleCell.font = { 
                            name: 'Arial', 
                            bold: true, 
                            size: 12 
                        };
                        titleCell.alignment = { 
                            horizontal: 'center', 
                            vertical: 'middle' 
                        };
                        titleCell.fill = {
                            type: 'pattern',
                            pattern: 'solid',
                            fgColor: { argb: 'FF428BCA' } // Blue background like in photo
                        };
                        titleCell.font.color = { argb: 'FFFFFFFF' }; // White text
                        // Add borders to title cell
                        titleCell.border = {
                            top: { style: 'thick' },
                            left: { style: 'thick' },
                            bottom: { style: 'thick' },
                            right: { style: 'thick' }
                        };
                        worksheet.getRow(1).height = 22;
                        
                        // Empty row
                        worksheet.getRow(2).height = 5;
                        
                        // Header row
                        const headerRow = worksheet.getRow(3);
                        headerRow.getCell(1).value = 'ΗΜΕΡ.';
                        headerRow.getCell(2).value = 'ΗΜΕΡΑ';
                        headerRow.getCell(3).value = 'ΟΝΟΜΑΤΕΠΩΝΥΜΟ';
                        
                        // Style each header cell individually
                        ['A3', 'B3', 'C3'].forEach(cellRef => {
                            const cell = worksheet.getCell(cellRef);
                            cell.font = { 
                                name: 'Arial', 
                                bold: true, 
                                size: 12,
                                color: { argb: 'FFFFFFFF' } // White text
                            };
                            cell.fill = {
                                type: 'pattern',
                                pattern: 'solid',
                                fgColor: { argb: 'FF428BCA' } // Blue background
                            };
                            cell.alignment = { 
                                horizontal: 'center', 
                                vertical: 'middle' 
                            };
                            // Add borders to header cells
                            cell.border = {
                                top: { style: 'thick' },
                                left: { style: 'thin' },
                                bottom: { style: 'thick' },
                                right: { style: 'thin' }
                            };
                        });
                        // Add thick left and right borders to first and last header cells
                        worksheet.getCell('A3').border.left = { style: 'thick' };
                        worksheet.getCell('C3').border.right = { style: 'thick' };
                        headerRow.height = 22;
                        
                        // Set column widths
                        worksheet.getColumn(1).width = 12;
                        worksheet.getColumn(2).width = 15;
                        worksheet.getColumn(3).width = 30;
                        
                        // Data rows
                        for (let day = 1; day <= daysInMonth; day++) {
                            const date = new Date(year, month, day);
                            const dayKey = formatDateKey(date);
                            const dayType = getDayType(date);
                            const dayName = getGreekDayNameUppercase(date); // Use uppercase
                            
                            // Get assignment for this group
                            const assignment = dutyAssignments[dayKey] || '';
                            let personName = '';
                            
                            if (assignment) {
                                // Extract person name for this group - split by comma first to handle properly
                                const parts = assignment.split(',').map(p => p.trim()).filter(p => p);
                                for (const part of parts) {
                                    const match = part.match(/^(.+?)\s*\(Ομάδα\s*(\d+)\)\s*$/);
                                    if (match && parseInt(match[2]) === groupNum) {
                                        // Remove any leading/trailing commas from the name
                                        personName = match[1].trim().replace(/^,+\s*/, '').replace(/\s*,+$/, '');
                                        break;
                                    }
                                }
                            }
                            
                            // Format date as DD/MM/YYYY
                            const dateStr = `${String(day).padStart(2, '0')}/${String(month + 1).padStart(2, '0')}/${year}`;
                            
                            const row = worksheet.getRow(day + 3); // +3 for title, empty, header rows
                            row.getCell(1).value = dateStr;
                            row.getCell(2).value = dayName;
                            row.getCell(3).value = personName;
                            
                            // Apply color based on day type
                            const color = getDayTypeColor(dayType);
                            const hexColor = 'FF' + color.map(c => c.toString(16).padStart(2, '0')).join('').toUpperCase();
                            
                            // Style each cell in the row
                            const isFirstDataRow = day === 1;
                            const isLastDataRow = day === daysInMonth;
                            
                            [1, 2, 3].forEach(colNum => {
                                const cell = row.getCell(colNum);
                                cell.fill = {
                                    type: 'pattern',
                                    pattern: 'solid',
                                    fgColor: { argb: hexColor }
                                };
                                cell.font = { 
                                    name: 'Arial', 
                                    size: 12 
                                };
                                cell.alignment = { 
                                    horizontal: 'left', 
                                    vertical: 'middle' 
                                };
                                
                                // Add borders - thick on outside, thin on inside
                                const isFirstCol = colNum === 1;
                                const isLastCol = colNum === 3;
                                
                                cell.border = {
                                    top: isFirstDataRow ? { style: 'thick' } : { style: 'thin' },
                                    bottom: isLastDataRow ? { style: 'thick' } : { style: 'thin' },
                                    left: isFirstCol ? { style: 'thick' } : { style: 'thin' },
                                    right: isLastCol ? { style: 'thick' } : { style: 'thin' }
                                };
                            });
                            
                            row.height = 22;
                        }
                        
                        // Generate file name
                        const fileName = `YPHRESIA_${groupName.replace(/[^a-zA-Z0-9]/g, '_')}_${monthName.replace(/[^a-zA-Z0-9]/g, '_')}_${year}.xlsx`;
                        
                        // Write file
                        const buffer = await workbook.xlsx.writeBuffer();
                        const blob = new Blob([buffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
                        const url = URL.createObjectURL(blob);
                        const link = document.createElement('a');
                        link.href = url;
                        link.download = fileName;
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        URL.revokeObjectURL(url);
                    } else {
                        // Fallback to SheetJS (limited styling)
                        const wb = XLSX.utils.book_new();
                        const data = [];
                        const rowDayTypes = [];
                        
                        data.push([`ΥΠΗΡΕΣΙΑ ${groupName} ΜΗΝΟΣ ${monthName.toUpperCase()} ${year}`]);
                        data.push([]);
                        rowDayTypes.push(null, null);
                        
                        data.push(['ΗΜΕΡ.', 'ΗΜΕΡΑ', 'ΟΝΟΜΑΤΕΠΩΝΥΜΟ']);
                        rowDayTypes.push(null);
                        
                        for (let day = 1; day <= daysInMonth; day++) {
                            const date = new Date(year, month, day);
                            const dayKey = formatDateKey(date);
                            const dayType = getDayType(date);
                            const dayName = getGreekDayNameUppercase(date); // Use uppercase
                            
                            const assignment = dutyAssignments[dayKey] || '';
                            let personName = '';
                            
                            if (assignment) {
                                const parts = assignment.split(',').map(p => p.trim()).filter(p => p);
                                for (const part of parts) {
                                    const match = part.match(/^(.+?)\s*\(Ομάδα\s*(\d+)\)\s*$/);
                                    if (match && parseInt(match[2]) === groupNum) {
                                        personName = match[1].trim().replace(/^,+\s*/, '').replace(/\s*,+$/, '');
                                        break;
                                    }
                                }
                            }
                            
                            const dateStr = `${String(day).padStart(2, '0')}/${String(month + 1).padStart(2, '0')}/${year}`;
                            data.push([dateStr, dayName, personName]);
                            rowDayTypes.push(dayType);
                        }
                        
                        const ws = XLSX.utils.aoa_to_sheet(data);
                        ws['!cols'] = [{ wch: 12 }, { wch: 15 }, { wch: 30 }];
                        if (!ws['!merges']) ws['!merges'] = [];
                        ws['!merges'].push({ s: { r: 0, c: 0 }, e: { r: 0, c: 2 } });
                        
                        // Style title row (row 1)
                        const titleCell = 'A1';
                        if (!ws[titleCell]) ws[titleCell] = { t: 's', v: data[0][0] || '' };
                        if (!ws[titleCell].s) ws[titleCell].s = {};
                        ws[titleCell].s.font = { name: 'Arial', bold: true, sz: 12, color: { rgb: 'FFFFFF' } };
                        ws[titleCell].s.fill = { fgColor: { rgb: '428BCA' }, patternType: 'solid' };
                        ws[titleCell].s.alignment = { horizontal: 'center', vertical: 'center' };
                        
                        // Style header row (row 3)
                        const headerRow = 2; // 0-indexed, so row 3 is index 2
                        ['A', 'B', 'C'].forEach((col, idx) => {
                            const cellRef = col + (headerRow + 1);
                            if (!ws[cellRef]) ws[cellRef] = { t: 's', v: data[headerRow][idx] || '' };
                            if (!ws[cellRef].s) ws[cellRef].s = {};
                            ws[cellRef].s.font = { name: 'Arial', bold: true, sz: 12, color: { rgb: 'FFFFFF' } };
                            ws[cellRef].s.fill = { fgColor: { rgb: '428BCA' }, patternType: 'solid' };
                            ws[cellRef].s.alignment = { horizontal: 'center', vertical: 'center' };
                        });
                        
                        // Apply colors and fonts to data rows
                        for (let rowIdx = 3; rowIdx < rowDayTypes.length; rowIdx++) {
                            const dayType = rowDayTypes[rowIdx];
                            if (!dayType) continue;
                            
                            const color = getDayTypeColor(dayType);
                            const hexColor = color.map(c => c.toString(16).padStart(2, '0')).join('').toUpperCase();
                            const excelRow = rowIdx + 1;
                            
                            ['A', 'B', 'C'].forEach((col, colIdx) => {
                                const cellRef = col + excelRow;
                                if (!ws[cellRef]) {
                                    ws[cellRef] = { t: 's', v: data[rowIdx] ? (data[rowIdx][colIdx] || '') : '' };
                                }
                                if (!ws[cellRef].s) ws[cellRef].s = {};
                                ws[cellRef].s.fill = { fgColor: { rgb: hexColor }, patternType: 'solid' };
                                ws[cellRef].s.font = { name: 'Arial', sz: 12 };
                                ws[cellRef].s.alignment = { horizontal: 'left', vertical: 'center' };
                            });
                        }
                        
                        XLSX.utils.book_append_sheet(wb, ws, 'Υπηρεσίες');
                        const fileName = `YPHRESIA_${groupName.replace(/[^a-zA-Z0-9]/g, '_')}_${monthName.replace(/[^a-zA-Z0-9]/g, '_')}_${year}.xlsx`;
                        XLSX.writeFile(wb, fileName);
                    }
                }
                
                // Remove loading message
                if (document.body.contains(loadingAlert)) {
                    document.body.removeChild(loadingAlert);
                }
                
                // Close preview modal if it's open
                if (skipPreview) {
                    const previewModal = bootstrap.Modal.getInstance(document.getElementById('excelPreviewModal'));
                    if (previewModal) {
                        previewModal.hide();
                    }
                }
                
                alert('Τα Excel αρχεία δημιουργήθηκαν επιτυχώς!');
            } catch (error) {
                console.error('Error generating Excel files:', error);
                alert('Σφάλμα κατά τη δημιουργία των Excel αρχείων: ' + error.message);
                // Remove loading message if still present
                const loadingAlert = document.querySelector('.alert.position-fixed');
                if (loadingAlert) {
                    document.body.removeChild(loadingAlert);
                }
            }
        }


        // Generate a consistent color for a person based on their name
        function getPersonColor(personName) {
            // Create a hash from the person's name
            let hash = 0;
            for (let i = 0; i < personName.length; i++) {
                hash = personName.charCodeAt(i) + ((hash << 5) - hash);
            }
            
            // Generate a color from the hash (bright, distinct colors)
            const hue = Math.abs(hash) % 360;
            // Use high saturation and medium lightness for vibrant colors
            return `hsl(${hue}, 70%, 60%)`;
        }

        // Extract all person names from assignment string
        function extractAllPersonNames(assignment) {
            if (!assignment) return [];
            
            // Match all patterns like "Name (Ομάδα X)"
            const matches = assignment.matchAll(/([^(]+)\s*\(Ομάδα\s*(\d+)\)/g);
            const persons = [];
            
            for (const match of matches) {
                if (match[1]) {
                    persons.push({
                        name: match[1].trim(),
                        group: parseInt(match[2])
                    });
                }
            }
            
            return persons;
        }

        // Get person colors for a day
        function getDayPersonColors(assignment) {
            if (!assignment) return [];
            
            const persons = extractAllPersonNames(assignment);
            return persons.map(p => ({
                color: getPersonColor(p.name),
                name: p.name,
                group: p.group
            }));
        }

        // Get holiday name for a date (checks special holidays first, then auto-detected Orthodox holidays)
        function getOrthodoxHolidayName(date) {
            // First check special holidays (user-defined)
            if (isSpecialHoliday(date)) {
                const key = formatDateKey(date);
                const holiday = specialHolidays.find(h => h.date === key);
                return holiday ? holiday.name : null;
            }
            
            // Then check auto-detected Orthodox/Cyprus holidays
            return getOrthodoxHolidayNameAuto(date);
        }

        // Render calendar
        function renderCalendar() {
            const calendarGrid = document.getElementById('calendarGrid');
            const currentMonthYear = document.getElementById('currentMonthYear');
            
            if (!calendarGrid || !currentMonthYear) {
                console.error('Calendar elements not found');
                return;
            }
            
            // CRITICAL: Restore critical assignments to day-type-specific documents before rendering
            // This ensures manually entered last duty dates are always visible
            Object.keys(criticalAssignments).forEach(dateKey => {
                const criticalPeople = criticalAssignments[dateKey];
                if (Array.isArray(criticalPeople) && criticalPeople.length > 0) {
                    const criticalStr = criticalPeople.join(', ');
                    const existingAssignment = getAssignmentForDate(dateKey);
                    if (!existingAssignment) {
                        // No assignment exists, add the critical one
                        setAssignmentForDate(dateKey, criticalStr);
                        console.log(`Restored critical assignment for ${dateKey}: ${criticalStr}`);
                    } else {
                        // Assignment exists, merge critical people if not already present
                        const existing = existingAssignment.split(', ');
                        let needsUpdate = false;
                        criticalPeople.forEach(person => {
                            if (!existing.includes(person)) {
                                existing.push(person);
                                needsUpdate = true;
                            }
                        });
                        if (needsUpdate) {
                            setAssignmentForDate(dateKey, existing.join(', '));
                            console.log(`Merged critical assignment for ${dateKey}: ${existing.join(', ')}`);
                        }
                    }
                }
            });
            
            const year = currentDate.getFullYear();
            const month = currentDate.getMonth();
            
            currentMonthYear.textContent = 
                currentDate.toLocaleDateString('el-GR', { month: 'long', year: 'numeric' });
            
            const firstDay = new Date(year, month, 1);
            const lastDay = new Date(year, month + 1, 0);
            const daysInMonth = lastDay.getDate();
            // Convert Sunday (0) to 6, Monday (1) to 0, etc. for Monday-first calendar
            let startingDayOfWeek = firstDay.getDay();
            startingDayOfWeek = startingDayOfWeek === 0 ? 6 : startingDayOfWeek - 1;
            
            const grid = calendarGrid;
            grid.innerHTML = '';
            
            // Day headers - Monday first
            const dayHeaders = ['Δευ', 'Τρι', 'Τετ', 'Πεμ', 'Παρ', 'Σαβ', 'Κυρ'];
            dayHeaders.forEach(header => {
                const headerDiv = document.createElement('div');
                headerDiv.className = 'calendar-day-header';
                headerDiv.textContent = header;
                grid.appendChild(headerDiv);
            });
            
            // Empty cells for days before month starts
            for (let i = 0; i < startingDayOfWeek; i++) {
                const emptyDiv = document.createElement('div');
                grid.appendChild(emptyDiv);
            }
            
            // Days of the month
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            
            for (let day = 1; day <= daysInMonth; day++) {
                const date = new Date(year, month, day);
                const dayType = getDayType(date);
                const isToday = date.getTime() === today.getTime();
                const key = formatDateKey(date);
                // Get assignment from the correct day-type-specific document
                const assignment = getAssignmentForDate(key);
                
                const dayDiv = document.createElement('div');
                // dayType is determined by getDayType() which handles:
                // - normal-day: green background (#E8F5E9)
                // - semi-normal-day: yellow background (#FFF9C4) - Fridays or days before holidays/weekends
                // - weekend-holiday: orange background (#FFE0B2) - weekends and regular holidays
                // - special-holiday: purple background (#E1BEE7) - special holidays
                // Note: December 30th is treated as normal-day (green) unless it's Friday or weekend
                
                // CRITICAL: Special holidays must always have purple color, even if they're also weekends/holidays
                // Remove conflicting day type classes and ensure special-holiday class is applied
                const isSpecial = isSpecialHoliday(date);
                if (isSpecial) {
                    // For special holidays, only use special-holiday class (purple color)
                    dayDiv.className = `calendar-day special-holiday ${isToday ? 'today' : ''}`;
                } else {
                    // For non-special holidays, use the normal dayType
                    dayDiv.className = `calendar-day ${dayType} ${isToday ? 'today' : ''}`;
                }
                
                // Set special holiday background and border
                if (isSpecial) {
                    // Set background and border for special holidays
                    dayDiv.style.background = '#E1BEE7';
                    dayDiv.style.borderColor = '#9C27B0';
                    // Also add a data attribute for CSS targeting if needed
                    dayDiv.setAttribute('data-special-holiday', 'true');
                }
                
                // Get holiday name (special holiday first, then Orthodox/Cyprus holiday)
                const holidayName = getOrthodoxHolidayName(date);
                
                // Parse assignment and display each person on a separate line (no commas)
                let displayAssignmentHtml = '';
                if (assignment) {
                    // Split by comma first, then extract person-group info from each part
                    const parts = assignment.split(',').map(p => p.trim()).filter(p => p);
                    const personGroups = [];
                    
                    parts.forEach(part => {
                        // Try to match "Name (Ομάδα X)" pattern
                        const match = part.match(/^(.+?)\s*\(Ομάδα\s*(\d+)\)\s*$/);
                        if (match) {
                            // Remove any leading/trailing commas from the name
                            const name = match[1].trim().replace(/^,+\s*/, '').replace(/\s*,+$/, '');
                            personGroups.push({
                                name: name,
                                group: match[2].trim(),
                                fullString: part
                            });
                        } else {
                            // If no group pattern, check if it's just a name
                            // Try to extract group info if it exists elsewhere in the string
                            const groupMatch = part.match(/\(Ομάδα\s*(\d+)\)/);
                            if (groupMatch) {
                                let name = part.replace(/\s*\(Ομάδα\s*\d+\)\s*/, '').trim();
                                name = name.replace(/^,+\s*/, '').replace(/\s*,+$/, ''); // Remove leading/trailing commas
                                personGroups.push({
                                    name: name,
                                    group: groupMatch[1],
                                    fullString: part
                                });
                            } else {
                                // Just a name without group info - remove commas
                                let name = part.replace(/^,+\s*/, '').replace(/\s*,+$/, '');
                                personGroups.push({
                                    name: name,
                                    group: null,
                                    fullString: part
                                });
                            }
                        }
                    });
                    
                    // Check if this date has critical assignments
                    const criticalPeople = criticalAssignments[key] || [];
                    
                    // Create a container div for all persons - each on separate line
                    displayAssignmentHtml = '<div class="duty-person-container">';
                    personGroups.forEach(({ name, group, fullString }) => {
                        // Check if this person-group combination is in critical assignments
                        const isCritical = criticalPeople.some(cp => {
                            if (group) {
                                return cp === fullString || (cp.includes(name) && cp.includes(`(Ομάδα ${group})`));
                            } else {
                                return cp.includes(name);
                            }
                        });
                        
                        // Apply red bold styling for critical assignments
                        const styleClass = isCritical ? 'duty-person-critical' : 'duty-person';
                        // Display only the name, no comma, each on separate line
                        displayAssignmentHtml += `<div class="${styleClass}">${name}</div>`;
                    });
                    displayAssignmentHtml += '</div>';
                }
                
                dayDiv.innerHTML = `
                    <div class="day-number">${day}</div>
                    ${holidayName ? `<div class="orthodox-holiday-name">${holidayName}</div>` : ''}
                    ${displayAssignmentHtml}
                `;
                
                // Add click handler AFTER setting innerHTML to ensure it's not removed
                dayDiv.style.cursor = 'pointer';
                dayDiv.setAttribute('data-date', key); // Store date key for debugging
                dayDiv.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    try {
                        showDayDetails(date);
                    } catch (error) {
                        console.error('Error showing day details:', error);
                        alert('Σφάλμα κατά το άνοιγμα των λεπτομερειών ημέρας: ' + error.message);
                    }
                });
                
                grid.appendChild(dayDiv);
            }
        }

        // Get day type label
        function getDayTypeLabel(dayType) {
            switch(dayType) {
                case 'special-holiday': return 'Ειδική';
                case 'normal-day': return 'Καθημερινή';
                case 'semi-normal-day': return 'Ημιαργία';
                case 'weekend-holiday': return 'Σαββατοκύριακο/Αργία';
                default: return '';
            }
        }

        // Previous month
        function previousMonth() {
            currentDate.setMonth(currentDate.getMonth() - 1);
            renderCalendar();
        }

        // Next month
        function nextMonth() {
            currentDate.setMonth(currentDate.getMonth() + 1);
            renderCalendar();
        }

        // Check if a person has duty on a specific day
        function hasDutyOnDay(dayKey, person, groupNum) {
            // Determine which document to check based on day type
            const date = new Date(dayKey + 'T00:00:00');
            if (isNaN(date.getTime())) return false;
            
            const dayType = getDayType(date);
            let assignment = null;
            
            if (dayType === 'special-holiday') {
                assignment = specialHolidayAssignments[dayKey];
            } else if (dayType === 'weekend-holiday') {
                assignment = weekendAssignments[dayKey];
            } else if (dayType === 'semi-normal-day') {
                assignment = semiNormalAssignments[dayKey];
            } else if (dayType === 'normal-day') {
                assignment = normalDayAssignments[dayKey];
            }
            
            // Also check legacy dutyAssignments for backward compatibility
            if (!assignment) {
                assignment = dutyAssignments[dayKey];
            }
            
            if (!assignment) return false;
            
            const personGroupStr = `${person} (Ομάδα ${groupNum})`;
            return assignment.includes(personGroupStr);
        }

        // Check if a person has duty on consecutive days (day before or day after)
        function hasConsecutiveDuty(dayKey, person, groupNum) {
            const date = new Date(dayKey + 'T00:00:00');
            const currentDayType = getDayType(date);
            
            // Get day type category for current day
            let currentTypeCategory = 'normal';
            if (currentDayType === 'special-holiday') {
                currentTypeCategory = 'special';
            } else if (currentDayType === 'semi-normal-day') {
                currentTypeCategory = 'semi';
            } else if (currentDayType === 'weekend-holiday') {
                currentTypeCategory = 'weekend';
            }
            
            // Check day before
            const dayBefore = new Date(date);
            dayBefore.setDate(dayBefore.getDate() - 1);
            const dayBeforeKey = formatDateKey(dayBefore);
            const hasDutyBefore = hasDutyOnDay(dayBeforeKey, person, groupNum);
            
            if (hasDutyBefore) {
                const beforeDayType = getDayType(dayBefore);
                let beforeTypeCategory = 'normal';
                if (beforeDayType === 'special-holiday') {
                    beforeTypeCategory = 'special';
                } else if (beforeDayType === 'semi-normal-day') {
                    beforeTypeCategory = 'semi';
                } else if (beforeDayType === 'weekend-holiday') {
                    beforeTypeCategory = 'weekend';
                }
                
                // Only flag if different day type (consecutive days of same type are prevented by N-day rotation)
                // OR if either day is a special holiday (special holidays have priority)
                const isConflict = currentTypeCategory !== beforeTypeCategory || currentDayType === 'special-holiday' || beforeDayType === 'special-holiday';
                if (isConflict) {
                    return true;
                }
            }
            
            // IMPORTANT: Also check day after if it's already been assigned
            // This handles cases where higher priority day types (semi, weekend, special) are assigned before lower priority (normal)
            // For example: Friday (semi-normal, Priority 3) is assigned before Thursday (normal, Priority 4)
            // When processing Thursday, we need to check if person already has duty on Friday
            const dayAfter = new Date(date);
            dayAfter.setDate(dayAfter.getDate() + 1);
            const dayAfterKey = formatDateKey(dayAfter);
            const dayAfterAssigned = dutyAssignments[dayAfterKey];
            const hasDutyAfter = dayAfterAssigned && hasDutyOnDay(dayAfterKey, person, groupNum);
            
            // Only check day after if it's already assigned (exists in dutyAssignments)
            // This means it was processed earlier due to higher priority
            if (hasDutyAfter) {
                const afterDayType = getDayType(dayAfter);
                let afterTypeCategory = 'normal';
                if (afterDayType === 'special-holiday') {
                    afterTypeCategory = 'special';
                } else if (afterDayType === 'semi-normal-day') {
                    afterTypeCategory = 'semi';
                } else if (afterDayType === 'weekend-holiday') {
                    afterTypeCategory = 'weekend';
                }
                
                // Only flag if different day type OR if either day is a special holiday
                const isConflict = currentTypeCategory !== afterTypeCategory || currentDayType === 'special-holiday' || afterDayType === 'special-holiday';
                if (isConflict) {
                    return true;
                }
            }
            
            return false;
        }


        // Check if person should be skipped from weekend/holiday duty due to special holiday duty
        // Logic:
        // 1. Find last weekend/holiday duty for the person
        // 2. Calculate what the next weekend/holiday duty should be (based on N-day rotation)
        // 3. Check if there's a special holiday duty between last weekend duty and the calculated next weekend duty
        // 4. If yes, skip the calculated next weekend duty
        // 5. Count N weekends from the day AFTER the skipped weekend
        // 6. If current day is the skipped weekend, return true to skip it
        function hadSpecialHolidayDutyBefore(dayKey, person, groupNum) {
            const date = new Date(dayKey + 'T00:00:00');
            const dayOfWeek = date.getDay(); // 0=Sunday, 6=Saturday
            const currentDayType = getDayType(date);
            
            // Only apply this rule if current day is:
            // - A weekend (Saturday or Sunday)
            // - OR a holiday (weekend-holiday type, but not special holiday)
            const isWeekend = dayOfWeek === 0 || dayOfWeek === 6; // Sunday or Saturday
            const isHoliday = currentDayType === 'weekend-holiday' && !isSpecialHoliday(date);
            
            if (!isWeekend && !isHoliday) {
                return false;
            }
            
            // Get group data to find rotation days
            const groupData = groups[groupNum] || { special: [], weekend: [], semi: [], normal: [] };
            const groupPeople = groupData.weekend || [];
            if (groupPeople.length === 0) return false;
            
            const rotationDays = groupPeople.length;
            
            // Find last weekend/holiday duty for this person
            let lastWeekendDutyKey = null;
            let lastWeekendDutyDate = null;
            
            // Check manually entered last duties first
            const lastDuties = groupData.lastDuties?.[person];
            if (lastDuties && lastDuties.weekend) {
                lastWeekendDutyDate = new Date(lastDuties.weekend + 'T00:00:00');
                lastWeekendDutyKey = formatDateKey(lastWeekendDutyDate);
            }
            
            // Also check actual assignments (use the more recent one)
            const checkDate = new Date(date);
            for (let i = 1; i <= 365; i++) { // Look back up to 1 year
                checkDate.setDate(checkDate.getDate() - 1);
                const checkKey = formatDateKey(checkDate);
                const checkDayType = getDayType(checkDate);
                const isCheckWeekend = checkDate.getDay() === 0 || checkDate.getDay() === 6;
                const isCheckHoliday = checkDayType === 'weekend-holiday' && !isSpecialHoliday(checkDate);
                
                if ((isCheckWeekend || isCheckHoliday) && hasDutyOnDay(checkKey, person, groupNum)) {
                    const checkDateCopy = new Date(checkDate);
                    if (!lastWeekendDutyDate || checkDateCopy > lastWeekendDutyDate) {
                        lastWeekendDutyDate = checkDateCopy;
                        lastWeekendDutyKey = checkKey;
                    }
                    break; // Found the most recent one
                }
            }
            
            if (!lastWeekendDutyKey || !lastWeekendDutyDate) {
                return false; // No previous weekend duty found
            }
            
            // Calculate what the next weekend/holiday duty should be (N weekends after last duty)
            let nextWeekendDutyDate = new Date(lastWeekendDutyDate);
            nextWeekendDutyDate.setDate(nextWeekendDutyDate.getDate() + 1); // Start from day after last duty
            let weekendsCounted = 0;
            let daysChecked = 0;
            const maxDaysToCheck = 365; // Don't check more than 1 year ahead
            
            while (weekendsCounted < rotationDays && daysChecked < maxDaysToCheck) {
                const checkDayType = getDayType(nextWeekendDutyDate);
                const isCheckWeekend = nextWeekendDutyDate.getDay() === 0 || nextWeekendDutyDate.getDay() === 6;
                const isCheckHoliday = checkDayType === 'weekend-holiday' && !isSpecialHoliday(nextWeekendDutyDate);
                
                if (isCheckWeekend || isCheckHoliday) {
                    weekendsCounted++;
                }
                
                if (weekendsCounted < rotationDays) {
                    nextWeekendDutyDate.setDate(nextWeekendDutyDate.getDate() + 1);
                    daysChecked++;
                }
            }
            
            if (weekendsCounted < rotationDays) {
                return false; // Couldn't find enough weekends
            }
            
            const nextWeekendDutyKey = formatDateKey(nextWeekendDutyDate);
            
            // Check if current day is the calculated next weekend duty
            if (dayKey !== nextWeekendDutyKey) {
                // Current day is not the calculated next weekend duty
                return false;
            }
            
            // Current day IS the calculated next weekend duty
            // Check if there's a special holiday duty between last weekend duty and this day
            let specialHolidayBetween = null;
            const checkSpecialDate = new Date(lastWeekendDutyDate);
            checkSpecialDate.setDate(checkSpecialDate.getDate() + 1);
            while (checkSpecialDate < date) {
                if (isSpecialHoliday(checkSpecialDate) && hasDutyOnDay(formatDateKey(checkSpecialDate), person, groupNum)) {
                    specialHolidayBetween = new Date(checkSpecialDate);
                    break;
                }
                checkSpecialDate.setDate(checkSpecialDate.getDate() + 1);
            }
            
            if (!specialHolidayBetween) {
                return false; // No special holiday between last and next weekend duty
            }
            
            // There is a special holiday between last weekend duty and this day
            // Skip this day (the calculated next weekend duty)
            return true;
        }

        // Check if person had duty on consecutive weekend/holiday days
        // If so, skip them from the next weekend/holiday
        // DISABLED: This logic was causing incorrect swaps on 01/02/26, 08/02/26, and 26/02/2026
        // TODO: Re-implement with corrected logic if needed
        function hasConsecutiveWeekendHolidayDuty(dayKey, person, groupNum) {
            // Temporarily disabled to prevent incorrect swaps
            return false;
        }

        // Check if person had duty on consecutive special holidays
        // If so, skip them from the next special holiday
        function hasConsecutiveSpecialHolidayDuty(dayKey, person, groupNum) {
            const date = new Date(dayKey + 'T00:00:00');
            
            // Only apply this rule if current day is a special holiday
            if (!isSpecialHoliday(date)) {
                return false;
            }
            
            // Check if person had duty on any previous special holiday
            // Look back up to 30 days to catch all special holidays
            for (let i = 1; i <= 30; i++) {
                const checkDate = new Date(date);
                checkDate.setDate(checkDate.getDate() - i);
                const checkKey = formatDateKey(checkDate);
                
                // If we find a special holiday where person had duty, it's consecutive
                // This prevents assigning the same person to multiple special holidays in a row
                if (isSpecialHoliday(checkDate) && hasDutyOnDay(checkKey, person, groupNum)) {
                    return true;
                }
            }
            
            return false;
        }

        // Check if person has special holiday duty in a given month
        function hasSpecialHolidayDutyInMonth(person, groupNum, month, year) {
            const firstDay = new Date(year, month, 1);
            const lastDay = new Date(year, month + 1, 0);
            const checkDate = new Date(firstDay);
            
            while (checkDate <= lastDay) {
                if (isSpecialHoliday(checkDate) && hasDutyOnDay(formatDateKey(checkDate), person, groupNum)) {
                    return true;
                }
                checkDate.setDate(checkDate.getDate() + 1);
            }
            return false;
        }

        // Count days of a specific type since last duty for a person
        // startDate is optional - if provided, will also check assignments before this date
        function countDaysSinceLastDuty(dayKey, person, groupNum, dayTypeCategory, allDaysByType, startDate = null) {
            const daysOfType = allDaysByType[dayTypeCategory];
            const currentIndex = daysOfType.indexOf(dayKey);
            
            if (currentIndex === -1) {
                return Infinity; // Current day not in this type
            }
            
            // Find last duty day for this person in this day type (before current day)
            let lastDutyIndex = -1;
            for (let i = currentIndex - 1; i >= 0; i--) {
                if (hasDutyOnDay(daysOfType[i], person, groupNum)) {
                    lastDutyIndex = i;
                    break;
                }
            }
            
            // Check intended assignments - these count for rotation even if person was skipped due to conflicts
            // This ensures N-day rotation counts from the intended day, not the actual assignment day
            // IMPORTANT: For weekends skipped due to special holiday, we need to count from the NEXT weekend after the skipped one
            let intendedDutyIndex = -1;
            
            for (let i = currentIndex - 1; i >= 0; i--) {
                const checkDayKey = daysOfType[i];
                // Check if this person had an intended assignment on this day
                if (intendedAssignments[checkDayKey] && 
                    intendedAssignments[checkDayKey][groupNum] === person) {
                    intendedDutyIndex = i;
                    
                    // If this is a weekend/holiday day that was skipped due to special holiday,
                    // we need to count from the NEXT weekend/holiday day after it (not from the skipped one)
                    if (dayTypeCategory === 'weekend' && i + 1 < daysOfType.length) {
                        // The next day in the daysOfType array is the next weekend/holiday day
                        // Count from the day AFTER that next weekend (start counting tomorrow)
                        const nextWeekendIndex = i + 1;
                        if (nextWeekendIndex < currentIndex) {
                            // Start counting from the day after the next weekend
                            return currentIndex - nextWeekendIndex - 1;
                        }
                    }
                    break;
                }
            }
            
            // Use intended assignment if it's more recent than actual assignment
            // This ensures rotation counts from when person SHOULD have been assigned, not when they actually were
            if (intendedDutyIndex !== -1 && (lastDutyIndex === -1 || intendedDutyIndex > lastDutyIndex)) {
                // Count from the day AFTER the intended assignment (start counting tomorrow)
                // If intended duty was at index i, we start counting from index i+1
                // So days passed = currentIndex - (intendedDutyIndex + 1) = currentIndex - intendedDutyIndex - 1
                return currentIndex - intendedDutyIndex - 1;
            }
            
            // Check lastDuties data first (manually entered last duties)
            const groupData = groups[groupNum] || { special: [], weekend: [], semi: [], normal: [], lastDuties: {} };
            const lastDuties = groupData.lastDuties?.[person];
            if (lastDuties) {
                const lastDutyDateStr = lastDuties[dayTypeCategory];
                if (lastDutyDateStr) {
                    const lastDutyDate = new Date(lastDutyDateStr + 'T00:00:00');
                    const currentDate = new Date(dayKey + 'T00:00:00');
                    
                    // Count days of the same type between last duty and current day
                    let sameTypeDays = 0;
                    const tempDate = new Date(lastDutyDate);
                    tempDate.setDate(tempDate.getDate() + 1);
                    while (tempDate < currentDate) {
                        const tempDayType = getDayType(tempDate);
                        let tempTypeCategory = 'normal';
                        if (tempDayType === 'special-holiday') {
                            tempTypeCategory = 'special';
                        } else if (tempDayType === 'semi-normal-day') {
                            tempTypeCategory = 'semi';
                        } else if (tempDayType === 'weekend-holiday') {
                            tempTypeCategory = 'weekend';
                        }
                        if (tempTypeCategory === dayTypeCategory) {
                            sameTypeDays++;
                        }
                        tempDate.setDate(tempDate.getDate() + 1);
                    }
                    
                    // If we found a last duty date, use it (unless we found a more recent one in assignments)
                    if (lastDutyIndex === -1 || (lastDutyDate > new Date(daysOfType[lastDutyIndex] + 'T00:00:00'))) {
                        return sameTypeDays;
                    }
                }
            }
            
            // If startDate is provided, also check existing assignments before the start date
            if (startDate && lastDutyIndex === -1) {
                const currentDate = new Date(dayKey + 'T00:00:00');
                const checkDate = new Date(startDate);
                checkDate.setDate(checkDate.getDate() - 1); // Day before start date
                
                // Look backwards from start date to find last duty
                let daysBack = 0;
                const maxDaysBack = 365; // Check up to 1 year back
                
                while (daysBack < maxDaysBack && checkDate >= new Date(2000, 0, 1)) { // Don't go before year 2000
                    const checkKey = formatDateKey(checkDate);
                    const checkDayType = getDayType(checkDate);
                    let checkTypeCategory = 'normal';
                    
                    if (checkDayType === 'special-holiday') {
                        checkTypeCategory = 'special';
                    } else if (checkDayType === 'semi-normal-day') {
                        checkTypeCategory = 'semi';
                    } else if (checkDayType === 'weekend-holiday') {
                        checkTypeCategory = 'weekend';
                    }
                    
                    // Only count if it's the same day type category
                    if (checkTypeCategory === dayTypeCategory && hasDutyOnDay(checkKey, person, groupNum)) {
                        // Found a previous duty - calculate days between
                        const daysBetween = Math.floor((currentDate - checkDate) / (1000 * 60 * 60 * 24));
                        // Count only days of the same type between them
                        let sameTypeDays = 0;
                        const tempDate = new Date(checkDate);
                        tempDate.setDate(tempDate.getDate() + 1);
                        while (tempDate < currentDate) {
                            const tempDayType = getDayType(tempDate);
                            let tempTypeCategory = 'normal';
                            if (tempDayType === 'special-holiday') {
                                tempTypeCategory = 'special';
                            } else if (tempDayType === 'semi-normal-day') {
                                tempTypeCategory = 'semi';
                            } else if (tempDayType === 'weekend-holiday') {
                                tempTypeCategory = 'weekend';
                            }
                            if (tempTypeCategory === dayTypeCategory) {
                                sameTypeDays++;
                            }
                            tempDate.setDate(tempDate.getDate() + 1);
                        }
                        return sameTypeDays;
                    }
                    
                    checkDate.setDate(checkDate.getDate() - 1);
                    daysBack++;
                }
            }
            
            if (lastDutyIndex === -1) {
                return Infinity; // Never had duty of this type
            }
            
            // Count how many days of this type between last duty and current day
            // If last duty was at index i, we start counting from index i+1 (tomorrow)
            // So days passed = currentIndex - (lastDutyIndex + 1) = currentIndex - lastDutyIndex - 1
            return currentIndex - lastDutyIndex - 1;
        }

        // Open calculate duties modal
        function openCalculateDutiesModal() {
            // Set default to current month
            const currentYear = currentDate.getFullYear();
            const currentMonth = String(currentDate.getMonth() + 1).padStart(2, '0');
            const startMonthInput = document.getElementById('calculateStartMonth');
            const endMonthInput = document.getElementById('calculateEndMonth');
            const preserveCheckbox = document.getElementById('preserveExistingAssignments');
            
            if (startMonthInput) {
                startMonthInput.value = `${currentYear}-${currentMonth}`;
            }
            if (endMonthInput) {
                endMonthInput.value = '';
            }
            if (preserveCheckbox) {
                preserveCheckbox.checked = true;
            }
            
            // Add event listener to button as backup (remove old listeners first)
            const calculateButton = document.getElementById('calculateDutiesButton');
            if (calculateButton) {
                // Clone button to remove all event listeners
                const newButton = calculateButton.cloneNode(true);
                calculateButton.parentNode.replaceChild(newButton, calculateButton);
                
                // Add new event listener
                newButton.addEventListener('click', function(e) {
                    e.preventDefault();
                    calculateDutiesForSelectedMonths();
                });
            }
            
            const modal = new bootstrap.Modal(document.getElementById('calculateDutiesModal'));
            modal.show();
        }

        // Calculate duties for selected months
        function calculateDutiesForSelectedMonths() {
            try {
                const startMonthInput = document.getElementById('calculateStartMonth');
                const endMonthInput = document.getElementById('calculateEndMonth');
                const preserveCheckbox = document.getElementById('preserveExistingAssignments');
                
                if (!startMonthInput || !preserveCheckbox) {
                    alert('Σφάλμα: Δεν βρέθηκαν τα απαραίτητα στοιχεία της φόρμας');
                    console.error('Missing form elements:', { startMonthInput, endMonthInput, preserveCheckbox });
                    return;
                }
                
                const startMonth = startMonthInput.value;
                const endMonth = endMonthInput ? endMonthInput.value : '';
                const preserveExisting = preserveCheckbox.checked;
                
                if (!startMonth) {
                    alert('Παρακαλώ επιλέξτε τουλάχιστον τον μήνα έναρξης');
                    return;
                }
                
                // Parse start date
                const [startYear, startMonthNum] = startMonth.split('-').map(Number);
                const startDate = new Date(startYear, startMonthNum - 1, 1);
                
                // Parse end date (or use start month if not specified)
                let endDate;
                if (endMonth) {
                    const [endYear, endMonthNum] = endMonth.split('-').map(Number);
                    endDate = new Date(endYear, endMonthNum, 0); // Last day of the month
                } else {
                    endDate = new Date(startYear, startMonthNum, 0); // Last day of start month
                }
                
                // Store calculation parameters for step-by-step process
                calculationSteps.startDate = startDate;
                calculationSteps.endDate = endDate;
                calculationSteps.preserveExisting = preserveExisting;
                calculationSteps.currentStep = 1;
                
                // Close month selection modal
                const monthModal = bootstrap.Modal.getInstance(document.getElementById('calculateDutiesModal'));
                if (monthModal) {
                    monthModal.hide();
                }
                
                // Start step-by-step calculation process
                showStepByStepCalculation();
            } catch (error) {
                console.error('Error in calculateDutiesForSelectedMonths:', error);
                alert('Σφάλμα κατά τον υπολογισμό: ' + error.message);
            }
        }
        
        // Show step-by-step calculation modal
        function showStepByStepCalculation() {
            calculationSteps.currentStep = 1;
            renderCurrentStep();
            const modal = new bootstrap.Modal(document.getElementById('stepByStepCalculationModal'));
            modal.show();
        }

        // Render current step content
        function renderCurrentStep() {
            const stepContent = document.getElementById('stepContent');
            const stepNumber = document.getElementById('currentStepNumber');
            const backButton = document.getElementById('backButton');
            const nextButton = document.getElementById('nextButton');
            const calculateButton = document.getElementById('calculateButton');
            
            stepNumber.textContent = calculationSteps.currentStep;
            
            // Show/hide navigation buttons
            backButton.style.display = calculationSteps.currentStep > 1 ? 'inline-block' : 'none';
            nextButton.style.display = calculationSteps.currentStep < calculationSteps.totalSteps ? 'inline-block' : 'none';
            calculateButton.style.display = calculationSteps.currentStep === calculationSteps.totalSteps ? 'inline-block' : 'none';
            
            // Render step content
            switch(calculationSteps.currentStep) {
                case 1:
                    renderStep1_SpecialHolidays();
                    break;
                case 2:
                    renderStep2_Weekends();
                    break;
                case 3:
                    renderStep3_SemiNormal();
                    break;
                case 4:
                    renderStep4_Normal();
                    break;
            }
        }

        // Step 1: Check and show special holidays
        function renderStep1_SpecialHolidays() {
            const stepContent = document.getElementById('stepContent');
            const startDate = calculationSteps.startDate;
            const endDate = calculationSteps.endDate;
            
            // Build day type lists
            const dayTypeLists = {
                special: [],
                weekend: [],
                semi: [],
                normal: []
            };
            
            const dateIterator = new Date(startDate);
            while (dateIterator <= endDate) {
                const dayType = getDayType(dateIterator);
                const key = formatDateKey(dateIterator);
                let typeCategory = 'normal';
                
                if (dayType === 'special-holiday') {
                    typeCategory = 'special';
                } else if (dayType === 'semi-normal-day') {
                    typeCategory = 'semi';
                } else if (dayType === 'weekend-holiday') {
                    typeCategory = 'weekend';
                }
                
                dayTypeLists[typeCategory].push(key);
                dateIterator.setDate(dateIterator.getDate() + 1);
            }
            
            calculationSteps.dayTypeLists = dayTypeLists;
            
            // Check for special holidays
            const specialHolidays = dayTypeLists.special;
            
            let html = '<div class="step-content">';
            html += '<h6 class="mb-3"><i class="fas fa-star text-warning me-2"></i>Βήμα 1: Ειδικές Αργίες</h6>';
            
            if (specialHolidays.length === 0) {
                html += '<div class="alert alert-info">';
                html += '<i class="fas fa-info-circle me-2"></i>';
                html += 'Δεν βρέθηκαν ειδικές αργίες στην επιλεγμένη περίοδο.';
                html += '</div>';
            } else {
                html += '<div class="alert alert-success">';
                html += `<i class="fas fa-check-circle me-2"></i>Βρέθηκαν <strong>${specialHolidays.length}</strong> ειδικές αργίες στην επιλεγμένη περίοδο.`;
                html += '</div>';
                
                html += '<div class="table-responsive mt-3">';
                html += '<table class="table table-bordered table-hover">';
                html += '<thead class="table-warning">';
                html += '<tr>';
                html += '<th>Ημερομηνία</th>';
                html += '<th>Όνομα Αργίας</th>';
                html += '<th>Ομάδα 1<br><small>ΕΠΙΚΕΦΑΛΗΣ-ΑΥΜ</small></th>';
                html += '<th>Ομάδα 2<br><small>ΜΗΧΑΝΙΚΟΣ-ΟΠΛΟΥΡΓΟΣ-ΟΔΗΓΟΣ</small></th>';
                html += '<th>Ομάδα 3<br><small>ΤΕΧΝΙΚΟΣ Ε/Π AW139</small></th>';
                html += '<th>Ομάδα 4<br><small>ΤΕΧΝΙΚΟΣ ΕΠΙΓΕΙΩΝ ΜΕΣΩΝ</small></th>';
                html += '</tr>';
                html += '</thead>';
                html += '<tbody>';
                
                // Sort special holidays by date
                const sortedSpecial = [...specialHolidays].sort();
                
                sortedSpecial.forEach((dateKey, specialIndex) => {
                    const date = new Date(dateKey + 'T00:00:00');
                    const dateStr = date.toLocaleDateString('el-GR', { day: '2-digit', month: '2-digit', year: 'numeric' });
                    const dayName = getGreekDayName(date);
                    
                    // Get holiday name
                    let holidayName = '';
                    const year = date.getFullYear();
                    const month = date.getMonth() + 1;
                    const day = date.getDate();
                    
                    // Check recurring holidays
                    for (const holidayDef of recurringSpecialHolidays) {
                        if (holidayDef.type === 'fixed' && holidayDef.month === month && holidayDef.day === day) {
                            holidayName = holidayDef.name;
                            break;
                        } else if (holidayDef.type === 'easter-relative') {
                            const orthodoxHolidays = calculateOrthodoxHolidays(year);
                            const easterDate = orthodoxHolidays.easterSunday;
                            const holidayDate = new Date(easterDate);
                            holidayDate.setDate(holidayDate.getDate() + (holidayDef.offset || 0));
                            if (formatDateKey(holidayDate) === dateKey) {
                                holidayName = holidayDef.name;
                                break;
                            }
                        }
                    }
                    
                    html += '<tr>';
                    html += `<td><strong>${dateStr}</strong><br><small class="text-muted">${dayName}</small></td>`;
                    html += `<td>${holidayName || 'Ειδική Αργία'}</td>`;
                    
                    // Calculate who will be assigned for each group based on rotation order
                    for (let groupNum = 1; groupNum <= 4; groupNum++) {
                        const groupData = groups[groupNum] || { special: [], weekend: [], semi: [], normal: [] };
                        const groupPeople = groupData.special || [];
                        
                        if (groupPeople.length === 0) {
                            html += '<td class="text-muted">-</td>';
                        } else {
                            // Use rotation order: specialIndex % rotationDays determines which person
                            const rotationDays = groupPeople.length;
                            const rotationPosition = specialIndex % rotationDays;
                            let assignedPerson = groupPeople[rotationPosition];
                            
                            // Check if assigned person is missing, if so find next in rotation
                            if (assignedPerson && isPersonMissingOnDate(assignedPerson, groupNum, date)) {
                                // Find next person in rotation who is not missing
                                for (let offset = 1; offset < rotationDays; offset++) {
                                    const nextIndex = (rotationPosition + offset) % rotationDays;
                                    const candidate = groupPeople[nextIndex];
                                    if (candidate && !isPersonMissingOnDate(candidate, groupNum, date)) {
                                        assignedPerson = candidate;
                                        break;
                                    }
                                }
                            }
                            
                            // Get last duty date and days since for display
                            let lastDutyInfo = '';
                            let daysCountInfo = '';
                            if (assignedPerson) {
                                const daysSince = countDaysSinceLastDuty(dateKey, assignedPerson, groupNum, 'special', dayTypeLists, startDate);
                                const dutyDates = getLastAndNextDutyDates(assignedPerson, groupNum, 'special', groupPeople.length);
                                lastDutyInfo = dutyDates.lastDuty !== 'Δεν έχει' ? `<br><small class="text-muted">Τελευταία: ${dutyDates.lastDuty}</small>` : '';
                                
                                // Show days counted in parentheses
                                if (daysSince !== null && daysSince !== Infinity) {
                                    daysCountInfo = ` <span class="text-info">(${daysSince}/${rotationDays} ημέρες)</span>`;
                                } else if (daysSince === Infinity) {
                                    daysCountInfo = ' <span class="text-success">(πρώτη φορά)</span>';
                                }
                            }
                            
                            html += `<td>${assignedPerson || '-'}${daysCountInfo}${lastDutyInfo}</td>`;
                        }
                    }
                    
                    html += '</tr>';
                });
                
                html += '</tbody>';
                html += '</table>';
                html += '</div>';
            }
            
            html += '</div>';
            stepContent.innerHTML = html;
        }

        // Navigation functions
        function goToNextStep() {
            if (calculationSteps.currentStep < calculationSteps.totalSteps) {
                calculationSteps.currentStep++;
                renderCurrentStep();
            }
        }

        function goToPreviousStep() {
            if (calculationSteps.currentStep > 1) {
                calculationSteps.currentStep--;
                renderCurrentStep();
            }
        }

        // Cancel step-by-step calculation
        function cancelStepByStepCalculation() {
            const modal = bootstrap.Modal.getInstance(document.getElementById('stepByStepCalculationModal'));
            if (modal) {
                modal.hide();
            }
            // Remove backdrop if it exists
            const backdrop = document.querySelector('.modal-backdrop');
            if (backdrop) {
                backdrop.remove();
            }
            // Remove modal-open class from body
            document.body.classList.remove('modal-open');
            document.body.style.overflow = '';
            document.body.style.paddingRight = '';
        }

        // Execute final calculation
        function executeCalculation() {
            const modal = bootstrap.Modal.getInstance(document.getElementById('stepByStepCalculationModal'));
            if (modal) {
                modal.hide();
            }
            
            // Execute the actual calculation
            const startDate = calculationSteps.startDate;
            const endDate = calculationSteps.endDate;
            const preserveExisting = calculationSteps.preserveExisting;
            
            // Store existing assignments if preserving
            const existingAssignments = preserveExisting ? { ...dutyAssignments } : {};
            
            // Clear assignments only for the selected date range if not preserving
            // BUT NEVER delete critical assignments (from last duties)
            if (!preserveExisting) {
                const dateIterator = new Date(startDate);
                while (dateIterator <= endDate) {
                    const key = formatDateKey(dateIterator);
                    // Check if this is a critical assignment - if so, preserve it
                    if (criticalAssignments[key] && criticalAssignments[key].length > 0) {
                        // This is a critical assignment - restore it if it was cleared
                        const criticalPeople = criticalAssignments[key];
                        dutyAssignments[key] = criticalPeople.join(', ');
                    } else {
                        // Not critical, safe to delete
                        delete dutyAssignments[key];
                    }
                    dateIterator.setDate(dateIterator.getDate() + 1);
                }
            }
            
            calculateDutiesForDateRange(startDate, endDate, preserveExisting);
            
            // Refresh calendar
            renderCalendar();
            
            alert('Ο υπολογισμός ολοκληρώθηκε!');
        }

        // Step 2: Check and show weekends/holidays
        function renderStep2_Weekends() {
            const stepContent = document.getElementById('stepContent');
            const startDate = calculationSteps.startDate;
            const endDate = calculationSteps.endDate;
            const dayTypeLists = calculationSteps.dayTypeLists || { weekend: [] };
            
            // Check for weekends/holidays
            const weekendHolidays = dayTypeLists.weekend || [];
            
            let html = '<div class="step-content">';
            html += '<h6 class="mb-3"><i class="fas fa-calendar-weekend text-info me-2"></i>Βήμα 2: Σαββατοκύριακα/Αργίες</h6>';
            
            if (weekendHolidays.length === 0) {
                html += '<div class="alert alert-info">';
                html += '<i class="fas fa-info-circle me-2"></i>';
                html += 'Δεν βρέθηκαν σαββατοκύριακα/αργίες στην επιλεγμένη περίοδο.';
                html += '</div>';
            } else {
                html += '<div class="alert alert-success">';
                html += `<i class="fas fa-check-circle me-2"></i>Βρέθηκαν <strong>${weekendHolidays.length}</strong> σαββατοκύριακα/αργίες στην επιλεγμένη περίοδο.`;
                html += '</div>';
                
                html += '<div class="table-responsive mt-3">';
                html += '<table class="table table-bordered table-hover">';
                html += '<thead class="table-info">';
                html += '<tr>';
                html += '<th>Ημερομηνία</th>';
                html += '<th>Όνομα Αργίας</th>';
                html += '<th>Ομάδα 1<br><small>ΕΠΙΚΕΦΑΛΗΣ-ΑΥΜ</small></th>';
                html += '<th>Ομάδα 2<br><small>ΜΗΧΑΝΙΚΟΣ-ΟΠΛΟΥΡΓΟΣ-ΟΔΗΓΟΣ</small></th>';
                html += '<th>Ομάδα 3<br><small>ΤΕΧΝΙΚΟΣ Ε/Π AW139</small></th>';
                html += '<th>Ομάδα 4<br><small>ΤΕΧΝΙΚΟΣ ΕΠΙΓΕΙΩΝ ΜΕΣΩΝ</small></th>';
                html += '</tr>';
                html += '</thead>';
                html += '<tbody>';
                
                // Sort weekends/holidays by date
                const sortedWeekends = [...weekendHolidays].sort();
                
                // Track skipped people per month per group (to match calculation logic)
                const skippedInMonth = {}; // groupNum -> monthKey -> Set of person names
                
                sortedWeekends.forEach((dateKey, weekendIndex) => {
                    const date = new Date(dateKey + 'T00:00:00');
                    const dateStr = date.toLocaleDateString('el-GR', { day: '2-digit', month: '2-digit', year: 'numeric' });
                    const dayName = getGreekDayName(date);
                    const month = date.getMonth();
                    const year = date.getFullYear();
                    
                    // Get holiday name
                    let holidayName = '';
                    const holidayNameAuto = getOrthodoxHolidayNameAuto(date);
                    if (holidayNameAuto) {
                        holidayName = holidayNameAuto;
                    } else if (date.getDay() === 0) {
                        holidayName = 'Κυριακή';
                    } else if (date.getDay() === 6) {
                        holidayName = 'Σάββατο';
                    } else {
                        holidayName = 'Αργία';
                    }
                    
                    html += '<tr>';
                    html += `<td><strong>${dateStr}</strong><br><small class="text-muted">${dayName}</small></td>`;
                    html += `<td>${holidayName || 'Αργία'}</td>`;
                    
                    // Calculate who will be assigned for each group based on rotation order
                    for (let groupNum = 1; groupNum <= 4; groupNum++) {
                        const groupData = groups[groupNum] || { special: [], weekend: [], semi: [], normal: [] };
                        const groupPeople = groupData.weekend || [];
                        
                        if (groupPeople.length === 0) {
                            html += '<td class="text-muted">-</td>';
                        } else {
                            // Initialize skipped tracking for this group/month
                            if (!skippedInMonth[groupNum]) {
                                skippedInMonth[groupNum] = {};
                            }
                            const monthKey = `${year}-${month}`;
                            if (!skippedInMonth[groupNum][monthKey]) {
                                skippedInMonth[groupNum][monthKey] = new Set();
                            }
                            
                            // Use rotation order: weekendIndex % rotationDays determines which person
                            const rotationDays = groupPeople.length;
                            const rotationPosition = weekendIndex % rotationDays;
                            let assignedPerson = groupPeople[rotationPosition];
                            let skippedPerson = null;
                            
                            // Check if assigned person has special holiday in same month or was already skipped
                            if (assignedPerson && !isPersonMissingOnDate(assignedPerson, groupNum, date)) {
                                if (hasSpecialHolidayDutyInMonth(assignedPerson, groupNum, month, year) || 
                                    skippedInMonth[groupNum][monthKey].has(assignedPerson)) {
                                    // Skip this person, find next in rotation who doesn't have special holiday
                                    skippedPerson = assignedPerson;
                                    skippedInMonth[groupNum][monthKey].add(assignedPerson);
                                    assignedPerson = null;
                                    
                                    for (let offset = 1; offset < rotationDays; offset++) {
                                        const nextIndex = (rotationPosition + offset) % rotationDays;
                                        const candidate = groupPeople[nextIndex];
                                        if (candidate && !isPersonMissingOnDate(candidate, groupNum, date) && 
                                            !hasSpecialHolidayDutyInMonth(candidate, groupNum, month, year) &&
                                            !skippedInMonth[groupNum][monthKey].has(candidate)) {
                                            assignedPerson = candidate;
                                            break;
                                        }
                                    }
                                }
                            } else if (assignedPerson && isPersonMissingOnDate(assignedPerson, groupNum, date)) {
                                // Person is missing, find next available in rotation
                                for (let offset = 1; offset < rotationDays; offset++) {
                                    const nextIndex = (rotationPosition + offset) % rotationDays;
                                    const candidate = groupPeople[nextIndex];
                                    if (candidate && !isPersonMissingOnDate(candidate, groupNum, date) && 
                                        !hasSpecialHolidayDutyInMonth(candidate, groupNum, month, year) &&
                                        !skippedInMonth[groupNum][monthKey].has(candidate)) {
                                        assignedPerson = candidate;
                                        break;
                                    }
                                }
                            }
                            
                            // Emergency fallback: if still no assignment, try all people in order
                            if (!assignedPerson) {
                                for (let i = 0; i < groupPeople.length; i++) {
                                    const candidate = groupPeople[i];
                                    if (candidate && !isPersonMissingOnDate(candidate, groupNum, date) && 
                                        !hasSpecialHolidayDutyInMonth(candidate, groupNum, month, year) &&
                                        !skippedInMonth[groupNum][monthKey].has(candidate)) {
                                        assignedPerson = candidate;
                                        break;
                                    }
                                }
                            }
                            
                            // Get last duty date and days since for display
                            let lastDutyInfo = '';
                            let daysCountInfo = '';
                            if (assignedPerson) {
                                const daysSince = countDaysSinceLastDuty(dateKey, assignedPerson, groupNum, 'weekend', dayTypeLists, startDate);
                                const dutyDates = getLastAndNextDutyDates(assignedPerson, groupNum, 'weekend', groupPeople.length);
                                lastDutyInfo = dutyDates.lastDuty !== 'Δεν έχει' ? `<br><small class="text-muted">Τελευταία: ${dutyDates.lastDuty}</small>` : '';
                                
                                // Show days counted in parentheses
                                if (daysSince !== null && daysSince !== Infinity) {
                                    daysCountInfo = ` <span class="text-info">(${daysSince}/${rotationDays} ημέρες)</span>`;
                                } else if (daysSince === Infinity) {
                                    daysCountInfo = ' <span class="text-success">(πρώτη φορά)</span>';
                                }
                            }
                            
                            html += `<td>${assignedPerson || '-'}${daysCountInfo}${lastDutyInfo}</td>`;
                        }
                    }
                    
                    html += '</tr>';
                });
                
                html += '</tbody>';
                html += '</table>';
                html += '</div>';
            }
            
            html += '</div>';
            stepContent.innerHTML = html;
        }

        function renderStep3_SemiNormal() {
            const stepContent = document.getElementById('stepContent');
            stepContent.innerHTML = '<div class="alert alert-info">Βήμα 3: Ημιαργίες (Υπό κατασκευή)</div>';
        }

        function renderStep4_Normal() {
            const stepContent = document.getElementById('stepContent');
            stepContent.innerHTML = '<div class="alert alert-info">Βήμα 4: Καθημερινές (Υπό κατασκευή)</div>';
        }
        
        // Expose to window for compatibility
        if (typeof window !== 'undefined') {
            window.calculateDutiesForSelectedMonths = calculateDutiesForSelectedMonths;
        }

        // Helper function to add/remove person from day assignment
        function assignPersonToDay(dayKey, person, groupNum) {
            const existingAssignment = getAssignmentForDate(dayKey);
            const personGroupStr = `${person} (Ομάδα ${groupNum})`;
            
            if (existingAssignment) {
                if (!existingAssignment.includes(personGroupStr)) {
                    // Add to existing assignment
                    setAssignmentForDate(dayKey, existingAssignment + `, ${personGroupStr}`);
                } else {
                    // Replace existing assignment for this group
                    const parts = existingAssignment.split(',').map(p => p.trim()).filter(p => p);
                    const filtered = parts.filter(p => !p.includes(`(Ομάδα ${groupNum})`));
                    filtered.push(personGroupStr);
                    setAssignmentForDate(dayKey, filtered.join(', '));
                }
            } else {
                // Create new assignment
                setAssignmentForDate(dayKey, personGroupStr);
            }
            
            // Clear intended assignment if person is now actually assigned on this day
            // This ensures we don't double-count when person actually gets assigned
            if (intendedAssignments[dayKey] && intendedAssignments[dayKey][groupNum] === person) {
                delete intendedAssignments[dayKey][groupNum];
                if (Object.keys(intendedAssignments[dayKey]).length === 0) {
                    delete intendedAssignments[dayKey];
                }
            }
        }

        function removePersonFromDay(dayKey, person, groupNum) {
            const existingAssignment = getAssignmentForDate(dayKey);
            if (!existingAssignment) return;
            
            const parts = existingAssignment.split(',').map(p => p.trim()).filter(p => p);
            const filtered = parts.filter(p => {
                const match = p.match(/^(.+?)\s*\(Ομάδα\s*(\d+)\)\s*$/);
                if (match && parseInt(match[2]) === groupNum) {
                    return match[1].trim() !== person;
                }
                return true;
            });
            
            if (filtered.length === 0) {
                deleteAssignmentForDate(dayKey);
            } else {
                setAssignmentForDate(dayKey, filtered.join(', '));
            }
        }

        // Helper function to check if person can take a day (no conflicts)
        function canPersonTakeDay(dayKey, person, groupNum, dayTypeCategory) {
            const dayDate = new Date(dayKey + 'T00:00:00');
            
            // Skip if person is missing on this date
            if (isPersonMissingOnDate(person, groupNum, dayDate)) return false;
            
            const priorityLevel = dayTypeCategory === 'special' ? 1 : 
                                (dayTypeCategory === 'weekend' ? 2 : 
                                (dayTypeCategory === 'semi' ? 3 : 4));
            
            const hasConsecutive = hasConsecutiveDuty(dayKey, person, groupNum);
            const hadSpecialBefore = hadSpecialHolidayDutyBefore(dayKey, person, groupNum);
            const hasConsecutiveWeekend = hasConsecutiveWeekendHolidayDuty(dayKey, person, groupNum);
            const hasConsecutiveSpecial = hasConsecutiveSpecialHolidayDuty(dayKey, person, groupNum);
            
            const strictConflict = (priorityLevel <= 2) && (hasConsecutiveSpecial || hasConsecutiveWeekend);
            const generalConflict = hasConsecutive || hadSpecialBefore;
            
            return !strictConflict && !generalConflict;
        }

        // Helper to find last duty key for a person
        function findLastDutyKeyForPerson(person, groupNum, dayTypeCategory, dayTypeLists, startDate, currentDayKey) {
            const days = dayTypeLists[dayTypeCategory];
            const sortedDays = [...days].sort();
            const currentDayIndex = sortedDays.indexOf(currentDayKey);
            
            // Look backwards from current day to find last assignment
            for (let i = currentDayIndex - 1; i >= 0; i--) {
                const dayKey = sortedDays[i];
                const assignment = dutyAssignments[dayKey] || '';
                if (assignment) {
                    const parts = assignment.split(',').map(p => p.trim());
                    for (const part of parts) {
                        const match = part.match(/^(.+?)\s*\(Ομάδα\s*(\d+)\)\s*$/);
                        if (match && parseInt(match[2]) === groupNum && match[1].trim() === person) {
                            return dayKey;
                        }
                    }
                }
            }
            
            // Check last duties from person data
            const groupData = groups[groupNum] || {};
            const personData = groupData.lastDuties && groupData.lastDuties[person];
            if (personData) {
                let lastDutyKey = null;
                if (dayTypeCategory === 'special' && personData.special) {
                    lastDutyKey = formatDateKey(new Date(personData.special));
                } else if (dayTypeCategory === 'weekend' && personData.weekend) {
                    lastDutyKey = formatDateKey(new Date(personData.weekend));
                } else if (dayTypeCategory === 'semi' && personData.semi) {
                    lastDutyKey = formatDateKey(new Date(personData.semi));
                } else if (dayTypeCategory === 'normal' && personData.normal) {
                    lastDutyKey = formatDateKey(new Date(personData.normal));
                }
                
                if (lastDutyKey && sortedDays.includes(lastDutyKey)) {
                    return lastDutyKey;
                }
            }
            
            return null;
        }

        // Helper function to find person's original day in rotation based on N-day rotation
        function findPersonOriginalDayInRotation(person, dayTypeCategory, groupNum, dayTypeLists, startDate, currentDayKey) {
            const groupData = groups[groupNum] || { special: [], weekend: [], semi: [], normal: [] };
            let groupPeople;
            if (dayTypeCategory === 'special') {
                groupPeople = groupData.special || [];
            } else if (dayTypeCategory === 'weekend') {
                groupPeople = groupData.weekend || [];
            } else if (dayTypeCategory === 'semi') {
                groupPeople = groupData.semi || [];
            } else {
                groupPeople = groupData.normal || [];
            }
            
            const personIndex = groupPeople.indexOf(person);
            if (personIndex === -1) return null;
            
            const days = dayTypeLists[dayTypeCategory];
            const sortedDays = [...days].sort();
            const currentDayIndex = sortedDays.indexOf(currentDayKey);
            
            // Calculate when this person should be assigned based on rotation
            const rotationDays = groupPeople.length;
            
            // Find the last duty date for this person
            const lastDutyKey = findLastDutyKeyForPerson(person, groupNum, dayTypeCategory, dayTypeLists, startDate, currentDayKey);
            
            // If person has never had duty, they should be assigned on their rotation position
            if (!lastDutyKey) {
                // Find first day where this person should be assigned
                for (let i = 0; i < sortedDays.length; i++) {
                    if (i % rotationDays === personIndex) {
                        return sortedDays[i];
                    }
                }
                return null;
            }
            
            // Find the next day where this person should be assigned (N days after last duty)
            const lastDutyIndex = sortedDays.indexOf(lastDutyKey);
            if (lastDutyIndex === -1) return null;
            
            // Find the day that is N positions after last duty
            const nextDutyIndex = lastDutyIndex + rotationDays;
            if (nextDutyIndex < sortedDays.length) {
                return sortedDays[nextDutyIndex];
            }
            
            return null;
        }

        // Helper function to find and assign person to next available day (cascade)
        function findAndAssignNextAvailableDay(person, skipDay, dayTypeCategory, groupNum, dayTypeLists, sortedDays, startDate) {
            const groupData = groups[groupNum] || { special: [], weekend: [], semi: [], normal: [] };
            
            // Find next available day after skipDay
            const skipIndex = sortedDays.indexOf(skipDay);
            if (skipIndex === -1) return false; // Day not found
            
            for (let i = skipIndex + 1; i < sortedDays.length; i++) {
                const dayKey = sortedDays[i];
                const dayDate = new Date(dayKey + 'T00:00:00');
                
                // Skip if person is missing on this date
                if (isPersonMissingOnDate(person, groupNum, dayDate)) continue;
                
                // Skip critical assignments
                const isCritical = criticalAssignments[dayKey] && 
                                criticalAssignments[dayKey].some(a => a.includes(`(Ομάδα ${groupNum})`));
                if (isCritical) continue;
                
                // Check if person can take this day (no conflicts)
                if (canPersonTakeDay(dayKey, person, groupNum, dayTypeCategory)) {
                    // Check if this day already has someone assigned for this group
                    const currentAssignment = dutyAssignments[dayKey] || '';
                    let currentPersonForGroup = null;
                    
                    if (currentAssignment) {
                        const parts = currentAssignment.split(',').map(p => p.trim());
                        for (const part of parts) {
                            const match = part.match(/^(.+?)\s*\(Ομάδα\s*(\d+)\)\s*$/);
                            if (match && parseInt(match[2]) === groupNum) {
                                currentPersonForGroup = match[1].trim();
                                break;
                            }
                        }
                    }
                    
                    if (currentPersonForGroup && currentPersonForGroup !== person) {
                        // Day already has someone - cascade: move that person forward
                        removePersonFromDay(dayKey, currentPersonForGroup, groupNum);
                        assignPersonToDay(dayKey, person, groupNum);
                        
                        // IMPORTANT: Re-check that this assignment doesn't create consecutive days
                        // Check day after to ensure we don't create consecutive days
                        const dayAfter = new Date(dayDate);
                        dayAfter.setDate(dayAfter.getDate() + 1);
                        const dayAfterKey = formatDateKey(dayAfter);
                        
                        // Check if person has duty the day after (would create consecutive days)
                        if (hasDutyOnDay(dayAfterKey, person, groupNum)) {
                            // This creates consecutive days - undo and try next day
                            removePersonFromDay(dayKey, person, groupNum);
                            assignPersonToDay(dayKey, currentPersonForGroup, groupNum); // Restore original
                            continue; // Try next day
                        }
                        
                        // Recursively find next day for the displaced person
                        findAndAssignNextAvailableDay(currentPersonForGroup, dayKey, dayTypeCategory, groupNum, dayTypeLists, sortedDays, startDate);
                    } else {
                        // Day is free - assign person here
                        assignPersonToDay(dayKey, person, groupNum);
                        
                        // IMPORTANT: Re-check that this assignment doesn't create consecutive days
                        const dayAfter = new Date(dayDate);
                        dayAfter.setDate(dayAfter.getDate() + 1);
                        const dayAfterKey = formatDateKey(dayAfter);
                        
                        // Check if person has duty the day after (would create consecutive days)
                        if (hasDutyOnDay(dayAfterKey, person, groupNum)) {
                            // This creates consecutive days - undo and try next day
                            removePersonFromDay(dayKey, person, groupNum);
                            continue; // Try next day
                        }
                    }
                    
                    return true; // Found and assigned
                }
            }
            
            return false; // No available day found
        }

        // Process cascading swaps for a day type
        function processCascadingSwaps(dayTypeCategory, groupNum, dayTypeLists, startDate) {
            const days = dayTypeLists[dayTypeCategory];
            if (days.length === 0) return;
            
            const groupData = groups[groupNum] || { special: [], weekend: [], semi: [], normal: [] };
            let groupPeople;
            if (dayTypeCategory === 'special') {
                groupPeople = groupData.special || [];
            } else if (dayTypeCategory === 'weekend') {
                groupPeople = groupData.weekend || [];
            } else if (dayTypeCategory === 'semi') {
                groupPeople = groupData.semi || [];
            } else {
                groupPeople = groupData.normal || [];
            }
            
            if (groupPeople.length === 0) return;
            
            const rotationDays = groupPeople.length;
            const priorityLevel = dayTypeCategory === 'special' ? 1 : 
                                (dayTypeCategory === 'weekend' ? 2 : 
                                (dayTypeCategory === 'semi' ? 3 : 4));
            
            // Process days in chronological order
            const sortedDays = [...days].sort();
            
            for (const dayKey of sortedDays) {
                const dayDate = new Date(dayKey + 'T00:00:00');
                
                // Skip critical assignments
                const isCritical = criticalAssignments[dayKey] && 
                                criticalAssignments[dayKey].some(a => a.includes(`(Ομάδα ${groupNum})`));
                if (isCritical) continue;
                
                // Get current assignment for this group on this day
                const currentAssignment = dutyAssignments[dayKey] || '';
                let currentPerson = null;
                if (currentAssignment) {
                    const parts = currentAssignment.split(',').map(p => p.trim());
                    for (const part of parts) {
                        const match = part.match(/^(.+?)\s*\(Ομάδα\s*(\d+)\)\s*$/);
                        if (match && parseInt(match[2]) === groupNum) {
                            currentPerson = match[1].trim();
                            break;
                        }
                    }
                }
                
                if (!currentPerson) continue; // No assignment yet, skip
                
                // Determine who SHOULD be assigned based on rotation order
                const personEligibility = [];
                
                for (let i = 0; i < groupPeople.length; i++) {
                    const person = groupPeople[i];
                    if (isPersonMissingOnDate(person, groupNum, dayDate)) continue;
                    
                    const daysSinceLastDuty = countDaysSinceLastDuty(dayKey, person, groupNum, dayTypeCategory, dayTypeLists, startDate);
                    const isEligible = daysSinceLastDuty >= rotationDays || daysSinceLastDuty === Infinity;
                    
                    personEligibility.push({
                        person: person,
                        index: i,
                        daysSinceLastDuty: daysSinceLastDuty,
                        isEligible: isEligible
                    });
                }
                
                // Sort by rotation order (eligibility, then days, then index)
                personEligibility.sort((a, b) => {
                    if (a.isEligible !== b.isEligible) {
                        return b.isEligible - a.isEligible;
                    }
                    if (a.daysSinceLastDuty !== b.daysSinceLastDuty) {
                        return b.daysSinceLastDuty - a.daysSinceLastDuty;
                    }
                    return a.index - b.index;
                });
                
                // Find who should be assigned (first person in rotation order)
                const expectedPerson = personEligibility.length > 0 ? personEligibility[0].person : null;
                
                if (!expectedPerson || expectedPerson === currentPerson) continue; // Already correct
                
                // Check if expected person has conflicts
                const hasConsecutive = hasConsecutiveDuty(dayKey, expectedPerson, groupNum);
                const hadSpecialBefore = hadSpecialHolidayDutyBefore(dayKey, expectedPerson, groupNum);
                const hasConsecutiveWeekend = hasConsecutiveWeekendHolidayDuty(dayKey, expectedPerson, groupNum);
                const hasConsecutiveSpecial = hasConsecutiveSpecialHolidayDuty(dayKey, expectedPerson, groupNum);
                
                const strictConflict = (priorityLevel <= 2) && (hasConsecutiveSpecial || hasConsecutiveWeekend);
                const generalConflict = hasConsecutive || hadSpecialBefore;
                
                // If expected person has no conflicts, they should be here - swap them in
                if (!strictConflict && !generalConflict) {
                    // Remove current person from this day
                    removePersonFromDay(dayKey, currentPerson, groupNum);
                    
                    // Assign expected person to this day
                    assignPersonToDay(dayKey, expectedPerson, groupNum);
                    
                    // IMPORTANT: Re-check that this assignment doesn't create consecutive days
                    // Check day after to ensure we don't create consecutive days
                    const dayAfter = new Date(dayDate);
                    dayAfter.setDate(dayAfter.getDate() + 1);
                    const dayAfterKey = formatDateKey(dayAfter);
                    
                    if (hasDutyOnDay(dayAfterKey, expectedPerson, groupNum)) {
                        // This creates consecutive days - undo the swap
                        removePersonFromDay(dayKey, expectedPerson, groupNum);
                        assignPersonToDay(dayKey, currentPerson, groupNum); // Restore original
                        // Track as intended assignment since expected person can't be assigned due to consecutive days
                        if (!intendedAssignments[dayKey]) {
                            intendedAssignments[dayKey] = {};
                        }
                        intendedAssignments[dayKey][groupNum] = expectedPerson;
                        // Find replacement person instead
                        // (fall through to the else block logic)
                    } else {
                        // Assignment is valid - now find next available day for current person (cascade)
                        findAndAssignNextAvailableDay(currentPerson, dayKey, dayTypeCategory, groupNum, dayTypeLists, sortedDays, startDate);
                        continue; // Skip the else block
                    }
                }
                
                // If we reach here, expected person has conflicts or creates consecutive days
                if (strictConflict || generalConflict) {
                    // Expected person has conflict - track as intended assignment
                    // This ensures N-day rotation counts from the intended day (this day), not the actual assignment day
                    if (!intendedAssignments[dayKey]) {
                        intendedAssignments[dayKey] = {};
                    }
                    intendedAssignments[dayKey][groupNum] = expectedPerson;
                    
                    // Expected person has conflict - find next person in rotation who can take this day
                    let replacementPerson = null;
                    
                    for (let i = 1; i < personEligibility.length; i++) {
                        const candidate = personEligibility[i];
                        const candidatePerson = candidate.person;
                        
                        const candidateHasConsecutive = hasConsecutiveDuty(dayKey, candidatePerson, groupNum);
                        const candidateHadSpecialBefore = hadSpecialHolidayDutyBefore(dayKey, candidatePerson, groupNum);
                        const candidateHasConsecutiveWeekend = hasConsecutiveWeekendHolidayDuty(dayKey, candidatePerson, groupNum);
                        const candidateHasConsecutiveSpecial = hasConsecutiveSpecialHolidayDuty(dayKey, candidatePerson, groupNum);
                        
                        const candidateStrictConflict = (priorityLevel <= 2) && (candidateHasConsecutiveSpecial || candidateHasConsecutiveWeekend);
                        const candidateGeneralConflict = candidateHasConsecutive || candidateHadSpecialBefore;
                        
                        if (!candidateStrictConflict && !candidateGeneralConflict) {
                            replacementPerson = candidatePerson;
                            break;
                        }
                    }
                    
                    if (replacementPerson && replacementPerson !== currentPerson) {
                        // Find where replacement person should be assigned (their original day in rotation)
                        const replacementOriginalDay = findPersonOriginalDayInRotation(replacementPerson, dayTypeCategory, groupNum, dayTypeLists, startDate, dayKey);
                        
                        // Remove current person from this day
                        removePersonFromDay(dayKey, currentPerson, groupNum);
                        
                        // Assign replacement person to this day
                        assignPersonToDay(dayKey, replacementPerson, groupNum);
                        
                        // Cascade: Try to assign expected person to replacement person's original day
                        if (replacementOriginalDay && replacementOriginalDay !== dayKey) {
                            // Check if expected person can take replacement's original day
                            const expectedCanTakeReplacementDay = canPersonTakeDay(replacementOriginalDay, expectedPerson, groupNum, dayTypeCategory);
                            
                            if (expectedCanTakeReplacementDay) {
                                // Remove replacement person from their original day (if assigned)
                                removePersonFromDay(replacementOriginalDay, replacementPerson, groupNum);
                                
                                // Assign expected person to replacement's original day
                                assignPersonToDay(replacementOriginalDay, expectedPerson, groupNum);
                                
                                // Now find next available day for replacement person
                                findAndAssignNextAvailableDay(replacementPerson, replacementOriginalDay, dayTypeCategory, groupNum, dayTypeLists, sortedDays, startDate);
                            } else {
                                // Expected person can't take replacement's day - cascade further
                                findAndAssignNextAvailableDay(expectedPerson, dayKey, dayTypeCategory, groupNum, dayTypeLists, sortedDays, startDate);
                                findAndAssignNextAvailableDay(replacementPerson, replacementOriginalDay, dayTypeCategory, groupNum, dayTypeLists, sortedDays, startDate);
                            }
                        } else {
                            // Find next available day for expected person
                            findAndAssignNextAvailableDay(expectedPerson, dayKey, dayTypeCategory, groupNum, dayTypeLists, sortedDays, startDate);
                        }
                        
                        // Find next available day for current person
                        findAndAssignNextAvailableDay(currentPerson, dayKey, dayTypeCategory, groupNum, dayTypeLists, sortedDays, startDate);
                    }
                }
            }
        }

        // Calculate duties for a specific date range
        function calculateDutiesForDateRange(startDate, endDate, preserveExisting = true) {
            
            // Clear intended assignments for the date range being calculated
            // This ensures fresh tracking for this calculation cycle
            const dateIterator = new Date(startDate);
            while (dateIterator <= endDate) {
                const key = formatDateKey(dateIterator);
                if (intendedAssignments[key]) {
                    delete intendedAssignments[key];
                }
                dateIterator.setDate(dateIterator.getDate() + 1);
            }
            
            // Process each group
            for (let groupNum = 1; groupNum <= 4; groupNum++) {
                const groupData = groups[groupNum] || { special: [], weekend: [], semi: [], normal: [], lastDuties: {}, missingPeriods: {}, priorities: {} };
                
                // Ensure priorities exist
                if (!groupData.priorities) groupData.priorities = {};
                
                // Sort each list by priority before calculating (to ensure correct rotation order)
                const listTypes = ['special', 'weekend', 'semi', 'normal'];
                listTypes.forEach(listType => {
                    if (groupData[listType] && groupData[listType].length > 0) {
                        groupData[listType].sort((a, b) => {
                            // Get priorities (default to 999 if not set)
                            const priorityA = groupData.priorities[a]?.[listType] ?? 999;
                            const priorityB = groupData.priorities[b]?.[listType] ?? 999;
                            
                            // First sort by priority (lower number = higher priority)
                            if (priorityA !== priorityB) {
                                return priorityA - priorityB;
                            }
                            
                            // If priorities are equal, sort by last duty date (most recent first, no date last)
                            const dateA = groupData.lastDuties?.[a]?.[listType];
                            const dateB = groupData.lastDuties?.[b]?.[listType];
                            
                            if (!dateA && !dateB) return 0; // Both have no date, maintain order
                            if (!dateA) return 1; // A has no date, put it last
                            if (!dateB) return -1; // B has no date, put it last
                            
                            // Both have dates, sort by date (most recent first)
                            return new Date(dateB) - new Date(dateA);
                        });
                    }
                });
                
                const specialPeople = groupData.special || [];
                const weekendPeople = groupData.weekend || [];
                const semiPeople = groupData.semi || [];
                const normalPeople = groupData.normal || [];
                
                if (specialPeople.length === 0 && weekendPeople.length === 0 && semiPeople.length === 0 && normalPeople.length === 0) continue;
                
                // Separate days by type with priority: special > weekend > semi > normal
                const dayTypeLists = {
                    special: [],  // Highest priority - special holidays
                    weekend: [],  // Second priority
                    semi: [],     // Third priority
                    normal: []   // Lowest priority
                };
                
                // Build lists of days by type
                const dateIterator = new Date(startDate);
                while (dateIterator <= endDate) {
                    const dayType = getDayType(dateIterator);
                    const key = formatDateKey(dateIterator);
                    let typeCategory = 'normal';
                    
                    if (dayType === 'special-holiday') {
                        typeCategory = 'special';
                    } else if (dayType === 'semi-normal-day') {
                        typeCategory = 'semi';
                    } else if (dayType === 'weekend-holiday') {
                        typeCategory = 'weekend';
                    }
                    
                    dayTypeLists[typeCategory].push(key);
                    dateIterator.setDate(dateIterator.getDate() + 1);
                }
                
                // Helper function to find next available day for a skipped person
                function findNextAvailableDayForPerson(person, groupNum, dayTypeCategory, startFromDayKey, dayTypeLists) {
                    const days = dayTypeLists[dayTypeCategory];
                    const startIndex = days.indexOf(startFromDayKey);
                    if (startIndex === -1) return null;
                    
                    // Find next day after startFromDayKey where person can be assigned
                    for (let i = startIndex + 1; i < days.length; i++) {
                        const dayKey = days[i];
                        const dayDate = new Date(dayKey + 'T00:00:00');
                        
                        // Skip if person is missing on this date
                        if (isPersonMissingOnDate(person, groupNum, dayDate)) {
                            continue;
                        }
                        
                        // Skip if day already has assignment for this group
                        const existingAssignment = getAssignmentForDate(dayKey);
                        if (existingAssignment && existingAssignment.includes(`(Ομάδα ${groupNum})`)) {
                            continue;
                        }
                        
                        // Check for conflicts based on day type
                        let hasConflict = false;
                        if (dayTypeCategory === 'semi') {
                            // Check consecutive day with weekend/holiday
                            const dayBefore = new Date(dayDate);
                            dayBefore.setDate(dayBefore.getDate() - 1);
                            const dayAfter = new Date(dayDate);
                            dayAfter.setDate(dayAfter.getDate() + 1);
                            
                            const beforeType = getDayType(dayBefore);
                            const afterType = getDayType(dayAfter);
                            
                            if ((beforeType === 'weekend-holiday' || beforeType === 'special-holiday') && hasDutyOnDay(formatDateKey(dayBefore), person, groupNum)) {
                                hasConflict = true;
                            }
                            if ((afterType === 'weekend-holiday' || afterType === 'special-holiday') && hasDutyOnDay(formatDateKey(dayAfter), person, groupNum)) {
                                hasConflict = true;
                            }
                        } else if (dayTypeCategory === 'normal') {
                            // Check consecutive day with semi-normal
                            const dayBefore = new Date(dayDate);
                            dayBefore.setDate(dayBefore.getDate() - 1);
                            const dayAfter = new Date(dayDate);
                            dayAfter.setDate(dayAfter.getDate() + 1);
                            
                            const beforeType = getDayType(dayBefore);
                            const afterType = getDayType(dayAfter);
                            
                            if (beforeType === 'semi-normal-day' && hasDutyOnDay(formatDateKey(dayBefore), person, groupNum)) {
                                hasConflict = true;
                            }
                            if (afterType === 'semi-normal-day' && hasDutyOnDay(formatDateKey(dayAfter), person, groupNum)) {
                                hasConflict = true;
                            }
                        }
                        
                        if (!hasConflict) {
                            return dayKey;
                        }
                    }
                    return null;
                }
                
                // Simplified assignment function for each day type
                function assignDutiesForDayType(dayTypeCategory) {
                    const days = dayTypeLists[dayTypeCategory];
                    if (days.length === 0) return;
                    
                    // Use the appropriate list for each day type
                    let groupPeople;
                    if (dayTypeCategory === 'special') {
                        groupPeople = groupData.special || [];
                    } else if (dayTypeCategory === 'weekend') {
                        groupPeople = groupData.weekend || [];
                    } else if (dayTypeCategory === 'semi') {
                        groupPeople = groupData.semi || [];
                    } else { // normal
                        groupPeople = groupData.normal || [];
                    }
                    
                    if (groupPeople.length === 0) return;
                    
                    const rotationDays = groupPeople.length;
                    
                    // Track which people have been skipped in this month (for weekends only)
                    // This helps us know who to skip when their turn comes again
                    const skippedInMonth = {}; // monthKey -> Set of person names
                    
                    // Process each day in order
                    days.forEach((dayKey, dayIndex) => {
                        // Skip if day already has assignment for this group (critical assignments)
                        const existingAssignment = getAssignmentForDate(dayKey);
                        if (existingAssignment && existingAssignment.includes(`(Ομάδα ${groupNum})`)) {
                            return;
                        }
                        
                        const dayDate = new Date(dayKey + 'T00:00:00');
                        const month = dayDate.getMonth();
                        const year = dayDate.getFullYear();
                        const monthKey = `${year}-${month}`;
                        
                        // Initialize skipped set for this month if needed
                        if (!skippedInMonth[monthKey]) {
                            skippedInMonth[monthKey] = new Set();
                        }
                        
                        // Find person who should be assigned based on rotation order
                        // Rotation: day 0 → person 0, day 1 → person 1, ..., day N → person 0 (cycle)
                        const rotationPosition = dayIndex % rotationDays;
                        let assignedPerson = null;
                        let skippedPerson = null;
                        
                        // Get the person at this rotation position
                        const expectedPerson = groupPeople[rotationPosition];
                        
                        // Check if expected person is missing on this date
                        if (expectedPerson && !isPersonMissingOnDate(expectedPerson, groupNum, dayDate)) {
                            // Check for conflicts based on day type
                            let hasConflict = false;
                            
                            if (dayTypeCategory === 'special') {
                                // No conflicts to check for special holidays
                                hasConflict = false;
                            } else if (dayTypeCategory === 'weekend') {
                                // Check if person has special holiday duty in the same month
                                // OR if they were already skipped in this month (their turn came again)
                                // If yes, skip them and continue with next person in rotation order
                                if (hasSpecialHolidayDutyInMonth(expectedPerson, groupNum, month, year) || 
                                    skippedInMonth[monthKey].has(expectedPerson)) {
                                    hasConflict = true;
                                }
                            } else if (dayTypeCategory === 'semi') {
                                // Check consecutive day with weekend/holiday
                                const dayBefore = new Date(dayDate);
                                dayBefore.setDate(dayBefore.getDate() - 1);
                                const dayAfter = new Date(dayDate);
                                dayAfter.setDate(dayAfter.getDate() + 1);
                                
                                const beforeType = getDayType(dayBefore);
                                const afterType = getDayType(dayAfter);
                                
                                if ((beforeType === 'weekend-holiday' || beforeType === 'special-holiday') && hasDutyOnDay(formatDateKey(dayBefore), expectedPerson, groupNum)) {
                                    hasConflict = true;
                                }
                                if ((afterType === 'weekend-holiday' || afterType === 'special-holiday') && hasDutyOnDay(formatDateKey(dayAfter), expectedPerson, groupNum)) {
                                    hasConflict = true;
                                }
                            } else if (dayTypeCategory === 'normal') {
                                // Check consecutive day with semi-normal
                                const dayBefore = new Date(dayDate);
                                dayBefore.setDate(dayBefore.getDate() - 1);
                                const dayAfter = new Date(dayDate);
                                dayAfter.setDate(dayAfter.getDate() + 1);
                                
                                const beforeType = getDayType(dayBefore);
                                const afterType = getDayType(dayAfter);
                                
                                if (beforeType === 'semi-normal-day' && hasDutyOnDay(formatDateKey(dayBefore), expectedPerson, groupNum)) {
                                    hasConflict = true;
                                }
                                if (afterType === 'semi-normal-day' && hasDutyOnDay(formatDateKey(dayAfter), expectedPerson, groupNum)) {
                                    hasConflict = true;
                                }
                            }
                            
                            // If expected person has NO conflicts, assign them
                            if (!hasConflict) {
                                assignedPerson = expectedPerson;
                            } else {
                                // Expected person has conflict - mark as skipped and find replacement
                                skippedPerson = expectedPerson;
                                
                                // For weekends: track that this person was skipped in this month
                                if (dayTypeCategory === 'weekend') {
                                    skippedInMonth[monthKey].add(expectedPerson);
                                }
                                
                                // For weekends: find next person in rotation order who doesn't have special holiday in same month
                                // Continue following rotation order, skipping anyone with special holiday in that month
                                let foundReplacement = false;
                                for (let offset = 1; offset < rotationDays && !foundReplacement; offset++) {
                                    const nextIndex = (rotationPosition + offset) % rotationDays;
                                    const candidate = groupPeople[nextIndex];
                                    
                                    if (!candidate || isPersonMissingOnDate(candidate, groupNum, dayDate)) {
                                        continue;
                                    }
                                    
                                    let candidateHasConflict = false;
                                    
                                    // Check conflicts for candidate
                                    if (dayTypeCategory === 'weekend') {
                                        // Skip if candidate has special holiday duty in the same month
                                        // OR if they were already skipped in this month
                                        if (hasSpecialHolidayDutyInMonth(candidate, groupNum, month, year) || 
                                            skippedInMonth[monthKey].has(candidate)) {
                                            // Continue to next person in rotation - don't assign this candidate
                                            continue;
                                        }
                                    } else if (dayTypeCategory === 'semi') {
                                        const dayBefore = new Date(dayDate);
                                        dayBefore.setDate(dayBefore.getDate() - 1);
                                        const dayAfter = new Date(dayDate);
                                        dayAfter.setDate(dayAfter.getDate() + 1);
                                        
                                        const beforeType = getDayType(dayBefore);
                                        const afterType = getDayType(dayAfter);
                                        
                                        if ((beforeType === 'weekend-holiday' || beforeType === 'special-holiday') && hasDutyOnDay(formatDateKey(dayBefore), candidate, groupNum)) {
                                            candidateHasConflict = true;
                                        }
                                        if ((afterType === 'weekend-holiday' || afterType === 'special-holiday') && hasDutyOnDay(formatDateKey(dayAfter), candidate, groupNum)) {
                                            candidateHasConflict = true;
                                        }
                                    } else if (dayTypeCategory === 'normal') {
                                        const dayBefore = new Date(dayDate);
                                        dayBefore.setDate(dayBefore.getDate() - 1);
                                        const dayAfter = new Date(dayDate);
                                        dayAfter.setDate(dayAfter.getDate() + 1);
                                        
                                        const beforeType = getDayType(dayBefore);
                                        const afterType = getDayType(dayAfter);
                                        
                                        if (beforeType === 'semi-normal-day' && hasDutyOnDay(formatDateKey(dayBefore), candidate, groupNum)) {
                                            candidateHasConflict = true;
                                        }
                                        if (afterType === 'semi-normal-day' && hasDutyOnDay(formatDateKey(dayAfter), candidate, groupNum)) {
                                            candidateHasConflict = true;
                                        }
                                    }
                                    
                                    if (!candidateHasConflict) {
                                        assignedPerson = candidate;
                                        foundReplacement = true;
                                        break;
                                    }
                                }
                                
                                // If we still haven't found a replacement after checking all people in rotation,
                                // it means everyone has special holiday in this month - this shouldn't happen,
                                // but as fallback, we'll try the emergency fallback below
                            }
                        }
                        
                        // Emergency fallback: if still no assignment, try all people in order
                        if (!assignedPerson) {
                            for (let i = 0; i < groupPeople.length; i++) {
                                const candidate = groupPeople[i];
                                if (!candidate || isPersonMissingOnDate(candidate, groupNum, dayDate)) {
                                    continue;
                                }
                                
                                let candidateHasConflict = false;
                                
                                if (dayTypeCategory === 'weekend') {
                                    if (hasSpecialHolidayDutyInMonth(candidate, groupNum, month, year)) {
                                        candidateHasConflict = true;
                                    }
                                } else if (dayTypeCategory === 'semi') {
                                    const dayBefore = new Date(dayDate);
                                    dayBefore.setDate(dayBefore.getDate() - 1);
                                    const dayAfter = new Date(dayDate);
                                    dayAfter.setDate(dayAfter.getDate() + 1);
                                    
                                    const beforeType = getDayType(dayBefore);
                                    const afterType = getDayType(dayAfter);
                                    
                                    if ((beforeType === 'weekend-holiday' || beforeType === 'special-holiday') && hasDutyOnDay(formatDateKey(dayBefore), candidate, groupNum)) {
                                        candidateHasConflict = true;
                                    }
                                    if ((afterType === 'weekend-holiday' || afterType === 'special-holiday') && hasDutyOnDay(formatDateKey(dayAfter), candidate, groupNum)) {
                                        candidateHasConflict = true;
                                    }
                                } else if (dayTypeCategory === 'normal') {
                                    const dayBefore = new Date(dayDate);
                                    dayBefore.setDate(dayBefore.getDate() - 1);
                                    const dayAfter = new Date(dayDate);
                                    dayAfter.setDate(dayAfter.getDate() + 1);
                                    
                                    const beforeType = getDayType(dayBefore);
                                    const afterType = getDayType(dayAfter);
                                    
                                    if (beforeType === 'semi-normal-day' && hasDutyOnDay(formatDateKey(dayBefore), candidate, groupNum)) {
                                        candidateHasConflict = true;
                                    }
                                    if (afterType === 'semi-normal-day' && hasDutyOnDay(formatDateKey(dayAfter), candidate, groupNum)) {
                                        candidateHasConflict = true;
                                    }
                                }
                                
                                if (!candidateHasConflict) {
                                    assignedPerson = candidate;
                                    break;
                                }
                            }
                        }
                        
                        // Assign person to day (uses setAssignmentForDate which saves to correct document)
                        if (assignedPerson) {
                            assignPersonToDay(dayKey, assignedPerson, groupNum);
                        }
                        
                        // If person was skipped due to conflict, find next available day for them
                        // Note: For weekends, if skipped due to special holiday in same month, don't reassign
                        // They will be assigned when their turn comes again in rotation
                        if (skippedPerson && skippedPerson !== assignedPerson && dayTypeCategory !== 'weekend') {
                            // Only find next available day for semi and normal (not weekend)
                            if (dayTypeCategory === 'semi' || dayTypeCategory === 'normal') {
                                const nextAvailableDay = findNextAvailableDayForPerson(skippedPerson, groupNum, dayTypeCategory, dayKey, dayTypeLists);
                                if (nextAvailableDay) {
                                    // Check if next available day already has assignment for this group
                                    const nextAssignment = getAssignmentForDate(nextAvailableDay);
                                    if (!nextAssignment || !nextAssignment.includes(`(Ομάδα ${groupNum})`)) {
                                        // Assign skipped person to next available day
                                        assignPersonToDay(nextAvailableDay, skippedPerson, groupNum);
                                    }
                                }
                            }
                        }
                    });
                }
                
                // Assign duties in priority order: special > weekend > semi > normal
                // Priority 1: Special Holidays (highest priority) - simple N-day rotation, no conflicts
                assignDutiesForDayType('special');
                
                // Priority 2: Weekend/Holiday days - N-day rotation, check for special holiday duty in same month
                assignDutiesForDayType('weekend');
                
                // Priority 3: Ημιαργία days - N-day rotation, check consecutive day conflicts with weekends/holidays
                assignDutiesForDayType('semi');
                
                // Priority 4: Καθημερινή days - N-day rotation, check consecutive day conflicts with semi-normal
                assignDutiesForDayType('normal');
                
                // Old loop - replaced with priority-based assignments above
                /*for (const typeCategory in dayTypeLists) {
                    const days = dayTypeLists[typeCategory];
                    if (days.length === 0) continue;
                    
                    const rotationDays = groupPeople.length;
                    let personIndex = 0;
                    
                    // Simple rotation: assign person 0 to day 0, person 1 to day 1, etc.
                    // After rotationDays days, cycle back to person 0
                    days.forEach((dayKey, dayIndex) => {
                        // Calculate which person should be on duty
                        // Every rotationDays days, we cycle through all people
                        const rotationPosition = dayIndex % rotationDays;
                        const person = groupPeople[rotationPosition];
                        
                        // Allow multiple groups to assign on the same day
                        if (dutyAssignments[dayKey]) {
                            dutyAssignments[dayKey] += `, ${person} (Ομάδα ${groupNum})`;
                        } else {
                            dutyAssignments[dayKey] = `${person} (Ομάδα ${groupNum})`;
                        }
                    });
                }*/
            }
            
            saveData();
            renderCalendar();
            alert('Οι αναθέσεις υπηρεσιών υπολογίστηκαν επιτυχώς για την επιλεγμένη περίοδο!');
        }

        // Store current day being edited
        let currentEditingDayKey = null;
        let currentEditingDayDate = null;

        // Show day details
        function showDayDetails(date) {
            try {
                const key = formatDateKey(date);
                const assignment = dutyAssignments[key];
                const dayType = getDayType(date);
                
                // Store selected date for manual assignment
                selectedDateForDuty = date;
                currentEditingDayKey = key;
                currentEditingDayDate = date;
                
                const modalElement = document.getElementById('dayDetailsModal');
                if (!modalElement) {
                    console.error('dayDetailsModal element not found');
                    alert('Το modal δεν βρέθηκε. Παρακαλώ ανανεώστε τη σελίδα.');
                    return;
                }
                
                const modal = new bootstrap.Modal(modalElement);
                const titleElement = document.getElementById('dayDetailsTitle');
                if (titleElement) {
                    titleElement.textContent = formatDate(date);
                }
            
            let content = `
                <div class="mb-3">
                    <strong>Τύπος Ημέρας:</strong> ${getDayTypeLabel(dayType)}
                </div>
            `;
            
            if (isSpecialHoliday(date)) {
                const holidayName = getOrthodoxHolidayName(date);
                const displayName = holidayName || 'Ειδική Αργία';
                
                content += `
                    <div class="alert alert-warning" style="background: #FFE082; border-color: #FFC107;">
                        <i class="fas fa-star me-2"></i>
                        <strong>Ειδική Αργία:</strong> ${displayName}
                    </div>
                `;
            } else if (isOrthodoxOrCyprusHoliday(date)) {
                const holidayName = getOrthodoxHolidayNameAuto(date);
                content += `
                    <div class="alert alert-info">
                        <i class="fas fa-church me-2"></i>
                        <strong>Ορθόδοξη/Κυπριακή Αργία:</strong> ${holidayName || 'Αργία'}
                    </div>
                `;
            } else if (isHoliday(date)) {
                const holiday = holidays.find(h => h.date === key);
                content += `
                    <div class="alert alert-info">
                        <i class="fas fa-calendar-times me-2"></i>
                        <strong>Αργία:</strong> ${holiday ? holiday.name : 'Αργία'}
                    </div>
                `;
            }
            
            // Extract person-group combinations - ensure one per group (1-4)
            const personGroups = [];
            const groupsFound = new Set();
            
            if (assignment) {
                // Split by comma first, then extract person-group info
                const parts = assignment.split(',').map(p => p.trim()).filter(p => p);
                
                parts.forEach(part => {
                    // Try to match "Name (Ομάδα X)" pattern
                    const match = part.match(/^(.+?)\s*\(Ομάδα\s*(\d+)\)\s*$/);
                    if (match) {
                        const name = match[1].trim().replace(/^,+\s*/, '').replace(/\s*,+$/, ''); // Remove leading/trailing commas
                        const group = parseInt(match[2]);
                        if (!groupsFound.has(group)) {
                            personGroups.push({
                                name: name,
                                group: group,
                                fullString: part
                            });
                            groupsFound.add(group);
                        }
                    } else {
                        // Try to extract group info if it exists elsewhere in the string
                        const groupMatch = part.match(/\(Ομάδα\s*(\d+)\)/);
                        if (groupMatch) {
                            const group = parseInt(groupMatch[1]);
                            const name = part.replace(/\s*\(Ομάδα\s*\d+\)\s*/, '').trim().replace(/^,+\s*/, '').replace(/\s*,+$/, '');
                            if (!groupsFound.has(group)) {
                                personGroups.push({
                                    name: name,
                                    group: group,
                                    fullString: part
                                });
                                groupsFound.add(group);
                            }
                        }
                    }
                });
            }
            
            // Ensure we have one person per group (1-4), even if not assigned
            for (let groupNum = 1; groupNum <= 4; groupNum++) {
                if (!groupsFound.has(groupNum)) {
                    personGroups.push({
                        name: '',
                        group: groupNum,
                        fullString: ''
                    });
                }
            }
            
            // Sort by group number
            personGroups.sort((a, b) => a.group - b.group);
            
            // Check critical assignments
            const criticalPeople = criticalAssignments[key] || [];
            
            // Create editable dropdown fields for each group
            content += `
                <div class="mb-3">
                    <strong><i class="fas fa-user-shield me-2"></i>Σε Υπηρεσία:</strong>
                    <div id="dutyPersonsContainer" class="mt-2">
            `;
            
            personGroups.forEach((person, index) => {
                const isCritical = person.name && criticalPeople.some(cp => {
                    if (person.group) {
                        return cp === person.fullString || (cp.includes(person.name) && cp.includes(`(Ομάδα ${person.group})`));
                    } else {
                        return cp.includes(person.name);
                    }
                });
                
                const groupName = person.group ? getGroupName(person.group) : 'Άγνωστη Ομάδα';
                const criticalClass = isCritical ? 'border-danger bg-light' : '';
                const criticalLabel = isCritical ? '<span class="badge bg-danger ms-2"><i class="fas fa-lock me-1"></i>Κρίσιμη (Απόβαση)</span>' : '';
                const disabledAttr = isCritical ? 'disabled' : '';
                const disabledTitle = isCritical ? 'title="Αυτή η ανάθεση είναι κρίσιμη και δεν μπορεί να αλλάξει"' : '';
                
                // Get all people from this group for dropdown
                const groupData = groups[person.group] || {};
                const allPeopleInGroup = new Set();
                ['special', 'weekend', 'semi', 'normal'].forEach(listType => {
                    if (groupData[listType]) {
                        groupData[listType].forEach(p => allPeopleInGroup.add(p));
                    }
                });
                const peopleList = Array.from(allPeopleInGroup).sort();
                
                // Build dropdown options
                let peopleOptions = '<option value="">-- Επιλέξτε Άτομο --</option>';
                peopleOptions += peopleList.map(p => 
                    `<option value="${p}" ${p === person.name ? 'selected' : ''}>${p}</option>`
                ).join('');
                
                content += `
                    <div class="mb-2 p-2 border rounded ${criticalClass}" ${disabledTitle}>
                        <label class="form-label small text-muted">Ομάδα ${person.group}: ${groupName}${criticalLabel}</label>
                        <select class="form-select duty-person-select" 
                                data-index="${index}" 
                                data-group="${person.group}" 
                                data-original-name="${person.name || ''}"
                                data-is-critical="${isCritical ? 'true' : 'false'}"
                                ${disabledAttr}>
                            ${peopleOptions}
                        </select>
                        ${isCritical ? '<small class="text-muted d-block mt-1"><i class="fas fa-info-circle me-1"></i>Αυτή η ανάθεση προέρχεται από τις ημερομηνίες τελευταίας υπηρεσίας και δεν μπορεί να αλλάξει.</small>' : ''}
                    </div>
                `;
            });
            
            content += `
                    </div>
                </div>
            `;
            
                document.getElementById('dayDetailsContent').innerHTML = content;
                
                // Buttons are now in the modal footer, no need to show/hide them
                modal.show();
            } catch (error) {
                console.error('Error in showDayDetails:', error);
                alert('Σφάλμα: ' + error.message);
            }
        }
        
        // Functions removed - no longer needed as we show all 4 groups with dropdowns
        
        // Save day assignments
        function saveDayAssignments() {
            if (!currentEditingDayKey) return;
            
            const container = document.getElementById('dutyPersonsContainer');
            const selects = container.querySelectorAll('.duty-person-select');
            const newAssignments = [];
            
            // Get original critical assignments
            const originalCritical = criticalAssignments[currentEditingDayKey] || [];
            const originalCriticalPeople = new Set();
            originalCritical.forEach(cp => {
                const match = cp.match(/^(.+?)\s*\(Ομάδα\s*(\d+)\)\s*$/);
                if (match) {
                    const name = match[1].trim().replace(/^,+\s*/, '').replace(/\s*,+$/, '');
                    const group = parseInt(match[2]);
                    originalCriticalPeople.add(`${name}|${group}`);
                }
            });
            
            selects.forEach(select => {
                const isCritical = select.dataset.isCritical === 'true';
                const personName = select.value.trim();
                const group = select.dataset.group;
                
                // If critical, use the original value (don't allow changes)
                if (isCritical) {
                    const originalName = select.dataset.originalName;
                    if (originalName && group) {
                        newAssignments.push(`${originalName} (Ομάδα ${group})`);
                    }
                } else if (personName && group) {
                    // Non-critical assignments can be changed
                    newAssignments.push(`${personName} (Ομάδα ${group})`);
                }
            });
            
            // Update dutyAssignments
            if (newAssignments.length > 0) {
                dutyAssignments[currentEditingDayKey] = newAssignments.join(', ');
            } else {
                delete dutyAssignments[currentEditingDayKey];
            }
            
            // Preserve all original critical assignments
            const newCritical = [];
            newAssignments.forEach(newAssignment => {
                const match = newAssignment.match(/^(.+?)\s*\(Ομάδα\s*(\d+)\)\s*$/);
                if (match) {
                    const name = match[1].trim().replace(/^,+\s*/, '').replace(/\s*,+$/, '');
                    const group = parseInt(match[2]);
                    if (originalCriticalPeople.has(`${name}|${group}`)) {
                        newCritical.push(newAssignment);
                    }
                }
            });
            
            if (newCritical.length > 0) {
                criticalAssignments[currentEditingDayKey] = newCritical;
            } else {
                delete criticalAssignments[currentEditingDayKey];
            }
            
            saveData();
            renderCalendar();
            
            // Close modal
            const modal = bootstrap.Modal.getInstance(document.getElementById('dayDetailsModal'));
            if (modal) {
                modal.hide();
            }
            
            alert('Οι αλλαγές αποθηκεύτηκαν επιτυχώς!');
        }

        // Open assign duty modal from day details
        function openAssignDutyModal() {
            // Close day details modal
            const dayDetailsModal = bootstrap.Modal.getInstance(document.getElementById('dayDetailsModal'));
            if (dayDetailsModal) {
                dayDetailsModal.hide();
            }
            
            openAssignDutyModalForDate(selectedDateForDuty);
        }

        // Open assign duty modal for a specific date (or current date if not specified)
        function openAssignDutyModalForDate(date = null) {
            // Clear previous event listeners
            const groupSelect = document.getElementById('assignDutyGroup');
            const newGroupSelect = groupSelect.cloneNode(true);
            groupSelect.parentNode.replaceChild(newGroupSelect, groupSelect);
            
            // Set date in assign modal
            const dateInput = document.getElementById('assignDutyDate');
            if (date) {
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                dateInput.value = `${year}-${month}-${day}`;
                selectedDateForDuty = date;
            } else {
                // Use today's date
                const today = new Date();
                const year = today.getFullYear();
                const month = String(today.getMonth() + 1).padStart(2, '0');
                const day = String(today.getDate()).padStart(2, '0');
                dateInput.value = `${year}-${month}-${day}`;
                selectedDateForDuty = today;
            }
            
            // Reset form
            document.getElementById('assignDutyGroup').value = '';
            document.getElementById('assignDutyPerson').innerHTML = '<option value="">Επιλέξτε Άτομο</option>';
            
            // Update person dropdown when group changes
            document.getElementById('assignDutyGroup').addEventListener('change', function() {
                updatePersonDropdown();
            });
            
            // Open modal
            const modal = new bootstrap.Modal(document.getElementById('assignDutyModal'));
            modal.show();
        }

        // Update person dropdown based on selected group
        function updatePersonDropdown() {
            const groupSelect = document.getElementById('assignDutyGroup');
            const personSelect = document.getElementById('assignDutyPerson');
            const selectedGroup = parseInt(groupSelect.value);
            
            personSelect.innerHTML = '<option value="">Επιλέξτε Άτομο</option>';
            
            if (selectedGroup && groups[selectedGroup]) {
                const groupData = groups[selectedGroup];
                const specialList = groupData.special || [];
                const weekendList = groupData.weekend || [];
                const semiList = groupData.semi || [];
                const normalList = groupData.normal || [];
                // Combine all lists, removing duplicates
                const allPeople = [...new Set([...specialList, ...weekendList, ...semiList, ...normalList])];
                
                if (allPeople.length > 0) {
                    allPeople.forEach(person => {
                        const option = document.createElement('option');
                        option.value = person;
                        option.textContent = person;
                        personSelect.appendChild(option);
                    });
                }
            }
        }

        // Save manual duty assignment
        function saveManualDuty() {
            const date = document.getElementById('assignDutyDate').value;
            const groupNum = parseInt(document.getElementById('assignDutyGroup').value);
            const person = document.getElementById('assignDutyPerson').value.trim();
            
            if (!date) {
                alert('Παρακαλώ επιλέξτε ημερομηνία');
                return;
            }
            
            if (!groupNum || !person) {
                alert('Παρακαλώ επιλέξτε ομάδα και άτομο');
                return;
            }
            
            const dateKey = formatDateKey(new Date(date + 'T00:00:00'));
            
            // Check if assignment already exists
            if (dutyAssignments[dateKey]) {
                // Update existing assignment
                const existing = dutyAssignments[dateKey];
                // Remove old assignment for this group if exists
                const updated = existing.split(', ').filter(a => !a.includes(`Ομάδα ${groupNum}`));
                updated.push(`${person} (Ομάδα ${groupNum})`);
                dutyAssignments[dateKey] = updated.join(', ');
            } else {
                // Create new assignment
                dutyAssignments[dateKey] = `${person} (Ομάδα ${groupNum})`;
            }
            
            saveData();
            renderCalendar();
            
            const modal = bootstrap.Modal.getInstance(document.getElementById('assignDutyModal'));
            modal.hide();
            
            alert('Η ανάθεση υπηρεσίας αποθηκεύτηκε επιτυχώς!');
        }

        // Remove duty assignment
        function removeDutyAssignment() {
            if (!selectedDateForDuty) return;
            
            if (!confirm('Είστε σίγουροι ότι θέλετε να αφαιρέσετε την ανάθεση υπηρεσίας για αυτή την ημέρα;')) {
                return;
            }
            
            const key = formatDateKey(selectedDateForDuty);
            delete dutyAssignments[key];
            
            saveData();
            renderCalendar();
            
            const modal = bootstrap.Modal.getInstance(document.getElementById('dayDetailsModal'));
            modal.hide();
            
            alert('Η ανάθεση υπηρεσίας αφαιρέθηκε επιτυχώς!');
        }

        // Check if person is missing on a specific date
        function isPersonMissingOnDate(person, groupNum, date) {
            const groupData = groups[groupNum] || { special: [], weekend: [], semi: [], normal: [], lastDuties: {}, missingPeriods: {} };
            const missingPeriods = groupData.missingPeriods?.[person] || [];
            if (missingPeriods.length === 0) return false;
            
            const checkDate = new Date(date);
            checkDate.setHours(0, 0, 0, 0);
            
            return missingPeriods.some(period => {
                const start = new Date(period.start + 'T00:00:00');
                const end = new Date(period.end + 'T00:00:00');
                return checkDate >= start && checkDate <= end;
            });
        }

        // Open missing period modal
        let currentMissingPeriodGroup = null;
        let currentMissingPeriodPerson = null;
        
        function openMissingPeriodModal(groupNum, person) {
            currentMissingPeriodGroup = groupNum;
            currentMissingPeriodPerson = person;
            
            document.getElementById('missingPeriodPersonName').textContent = person;
            document.getElementById('missingPeriodStart').value = '';
            document.getElementById('missingPeriodEnd').value = '';
            
            renderMissingPeriodsList();
            
            const modal = new bootstrap.Modal(document.getElementById('missingPeriodModal'));
            modal.show();
        }

        // Render missing periods list
        function renderMissingPeriodsList() {
            const container = document.getElementById('missingPeriodsList');
            const groupData = groups[currentMissingPeriodGroup] || { special: [], weekend: [], semi: [], normal: [], lastDuties: {}, missingPeriods: {} };
            const missingPeriods = groupData.missingPeriods?.[currentMissingPeriodPerson] || [];
            
            if (missingPeriods.length === 0) {
                container.innerHTML = '<p class="text-muted text-center small">Δεν υπάρχουν καταχωρημένες περιόδοι απουσίας</p>';
                return;
            }
            
            container.innerHTML = missingPeriods.map((period, index) => {
                const startDate = new Date(period.start + 'T00:00:00');
                const endDate = new Date(period.end + 'T00:00:00');
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                const isActive = today >= startDate && today <= endDate;
                const isPast = today > endDate;
                const isFuture = today < startDate;
                
                let statusBadge = '';
                if (isActive) statusBadge = '<span class="badge bg-warning ms-2">Ενεργή</span>';
                else if (isPast) statusBadge = '<span class="badge bg-secondary ms-2">Παρελθούσα</span>';
                else if (isFuture) statusBadge = '<span class="badge bg-info ms-2">Μελλοντική</span>';
                
                return `
                    <div class="card mb-2">
                        <div class="card-body">
                            <div class="d-flex justify-content-between align-items-center">
                                <div>
                                    <strong>${formatDate(startDate)}</strong> - <strong>${formatDate(endDate)}</strong>
                                    ${statusBadge}
                                </div>
                                <button class="btn btn-sm btn-outline-danger" onclick="removeMissingPeriod(${index})">
                                    <i class="fas fa-trash"></i>
                                </button>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        // Add missing period
        function addMissingPeriod() {
            const start = document.getElementById('missingPeriodStart').value;
            const end = document.getElementById('missingPeriodEnd').value;
            
            if (!start || !end) {
                alert('Παρακαλώ συμπληρώστε και τις δύο ημερομηνίες');
                return;
            }
            
            const startDate = new Date(start + 'T00:00:00');
            const endDate = new Date(end + 'T00:00:00');
            
            if (endDate < startDate) {
                alert('Η ημερομηνία λήξης πρέπει να είναι μετά την ημερομηνία έναρξης');
                return;
            }
            
            const groupData = groups[currentMissingPeriodGroup] || { special: [], weekend: [], semi: [], normal: [], lastDuties: {}, missingPeriods: {} };
            if (!groupData.missingPeriods) groupData.missingPeriods = {};
            if (!groupData.missingPeriods[currentMissingPeriodPerson]) {
                groupData.missingPeriods[currentMissingPeriodPerson] = [];
            }
            
            groupData.missingPeriods[currentMissingPeriodPerson].push({
                start: start,
                end: end
            });
            
            // Sort periods by start date
            groupData.missingPeriods[currentMissingPeriodPerson].sort((a, b) => {
                return new Date(a.start) - new Date(b.start);
            });
            
            document.getElementById('missingPeriodStart').value = '';
            document.getElementById('missingPeriodEnd').value = '';
            
            saveData();
            renderMissingPeriodsList();
            renderGroups();
        }

        // Remove missing period
        function removeMissingPeriod(index) {
            if (!confirm('Είστε σίγουροι ότι θέλετε να αφαιρέσετε αυτή την περίοδο απουσίας;')) {
                return;
            }
            
            const groupData = groups[currentMissingPeriodGroup] || { special: [], weekend: [], semi: [], normal: [], lastDuties: {}, missingPeriods: {} };
            if (groupData.missingPeriods && groupData.missingPeriods[currentMissingPeriodPerson]) {
                groupData.missingPeriods[currentMissingPeriodPerson].splice(index, 1);
                if (groupData.missingPeriods[currentMissingPeriodPerson].length === 0) {
                    delete groupData.missingPeriods[currentMissingPeriodPerson];
                }
            }
            
            saveData();
            renderMissingPeriodsList();
            renderGroups();
        }

        // Toggle list collapse/expand
        function toggleListCollapse(listId, chevronId) {
            const listElement = document.getElementById(listId);
            const chevronElement = document.getElementById(chevronId);
            
            if (listElement && chevronElement) {
                // Check current state BEFORE toggling
                const isCurrentlyShown = listElement.classList.contains('show');
                
                // Toggle Bootstrap collapse
                const bsCollapse = new bootstrap.Collapse(listElement, {
                    toggle: true
                });
                
                // Update chevron icon based on what the state WILL BE (opposite of current)
                if (isCurrentlyShown) {
                    // Currently shown, will be hidden - show down arrow
                    chevronElement.classList.remove('fa-chevron-up');
                    chevronElement.classList.add('fa-chevron-down');
                } else {
                    // Currently hidden, will be shown - show up arrow
                    chevronElement.classList.remove('fa-chevron-down');
                    chevronElement.classList.add('fa-chevron-up');
                }
            }
        }
        
        // Expose to window for onclick handlers
        if (typeof window !== 'undefined') {
            window.toggleListCollapse = toggleListCollapse;
        }

        // Update statistics
        function updateStatistics() {
            let totalPeople = 0;
            let totalRotation = 0;
            let groupCount = 0;
            
            for (let i = 1; i <= 4; i++) {
                const groupData = groups[i] || { special: [], weekend: [], semi: [], normal: [], lastDuties: {} };
                const specialList = groupData.special || [];
                const weekendList = groupData.weekend || [];
                const semiList = groupData.semi || [];
                const normalList = groupData.normal || [];
                // Count unique people across all lists
                const uniquePeople = new Set([...specialList, ...weekendList, ...semiList, ...normalList]);
                const peopleCount = uniquePeople.size;
                
                if (peopleCount > 0) {
                    totalPeople += peopleCount;
                    totalRotation += peopleCount;
                    groupCount++;
                }
            }
            
            document.getElementById('totalPeople').textContent = totalPeople;
            document.getElementById('avgRotation').textContent = 
                groupCount > 0 ? Math.round(totalRotation / groupCount) : 0;
        }

        // Helper function to get consecutive duty dates for detailed violation messages
        function getConsecutiveDutyDates(dayKey, person, groupNum) {
            const consecutiveDates = [];
            const date = new Date(dayKey + 'T00:00:00');
            
            // Check day before
            const dayBefore = new Date(date);
            dayBefore.setDate(dayBefore.getDate() - 1);
            const dayBeforeKey = formatDateKey(dayBefore);
            if (hasDutyOnDay(dayBeforeKey, person, groupNum)) {
                consecutiveDates.push(dayBeforeKey);
            }
            
            // Check day after
            const dayAfter = new Date(date);
            dayAfter.setDate(dayAfter.getDate() + 1);
            const dayAfterKey = formatDateKey(dayAfter);
            if (dutyAssignments[dayAfterKey] && hasDutyOnDay(dayAfterKey, person, groupNum)) {
                consecutiveDates.push(dayAfterKey);
            }
            
            return consecutiveDates;
        }
        
        // Helper function to get the special holiday date that caused a weekend skip
        function getSpecialHolidayBeforeDate(dayKey, person, groupNum) {
            const date = new Date(dayKey + 'T00:00:00');
            
            // Get group data to find rotation days
            const groupData = groups[groupNum] || { special: [], weekend: [], semi: [], normal: [] };
            const groupPeople = groupData.weekend || [];
            if (groupPeople.length === 0) return null;
            
            // Find last weekend/holiday duty for this person
            let lastWeekendDutyDate = null;
            
            // Check manually entered last duties first
            const lastDuties = groupData.lastDuties?.[person];
            if (lastDuties && lastDuties.weekend) {
                lastWeekendDutyDate = new Date(lastDuties.weekend + 'T00:00:00');
            }
            
            // Also check actual assignments (use the more recent one)
            const checkDate = new Date(date);
            for (let i = 1; i <= 365; i++) {
                checkDate.setDate(checkDate.getDate() - 1);
                const checkKey = formatDateKey(checkDate);
                const checkDayType = getDayType(checkDate);
                const isCheckWeekend = checkDate.getDay() === 0 || checkDate.getDay() === 6;
                const isCheckHoliday = checkDayType === 'weekend-holiday' && !isSpecialHoliday(checkDate);
                
                if ((isCheckWeekend || isCheckHoliday) && hasDutyOnDay(checkKey, person, groupNum)) {
                    const checkDateCopy = new Date(checkDate);
                    if (!lastWeekendDutyDate || checkDateCopy > lastWeekendDutyDate) {
                        lastWeekendDutyDate = checkDateCopy;
                    }
                    break;
                }
            }
            
            if (!lastWeekendDutyDate) return null;
            
            // Check if there's a special holiday between last weekend duty and current day
            const checkSpecialDate = new Date(lastWeekendDutyDate);
            checkSpecialDate.setDate(checkSpecialDate.getDate() + 1);
            while (checkSpecialDate < date) {
                if (isSpecialHoliday(checkSpecialDate) && hasDutyOnDay(formatDateKey(checkSpecialDate), person, groupNum)) {
                    return formatDateKey(checkSpecialDate);
                }
                checkSpecialDate.setDate(checkSpecialDate.getDate() + 1);
            }
            
            return null;
        }
        
        // Helper function to get missing period for a person on a specific date
        function getPersonMissingPeriod(person, groupNum, date) {
            const groupData = groups[groupNum] || {};
            const personData = groupData.missingPeriods?.[person];
            if (!personData || !Array.isArray(personData)) return null;
            
            for (const period of personData) {
                const startDate = new Date(period.start + 'T00:00:00');
                const endDate = new Date(period.end + 'T00:00:00');
                if (date >= startDate && date <= endDate) {
                    return {
                        start: startDate,
                        end: endDate
                    };
                }
            }
            return null;
        }
        
        // Analyze rotation violations
        function analyzeRotationViolations() {
            const violations = [];
            
            // Get dates only for the current month being viewed
            const year = currentDate.getFullYear();
            const month = currentDate.getMonth();
            const firstDay = new Date(year, month, 1);
            const lastDay = new Date(year, month + 1, 0);
            const daysInMonth = lastDay.getDate();
            
            // Build list of dates for current month
            const allDates = [];
            for (let day = 1; day <= daysInMonth; day++) {
                const date = new Date(year, month, day);
                allDates.push(formatDateKey(date));
            }
            
            // For each date, check each group
            for (const dayKey of allDates) {
                const date = new Date(dayKey + 'T00:00:00');
                const dayType = getDayType(date);
                
                // Determine day type category
                let dayTypeCategory = 'normal';
                if (dayType === 'special-holiday') {
                    dayTypeCategory = 'special';
                } else if (dayType === 'weekend-holiday') {
                    dayTypeCategory = 'weekend';
                } else if (dayType === 'semi-normal-day') {
                    dayTypeCategory = 'semi';
                }
                
                // Check each group
                for (let groupNum = 1; groupNum <= 4; groupNum++) {
                    const groupData = groups[groupNum];
                    if (!groupData) continue;
                    
                    // Get the appropriate list for this day type
                    let groupPeople;
                    if (dayTypeCategory === 'special') {
                        groupPeople = groupData.special || [];
                    } else if (dayTypeCategory === 'weekend') {
                        groupPeople = groupData.weekend || [];
                    } else if (dayTypeCategory === 'semi') {
                        groupPeople = groupData.semi || [];
                    } else {
                        groupPeople = groupData.normal || [];
                    }
                    
                    if (groupPeople.length === 0) continue;
                    
                    // Get who is actually assigned (from correct day-type document)
                    const assignment = getAssignmentForDate(dayKey) || '';
                    let assignedPerson = null;
                    if (assignment) {
                        const parts = assignment.split(',').map(p => p.trim()).filter(p => p);
                        for (const part of parts) {
                            const match = part.match(/^(.+?)\s*\(Ομάδα\s*(\d+)\)\s*$/);
                            if (match && parseInt(match[2]) === groupNum) {
                                assignedPerson = match[1].trim();
                                break;
                            }
                        }
                    }
                    
                    // Skip if no one is assigned (shouldn't happen, but handle it)
                    if (!assignedPerson) continue;
                    
                    // Skip if this is a critical assignment (from last duties)
                    const isCritical = criticalAssignments[dayKey] && 
                                      criticalAssignments[dayKey].some(a => a.includes(`(Ομάδα ${groupNum})`));
                    if (isCritical) continue; // Critical assignments are baseline, not violations
                    
                    // Determine who SHOULD be assigned based on strict N-day rotation
                    const rotationDays = groupPeople.length;
                    
                    // Calculate eligibility for all people
                    const personEligibility = [];
                    for (let i = 0; i < groupPeople.length; i++) {
                        const person = groupPeople[i];
                        
                        // Skip if person is missing on this date
                        if (isPersonMissingOnDate(person, groupNum, date)) {
                            continue;
                        }
                        
                        // Count days since last duty for this day type
                        // We need to build the day type list first
                        const startDate = new Date(date);
                        startDate.setFullYear(startDate.getFullYear() - 1); // Look back 1 year
                        const endDate = new Date(date);
                        endDate.setDate(endDate.getDate() + 1);
                        
                        // Build list of days of this type up to current date
                        const daysOfType = [];
                        const tempDate = new Date(startDate);
                        while (tempDate < endDate) {
                            const tempDayType = getDayType(tempDate);
                            let tempTypeCategory = 'normal';
                            if (tempDayType === 'special-holiday') {
                                tempTypeCategory = 'special';
                            } else if (tempDayType === 'semi-normal-day') {
                                tempTypeCategory = 'semi';
                            } else if (tempDayType === 'weekend-holiday') {
                                tempTypeCategory = 'weekend';
                            }
                            
                            if (tempTypeCategory === dayTypeCategory) {
                                daysOfType.push(formatDateKey(tempDate));
                            }
                            tempDate.setDate(tempDate.getDate() + 1);
                        }
                        
                        const daysSinceLastDuty = countDaysSinceLastDuty(dayKey, person, groupNum, dayTypeCategory, { [dayTypeCategory]: daysOfType }, startDate);
                        const isEligible = daysSinceLastDuty >= rotationDays || daysSinceLastDuty === Infinity;
                        
                        personEligibility.push({
                            person: person,
                            index: i,
                            daysSinceLastDuty: daysSinceLastDuty,
                            isEligible: isEligible
                        });
                    }
                    
                    // Sort by eligibility and days since last duty
                    personEligibility.sort((a, b) => {
                        if (a.isEligible !== b.isEligible) {
                            return b.isEligible - a.isEligible;
                        }
                        if (a.daysSinceLastDuty !== b.daysSinceLastDuty) {
                            return b.daysSinceLastDuty - a.daysSinceLastDuty;
                        }
                        return a.index - b.index;
                    });
                    
                    // Find who should be assigned (first eligible person without conflicts)
                    let expectedPerson = null;
                    let violationReason = '';
                    
                    for (let i = 0; i < personEligibility.length; i++) {
                        const candidate = personEligibility[i];
                        const candidatePerson = candidate.person;
                        
                        // Check conflicts
                        const hasConsecutive = hasConsecutiveDuty(dayKey, candidatePerson, groupNum);
                        const hadSpecialBefore = hadSpecialHolidayDutyBefore(dayKey, candidatePerson, groupNum);
                        const hasConsecutiveWeekend = hasConsecutiveWeekendHolidayDuty(dayKey, candidatePerson, groupNum);
                        const hasConsecutiveSpecial = hasConsecutiveSpecialHolidayDuty(dayKey, candidatePerson, groupNum);
                        
                        // Priority-based conflict checking
                        const priorityLevel = dayTypeCategory === 'special' ? 1 : 
                                           (dayTypeCategory === 'weekend' ? 2 : 
                                           (dayTypeCategory === 'semi' ? 3 : 4));
                        
                        const strictConflict = (priorityLevel <= 2) && (hasConsecutiveSpecial || hasConsecutiveWeekend);
                        const generalConflict = hasConsecutive || hadSpecialBefore;
                        
                        if (candidate.isEligible && !strictConflict && !generalConflict) {
                            expectedPerson = candidatePerson;
                            break;
                        }
                    }
                    
                    // If no eligible person without conflicts, use first eligible person
                    if (!expectedPerson && personEligibility.length > 0 && personEligibility[0].isEligible) {
                        expectedPerson = personEligibility[0].person;
                    }
                    
                    // If still no one, use first person in rotation order
                    if (!expectedPerson && personEligibility.length > 0) {
                        expectedPerson = personEligibility[0].person;
                    }
                    
                    // Compare assigned vs expected
                    if (expectedPerson && assignedPerson !== expectedPerson) {
                        // Determine reason
                        const assignedIndex = personEligibility.findIndex(p => p.person === assignedPerson);
                        const expectedIndex = personEligibility.findIndex(p => p.person === expectedPerson);
                        
                        if (assignedIndex === -1) {
                            violationReason = 'Το άτομο που ανέθεται δεν είναι στη λίστα περιστροφής';
                        } else {
                            const assignedData = personEligibility[assignedIndex];
                            const expectedData = personEligibility[expectedIndex];
                            
                            // Check why expected person was skipped - get detailed conflict information
                            const hasConsecutive = hasConsecutiveDuty(dayKey, expectedPerson, groupNum);
                            const hadSpecialBefore = hadSpecialHolidayDutyBefore(dayKey, expectedPerson, groupNum);
                            const hasConsecutiveWeekend = hasConsecutiveWeekendHolidayDuty(dayKey, expectedPerson, groupNum);
                            const hasConsecutiveSpecial = hasConsecutiveSpecialHolidayDuty(dayKey, expectedPerson, groupNum);
                            
                            // Check if person is missing on this date
                            const isMissing = isPersonMissingOnDate(expectedPerson, groupNum, date);
                            
                            // Get detailed information about conflicts
                            let conflictDetails = [];
                            
                            // Check if person is missing
                            if (isMissing) {
                                const missingPeriod = getPersonMissingPeriod(expectedPerson, groupNum, date);
                                if (missingPeriod) {
                                    const startStr = missingPeriod.start.toLocaleDateString('el-GR', { day: '2-digit', month: '2-digit', year: 'numeric' });
                                    const endStr = missingPeriod.end.toLocaleDateString('el-GR', { day: '2-digit', month: '2-digit', year: 'numeric' });
                                    conflictDetails.push(`Άτομο λείπει: ${startStr} - ${endStr}`);
                                } else {
                                    conflictDetails.push(`Άτομο λείπει`);
                                }
                            }
                            
                            // Check consecutive days and get the dates
                            if (hasConsecutive) {
                                const consecutiveDates = getConsecutiveDutyDates(dayKey, expectedPerson, groupNum);
                                if (consecutiveDates.length > 0) {
                                    const datesStr = consecutiveDates.map(d => {
                                        const dDate = new Date(d + 'T00:00:00');
                                        return dDate.toLocaleDateString('el-GR', { day: '2-digit', month: '2-digit' });
                                    }).join(', ');
                                    conflictDetails.push(`Συνεχόμενες ημέρες: ${datesStr}`);
                                }
                            }
                            
                            // Check special holiday skip and get the special holiday date
                            if (hadSpecialBefore) {
                                const specialHolidayDate = getSpecialHolidayBeforeDate(dayKey, expectedPerson, groupNum);
                                if (specialHolidayDate) {
                                    const specialDate = new Date(specialHolidayDate + 'T00:00:00');
                                    const specialDateStr = specialDate.toLocaleDateString('el-GR', { day: '2-digit', month: '2-digit', year: 'numeric' });
                                    const holidayName = getOrthodoxHolidayName(specialDate) || 'Ειδική Αργία';
                                    conflictDetails.push(`Ειδική αργία: ${holidayName} (${specialDateStr})`);
                                }
                            }
                            
                            // Check consecutive weekend/holiday
                            if (hasConsecutiveWeekend) {
                                conflictDetails.push(`Συνεχόμενα σαββατοκύριακα/αργίες`);
                            }
                            
                            // Check consecutive special holidays
                            if (hasConsecutiveSpecial) {
                                conflictDetails.push(`Συνεχόμενες ειδικές αργίες`);
                            }
                            
                            // Build detailed violation reason
                            if (isMissing) {
                                violationReason = 'Άτομο λείπει την ημερομηνία';
                                if (conflictDetails.length > 0) {
                                    violationReason += ` (${conflictDetails.join('; ')})`;
                                }
                            } else if (hasConsecutiveSpecial) {
                                violationReason = 'Αποφυγή συνεχόμενων ειδικών αργιών';
                                if (conflictDetails.length > 0) {
                                    violationReason += ` (${conflictDetails.join('; ')})`;
                                }
                            } else if (hasConsecutiveWeekend) {
                                violationReason = 'Αποφυγή συνεχόμενων σαββατοκύριακων/αργιών';
                                if (conflictDetails.length > 0) {
                                    violationReason += ` (${conflictDetails.join('; ')})`;
                                }
                            } else if (hasConsecutive) {
                                violationReason = 'Αποφυγή συνεχόμενων ημερών';
                                if (conflictDetails.length > 0) {
                                    violationReason += ` (${conflictDetails.join('; ')})`;
                                }
                            } else if (hadSpecialBefore) {
                                violationReason = 'Παράλειψη λόγω προηγούμενης ειδικής αργίας';
                                if (conflictDetails.length > 0) {
                                    violationReason += ` (${conflictDetails.join('; ')})`;
                                }
                            } else if (!expectedData.isEligible) {
                                violationReason = `Το άτομο που έπρεπε να ανέθεται δεν έχει περάσει ${rotationDays} ημέρες από την τελευταία υπηρεσία (έχει περάσει ${expectedData.daysSinceLastDuty})`;
                            } else if (assignedData.daysSinceLastDuty < expectedData.daysSinceLastDuty) {
                                // The expected person (who was NOT assigned) has more days than the assigned person
                                // Check if we found any actual conflicts
                                if (conflictDetails.length > 0) {
                                    violationReason = `Το άτομο που έπρεπε να ανέθεται (${expectedData.daysSinceLastDuty} ημέρες) παραλείφθηκε λόγω συγκρούσεων. Ανέθεθηκε άτομο με ${assignedData.daysSinceLastDuty} ημέρες (${conflictDetails.join('; ')})`;
                                } else {
                                    // No conflicts found - this indicates a potential bug or unexpected behavior
                                    violationReason = `⚠️ Το άτομο που έπρεπε να ανέθεται (${expectedData.daysSinceLastDuty} ημέρες) παραλείφθηκε ΧΩΡΙΣ να εντοπιστεί σύγκρουση. Ανέθεθηκε άτομο με ${assignedData.daysSinceLastDuty} ημέρες. Αυτό μπορεί να υποδεικνύει σφάλμα στη λογική ανάθεσης.`;
                                }
                            } else {
                                violationReason = 'Αλλαγή λόγω προτεραιότητας ή άλλου περιορισμού';
                            }
                        }
                        
                        violations.push({
                            date: dayKey,
                            dateFormatted: date.toLocaleDateString('el-GR', { day: '2-digit', month: '2-digit', year: 'numeric' }),
                            group: groupNum,
                            groupName: getGroupName(groupNum),
                            assignedPerson: assignedPerson,
                            expectedPerson: expectedPerson,
                            reason: violationReason,
                            dayType: getDayTypeLabel(dayType)
                        });
                    }
                }
            }
            
            // Display violations in modal
            displayRotationViolations(violations);
        }

        // Display rotation violations in modal
        function displayRotationViolations(violations) {
            const tableBody = document.getElementById('rotationViolationsTableBody');
            const noViolationsMsg = document.getElementById('noViolationsMessage');
            
            if (!tableBody) return;
            
            tableBody.innerHTML = '';
            
            if (violations.length === 0) {
                tableBody.parentElement.parentElement.style.display = 'none';
                if (noViolationsMsg) noViolationsMsg.style.display = 'block';
            } else {
                tableBody.parentElement.parentElement.style.display = 'table';
                if (noViolationsMsg) noViolationsMsg.style.display = 'none';
                
                violations.forEach(violation => {
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td>${violation.dateFormatted}</td>
                        <td><span class="badge bg-primary">${violation.groupName}</span></td>
                        <td><strong>${violation.assignedPerson}</strong></td>
                        <td><strong class="text-danger">${violation.expectedPerson}</strong></td>
                        <td><small>${violation.reason}</small></td>
                    `;
                    tableBody.appendChild(row);
                });
            }
            
            // Show modal
            const modal = new bootstrap.Modal(document.getElementById('rotationViolationsModal'));
            modal.show();
        }
    </script>
</body>
</html>

